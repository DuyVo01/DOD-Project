This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-25T10:41:49.843Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
Archetype.cs
Archetype.cs.meta
ArchetypeManager.cs
ArchetypeManager.cs.meta
ComponentType.cs
ComponentType.cs.meta
IComponent.cs
IComponent.cs.meta
QueryDescription.cs
QueryDescription.cs.meta
World.cs
World.cs.meta

================================================================
Repository Files
================================================================

================
File: Archetype.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace ECS_Core
{
    public class Archetype
    {
        private const int DEFAULT_INITIAL_CAPACITY = 16;
        private const float GROWTH_FACTOR = 2.0f;
        private readonly HashSet<ComponentType> componentTypes = new();
        private readonly Dictionary<ComponentType, Array> componentArrays = new();
        private readonly List<int> entities = new();
        private readonly Dictionary<int, int> entityToIndex = new();
        private int count = 0;

        public Archetype(ComponentType[] types)
        {
            foreach (var type in types)
            {
                componentTypes.Add(type);
                componentArrays[type] = Array.CreateInstance(type.Type, DEFAULT_INITIAL_CAPACITY); // Initial capacity
            }
        }

        public bool HasComponent(ComponentType type) => componentTypes.Contains(type);

        public T[] GetComponentArray<T>()
            where T : struct, IComponent
        {
            var type = ComponentType.Of<T>();
            return (T[])componentArrays[type];
        }

        public void Add(int entityId, Dictionary<ComponentType, object> components)
        {
            if (count == componentArrays.First().Value.Length)
            {
                Grow();
            }

            entityToIndex[entityId] = count;
            entities.Add(entityId);

            foreach (var kvp in components)
            {
                var array = componentArrays[kvp.Key];
                Array.Copy(new[] { kvp.Value }, 0, array, count, 1);
            }

            count++;
        }

        // New overload for when components are already copied
        public void AddWithoutComponents(int entityId)
        {
            if (count == componentArrays.First().Value.Length)
            {
                Grow();
            }

            entityToIndex[entityId] = count;
            entities.Add(entityId);
            count++;
        }

        public void RemoveEntity(int entityId)
        {
            if (!entityToIndex.TryGetValue(entityId, out int indexToRemove))
                return;

            int lastIndex = count - 1;
            if (indexToRemove < lastIndex)
            {
                int lastEntityId = entities[lastIndex];

                foreach (var componentArray in componentArrays.Values)
                {
                    Array.Copy(componentArray, lastIndex, componentArray, indexToRemove, 1);
                }

                entityToIndex[lastEntityId] = indexToRemove;
                entities[indexToRemove] = lastEntityId;
            }

            entityToIndex.Remove(entityId);
            entities.RemoveAt(count - 1);
            count--;
        }

        private void Grow()
        {
            var newCapacity = (int)(componentArrays.First().Value.Length * GROWTH_FACTOR);
            foreach (var type in componentArrays.Keys.ToList())
            {
                var oldArray = componentArrays[type];
                var elementSize = Marshal.SizeOf(type.Type);
                var newArray = Array.CreateInstance(type.Type, newCapacity);

                Buffer.BlockCopy(oldArray, 0, newArray, 0, count * elementSize);

                componentArrays[type] = newArray;
            }
        }

        public bool HasEntity(int entityId) => entityToIndex.ContainsKey(entityId);

        public int Count => count;
        public IReadOnlyList<int> Entities => entities;

        public IEnumerable<ComponentType> ComponentTypes => componentTypes;

        public Array GetComponentArrayRaw(ComponentType type)
        {
            if (!componentArrays.TryGetValue(type, out var array))
                throw new ArgumentException(
                    $"ComponentType {type.Type.Name} not found in archetype."
                );

            return array;
        }

        public int GetEntityIndex(int entityId)
        {
            if (!entityToIndex.TryGetValue(entityId, out var index))
                throw new ArgumentException($"Entity {entityId} not found in archetype.");

            return index;
        }

        public void TransferEntityComponents(
            int entityId,
            Archetype targetArchetype,
            HashSet<ComponentType> componentTypesToTransfer
        )
        {
            // Get source entity index
            var sourceIndex = GetEntityIndex(entityId);
            if (sourceIndex == -1)
                throw new ArgumentException($"Entity {entityId} not found in source archetype.");

            foreach (var type in componentTypesToTransfer)
            {
                if (
                    !componentArrays.ContainsKey(type)
                    || !targetArchetype.componentArrays.ContainsKey(type)
                )
                    continue;

                var sourceArray = componentArrays[type];
                var targetArray = targetArchetype.componentArrays[type];
                var elementSize = Marshal.SizeOf(type.Type);

                // Ensure target has space
                if (targetArchetype.count >= targetArray.Length)
                    targetArchetype.Grow();

                // Direct memory copy for the component
                Buffer.BlockCopy(
                    sourceArray, // Source array
                    sourceIndex * elementSize, // Source offset
                    targetArray, // Target array
                    targetArchetype.count * elementSize, // Target offset
                    elementSize // How many bytes to copy
                );
            }
        }
    }
}

================
File: Archetype.cs.meta
================
fileFormatVersion: 2
guid: b4381e7b77d7446289e01f3738e6d8dc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ArchetypeManager.cs
================
using System.Collections.Generic;
using System.Linq;

namespace ECS_Core
{
    public class ArchetypeManager
    {
        private Dictionary<int, Archetype> archetypes = new();

        public Archetype GetOrCreateArchetype(ComponentType[] types)
        {
            int hash = CalculateArchetypeHash(types);
            if (!archetypes.TryGetValue(hash, out var archetype))
            {
                archetype = new Archetype(types);
                archetypes[hash] = archetype;
            }

            return archetype;
        }

        public IEnumerable<Archetype> GetArchetypesWithComponents(ComponentType[] types)
        {
            foreach (var archetype in archetypes.Values)
            {
                if (DoesArchetypeMatchQuery(archetype, types))
                {
                    yield return archetype;
                }
            }
        }

        private bool DoesArchetypeMatchQuery(Archetype archetype, ComponentType[] queryTypes)
        {
            foreach (var queryType in queryTypes)
            {
                if (!archetype.HasComponent(queryType))
                {
                    return false;
                }
            }
            return true;
        }

        private int CalculateArchetypeHash(ComponentType[] types)
        {
            int hash = 17;
            foreach (var type in types.OrderBy(t => t.Id))
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        public void CleanupEmptyArchetypes()
        {
            var emptyArchetypes = archetypes
                .Where(kvp => kvp.Value.Count == 0)
                .Select(kvp => kvp.Key)
                .ToList();

            foreach (var hash in emptyArchetypes)
            {
                archetypes.Remove(hash);
            }
        }
    }
}

================
File: ArchetypeManager.cs.meta
================
fileFormatVersion: 2
guid: 5358525b5829c452d9abb4891f4431ba
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ComponentType.cs
================
using System;
using System.Collections.Generic;

namespace ECS_Core
{
    public struct ComponentType
    {
        public readonly Type Type;
        public readonly int Id;
        private static int NextId = 0;
        private static Dictionary<Type, ComponentType> typeRegistry = new();

        private ComponentType(Type type)
        {
            Type = type;
            Id = NextId++;
        }

        public static ComponentType Of<T>()
            where T : struct, IComponent
        {
            var type = typeof(T);
            if (!typeRegistry.ContainsKey(type))
            {
                typeRegistry[type] = new ComponentType(type);
            }

            return typeRegistry[type];
        }
    }
}

================
File: ComponentType.cs.meta
================
fileFormatVersion: 2
guid: 2e3cff646cf254dee8948a45e56ad066
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: IComponent.cs
================
namespace ECS_Core
{
    public interface IComponent { }
}

================
File: IComponent.cs.meta
================
fileFormatVersion: 2
guid: 5bfc30fb61b4b4792b8875b3f63c5a3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: QueryDescription.cs
================
namespace ECS_Core
{
    public delegate void ActionRef<T1, T2>(T1 index, ref T2 item);
    public delegate void ActionRef<T1, T2, T3>(T1 index, ref T2 item1, ref T3 item2);
    public delegate void ActionRef<T1, T2, T3, T4>(
        T1 index,
        ref T2 item1,
        ref T3 item2,
        ref T4 item3
    );
    public delegate void ActionRef<T1, T2, T3, T4, T5>(
        T1 index,
        ref T2 item1,
        ref T3 item2,
        ref T4 item3,
        ref T5 item4
    );

    public readonly struct QueryDescription<T1>
        where T1 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[] { ComponentType.Of<T1>() };

        public void ForEach(ArchetypeManager archetypeManager, ActionRef<int, T1> action)
        {
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(componentTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var component1Array = archetype.GetComponentArray<T1>();
                var entities = archetype.Entities;

                for (int i = 0; i < archetype.Count; i++)
                {
                    action(entities[i], ref component1Array[i]);
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
        };

        public void ForEach(ArchetypeManager archetypeManager, ActionRef<int, T1, T2> action)
        {
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(componentTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var component1Array = archetype.GetComponentArray<T1>();
                var component2Array = archetype.GetComponentArray<T2>();
                var entities = archetype.Entities;

                for (int i = 0; i < archetype.Count; i++)
                {
                    action(entities[i], ref component1Array[i], ref component2Array[i]);
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2, T3>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
        where T3 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
            ComponentType.Of<T3>(),
        };

        public void ForEach(ArchetypeManager archetypeManager, ActionRef<int, T1, T2, T3> action)
        {
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(componentTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var component1Array = archetype.GetComponentArray<T1>();
                var component2Array = archetype.GetComponentArray<T2>();
                var component3Array = archetype.GetComponentArray<T3>();
                var entities = archetype.Entities;

                for (int i = 0; i < archetype.Count; i++)
                {
                    action(
                        entities[i],
                        ref component1Array[i],
                        ref component2Array[i],
                        ref component3Array[i]
                    );
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2, T3, T4>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
        where T3 : struct, IComponent
        where T4 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
            ComponentType.Of<T3>(),
            ComponentType.Of<T4>(),
        };

        public void ForEach(
            ArchetypeManager archetypeManager,
            ActionRef<int, T1, T2, T3, T4> action
        )
        {
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(componentTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var component1Array = archetype.GetComponentArray<T1>();
                var component2Array = archetype.GetComponentArray<T2>();
                var component3Array = archetype.GetComponentArray<T3>();
                var component4Array = archetype.GetComponentArray<T4>();
                var entities = archetype.Entities;

                for (int i = 0; i < archetype.Count; i++)
                {
                    action(
                        entities[i],
                        ref component1Array[i],
                        ref component2Array[i],
                        ref component3Array[i],
                        ref component4Array[i]
                    );
                }
            }
        }
    }
}

================
File: QueryDescription.cs.meta
================
fileFormatVersion: 2
guid: 88b70e4e0660742a3aef862f0ee483f7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: World.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace ECS_Core
{
    public class World
    {
        private const int CLEANUP_THRESHOLD = 100; // Adjust based on your needs
        private int operationCount = 0;
        private readonly ArchetypeManager archetypeManager = new();
        private int nextEntityId = 0;
        private Dictionary<int, Archetype> entityArchetypes = new();

        public ArchetypeManager ArchetypeManager => archetypeManager;

        public QueryDescription<T1> Query<T1>()
            where T1 : struct, IComponent
        {
            return new QueryDescription<T1>();
        }

        public QueryDescription<T1, T2> Query<T1, T2>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            return new QueryDescription<T1, T2>();
        }

        public QueryDescription<T1, T2, T3> Query<T1, T2, T3>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            return new QueryDescription<T1, T2, T3>();
        }

        public QueryDescription<T1, T2, T3, T4> Query<T1, T2, T3, T4>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
            where T4 : struct, IComponent
        {
            return new QueryDescription<T1, T2, T3, T4>();
        }

        public int CreateEntity<T1>(T1 component1)
            where T1 : struct, IComponent
        {
            var entityId = nextEntityId++;

            var types = new[] { ComponentType.Of<T1>() };
            var components = new Dictionary<ComponentType, object>
            {
                { ComponentType.Of<T1>(), component1 },
            };

            var archetype = archetypeManager.GetOrCreateArchetype(types);
            archetype.Add(entityId, components);
            entityArchetypes[entityId] = archetype;

            return entityId;
        }

        public int CreateEntity<T1, T2>(T1 component1, T2 component2)
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            var entityId = nextEntityId++;

            var types = new[] { ComponentType.Of<T1>(), ComponentType.Of<T2>() };

            var components = new Dictionary<ComponentType, object>
            {
                { ComponentType.Of<T1>(), component1 },
                { ComponentType.Of<T2>(), component2 },
            };

            var archetype = archetypeManager.GetOrCreateArchetype(types);
            archetype.Add(entityId, components);
            entityArchetypes[entityId] = archetype;

            return entityId;
        }

        public int CreateEntity<T1, T2, T3>(T1 component1, T2 component2, T3 component3)
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            var entityId = nextEntityId++;

            var types = new[]
            {
                ComponentType.Of<T1>(),
                ComponentType.Of<T2>(),
                ComponentType.Of<T3>(),
            };

            var components = new Dictionary<ComponentType, object>
            {
                { ComponentType.Of<T1>(), component1 },
                { ComponentType.Of<T2>(), component2 },
                { ComponentType.Of<T3>(), component3 },
            };

            var archetype = archetypeManager.GetOrCreateArchetype(types);
            archetype.Add(entityId, components);
            entityArchetypes[entityId] = archetype;

            return entityId;
        }

        public int CreateEntity<T1, T2, T3, T4>(
            T1 component1,
            T2 component2,
            T3 component3,
            T4 component4
        )
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
            where T4 : struct, IComponent
        {
            var entityId = nextEntityId++;

            var types = new[]
            {
                ComponentType.Of<T1>(),
                ComponentType.Of<T2>(),
                ComponentType.Of<T3>(),
                ComponentType.Of<T4>(),
            };

            var components = new Dictionary<ComponentType, object>
            {
                { ComponentType.Of<T1>(), component1 },
                { ComponentType.Of<T2>(), component2 },
                { ComponentType.Of<T3>(), component3 },
                { ComponentType.Of<T4>(), component4 },
            };

            var archetype = archetypeManager.GetOrCreateArchetype(types);
            archetype.Add(entityId, components);
            entityArchetypes[entityId] = archetype;

            return entityId;
        }

        public void DestroyEntity(int entityId)
        {
            if (!entityArchetypes.TryGetValue(entityId, out var archetype))
                return;

            archetype.RemoveEntity(entityId);
            entityArchetypes.Remove(entityId);

            // Periodic cleanup
            operationCount++;
            if (operationCount >= CLEANUP_THRESHOLD)
            {
                archetypeManager.CleanupEmptyArchetypes();
                operationCount = 0;
            }
        }

        public bool EntityExists(int entityId)
        {
            return entityArchetypes.ContainsKey(entityId);
        }

        public void AddComponent<T>(int entityId, T component)
            where T : struct, IComponent
        {
            if (!entityArchetypes.TryGetValue(entityId, out var currentArchetype))
                return;

            var newType = ComponentType.Of<T>();
            if (currentArchetype.HasComponent(newType))
                return; // Component already exists

            // Create new archetype
            var newTypes = new ComponentType[currentArchetype.ComponentTypes.Count() + 1];
            var index = 0;
            foreach (var type in currentArchetype.ComponentTypes)
            {
                newTypes[index++] = type;
            }
            newTypes[index] = newType;

            var newArchetype = archetypeManager.GetOrCreateArchetype(newTypes);

            // Transfer existing components directly
            var sourceIndex = currentArchetype.GetEntityIndex(entityId);
            foreach (var type in currentArchetype.ComponentTypes)
            {
                var sourceArray = currentArchetype.GetComponentArrayRaw(type);
                var targetArray = newArchetype.GetComponentArrayRaw(type);
                var elementSize = Marshal.SizeOf(type.Type);

                Buffer.BlockCopy(
                    sourceArray,
                    sourceIndex * elementSize,
                    targetArray,
                    newArchetype.Count * elementSize,
                    elementSize
                );
            }

            // Add new component directly to its array
            var newComponentArray = newArchetype.GetComponentArray<T>();
            newComponentArray[newArchetype.Count] = component;

            // Update tracking
            currentArchetype.RemoveEntity(entityId);
            newArchetype.AddWithoutComponents(entityId); // No more empty dictionary allocation
            entityArchetypes[entityId] = newArchetype;
        }

        public void RemoveComponent<T>(int entityId)
            where T : struct, IComponent
        {
            if (!entityArchetypes.TryGetValue(entityId, out var currentArchetype))
                return;

            var typeToRemove = ComponentType.Of<T>();
            if (!currentArchetype.HasComponent(typeToRemove))
                return;

            // Create new archetype type array (excluding removed type)
            var newTypes = new ComponentType[currentArchetype.ComponentTypes.Count() - 1];
            var index = 0;
            foreach (var type in currentArchetype.ComponentTypes)
            {
                if (type.Type != typeof(T))
                    newTypes[index++] = type;
            }

            var newArchetype = archetypeManager.GetOrCreateArchetype(newTypes);

            // Transfer components directly
            var sourceIndex = currentArchetype.GetEntityIndex(entityId);
            foreach (var type in newTypes)
            {
                var sourceArray = currentArchetype.GetComponentArrayRaw(type);
                var targetArray = newArchetype.GetComponentArrayRaw(type);
                var elementSize = Marshal.SizeOf(type.Type);

                Buffer.BlockCopy(
                    sourceArray,
                    sourceIndex * elementSize,
                    targetArray,
                    newArchetype.Count * elementSize,
                    elementSize
                );
            }

            // Update tracking
            currentArchetype.RemoveEntity(entityId);
            newArchetype.AddWithoutComponents(entityId); // No more empty dictionary allocation
            entityArchetypes[entityId] = newArchetype;
        }

        public void AddComponentToEntities<T>(IEnumerable<int> entityIds, T component)
            where T : struct, IComponent
        {
            // Group entities by current archetype to minimize archetype creation
            var groupedEntities = entityIds.Where(EntityExists).GroupBy(id => entityArchetypes[id]);

            foreach (var group in groupedEntities)
            {
                var sourceArchetype = group.Key;
                var newType = ComponentType.Of<T>();

                if (sourceArchetype.HasComponent(newType))
                    continue;

                // Create new archetype once for this group
                var newTypes = new ComponentType[sourceArchetype.ComponentTypes.Count() + 1];
                var index = 0;
                foreach (var type in sourceArchetype.ComponentTypes)
                {
                    newTypes[index++] = type;
                }
                newTypes[index] = newType;

                var targetArchetype = archetypeManager.GetOrCreateArchetype(newTypes);

                // Transfer all entities in this group
                foreach (var entityId in group)
                {
                    var sourceIndex = sourceArchetype.GetEntityIndex(entityId);

                    // Transfer existing components
                    foreach (var type in sourceArchetype.ComponentTypes)
                    {
                        var sourceArray = sourceArchetype.GetComponentArrayRaw(type);
                        var targetArray = targetArchetype.GetComponentArrayRaw(type);
                        var elementSize = Marshal.SizeOf(type.Type);

                        Buffer.BlockCopy(
                            sourceArray,
                            sourceIndex * elementSize,
                            targetArray,
                            targetArchetype.Count * elementSize,
                            elementSize
                        );
                    }

                    // Add new component
                    var newComponentArray = targetArchetype.GetComponentArray<T>();
                    newComponentArray[targetArchetype.Count] = component;

                    // Update tracking with the new method instead
                    sourceArchetype.RemoveEntity(entityId);
                    targetArchetype.AddWithoutComponents(entityId); // No more empty dictionary allocation
                    entityArchetypes[entityId] = targetArchetype;
                }
            }
        }
    }
}

================
File: World.cs.meta
================
fileFormatVersion: 2
guid: 7af841868c71a4655bb50385d1c61ad1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
