This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-01T14:28:31.624Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
Archetype.cs
Archetype.cs.meta
ArchetypeStorage.cs
ArchetypeStorage.cs.meta
ComponentType.cs
ComponentType.cs.meta
GlobalPoint.cs
GlobalPoint.cs.meta
MidiNoteParser.cs
MidiNoteParser.cs.meta
MusicNoteCreationSetting_SO.asset
MusicNoteCreationSetting_SO.asset.meta
MusicNoteCreationSystem_.cs
MusicNoteCreationSystem_.cs.meta
StorageManager.cs
StorageManager.cs.meta
SystemRegistry.cs
SystemRegistry.cs.meta
World.cs
World.cs.meta

================================================================
Repository Files
================================================================

================
File: Archetype.cs
================
using System;
using System.Linq;

namespace ECS_MagicTile
{
    public class Archetype
    {
        private readonly ComponentType[] types;
        private readonly int hash;

        private Archetype(ComponentType[] types)
        {
            // Store types in a fixed order for consistent hashing
            this.types = types.OrderBy(t => t.Id).ToArray();
            this.hash = CalculateHash(this.types);
        }

        // Utility methods for archetype management
        public ReadOnlySpan<ComponentType> GetTypes() => types;

        public int GetHash() => hash;

        private static int CalculateHash(ComponentType[] types)
        {
            // Simple but effective hash calculation for fixed component combinations
            int hash = 17;
            foreach (var type in types)
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        // Game-specific archetypes
        public static class Registry
        {
            // Note archetypes


            public static readonly Archetype MusicNote =
                new(new[] { ComponentType.Registry.Transform, ComponentType.Registry.MusicNote });

            // Game setup archetypes
            public static readonly Archetype PerfectLine =
                new(new[] { ComponentType.Registry.PerfectLine, ComponentType.Registry.Corner });

            // Keep track of all archetypes for initialization
            private static readonly Archetype[] AllArchetypes = { MusicNote, PerfectLine };

            public static ReadOnlySpan<Archetype> GetAllArchetypes() => AllArchetypes;
        }
    }
}

================
File: Archetype.cs.meta
================
fileFormatVersion: 2
guid: 6a700f18bf185134ebcd378e0ebfe28f

================
File: ArchetypeStorage.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_MagicTile
{
    public class ArchetypeStorage
    {
        // Store component arrays indexed by their ComponentType
        private readonly Dictionary<ComponentType, Array> componentArrays;
        private int[] entityIds; // Tracks which entities are in this storage
        private int count; // Number of active entities

        private const int DEFAULT_CAPACITY = 64; // Starting size for our arrays
        private const float GROWTH_FACTOR = 2.0f; // How much to grow when we need more space

        public ArchetypeStorage(Archetype archetype, int initialCapacity = DEFAULT_CAPACITY)
        {
            componentArrays = new Dictionary<ComponentType, Array>();

            // Create typed arrays for each component in the archetype
            foreach (var componentType in archetype.GetTypes())
            {
                // Creates an array of the proper type with our initial capacity
                componentArrays[componentType] = Array.CreateInstance(
                    componentType.Type,
                    initialCapacity
                );
            }

            entityIds = new int[initialCapacity];
            count = 0;
        }

        // Provides type-safe access to component arrays
        public T[] GetComponents<T>()
            where T : struct
        {
            var componentType = ComponentType.Registry.GetComponentType<T>();
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {typeof(T)} not found in archetype"
                );
            }
            return (T[])array;
        }

        // Adds an entity with its components to this storage
        public void Add(int entityId, ReadOnlySpan<object> components)
        {
            // Grow arrays if needed
            if (count >= entityIds.Length)
            {
                Grow();
            }

            // Add components to their respective arrays
            int componentIndex = 0;
            foreach (var array in componentArrays.Values)
            {
                Array.Copy(new[] { components[componentIndex] }, 0, array, count, 1);
                componentIndex++;
            }

            // Track the entity
            entityIds[count] = entityId;
            count++;
        }

        // Efficiently removes an entity by swapping with the last element
        public void Remove(int entityId)
        {
            // Find the entity's index
            int index = Array.IndexOf(entityIds, entityId, 0, count);
            if (index == -1)
                return;

            // If it's not the last element, swap with the last one
            int lastIndex = count - 1;
            if (index < lastIndex)
            {
                foreach (var array in componentArrays.Values)
                {
                    Array.Copy(array, lastIndex, array, index, 1);
                }
                entityIds[index] = entityIds[lastIndex];
            }

            count--;
        }

        private void Grow()
        {
            int newCapacity = (int)(entityIds.Length * GROWTH_FACTOR);

            // Grow all component arrays
            foreach (var kvp in componentArrays.ToList())
            {
                var oldArray = kvp.Value;
                var newArray = Array.CreateInstance(kvp.Key.Type, newCapacity);
                Array.Copy(oldArray, 0, newArray, 0, count);
                componentArrays[kvp.Key] = newArray;
            }

            // Grow entity ID array
            Array.Resize(ref entityIds, newCapacity);
        }

        // Properties for accessing storage information
        public int Count => count;
        public ReadOnlySpan<int> EntityIds => new ReadOnlySpan<int>(entityIds, 0, count);
    }
}

================
File: ArchetypeStorage.cs.meta
================
fileFormatVersion: 2
guid: 785407d53c9c26746adb34ba3d74b58d

================
File: ComponentType.cs
================
using System;
using System.Collections.Generic;

namespace ECS_MagicTile
{
    public readonly struct ComponentType
    {
        public readonly Type Type;
        public readonly int Id;

        // Private constructor ensures all types are created through registry
        private ComponentType(Type type, int id)
        {
            Type = type;
            Id = id;
        }

        // Static registry of all component types in our game
        public static class Registry
        {
            // Core Components
            public static readonly ComponentType Transform = new(typeof(TransformComponent), 0);
            public static readonly ComponentType MusicNote = new(typeof(MusicNoteComponent), 1);

            public static readonly ComponentType PerfectLine =
                new(typeof(PerfectLineTagComponent), 3);
            public static readonly ComponentType Corner = new(typeof(CornerComponent), 4);

            // A lookup dictionary to quickly find ComponentType by Type
            private static readonly Dictionary<Type, ComponentType> typeToComponentType;

            // Initialize our lookup dictionary when the class is first used
            static Registry()
            {
                typeToComponentType = new Dictionary<Type, ComponentType>
                {
                    { typeof(TransformComponent), Transform },
                    { typeof(MusicNoteComponent), MusicNote },
                    { typeof(PerfectLineTagComponent), PerfectLine },
                    { typeof(CornerComponent), Corner },
                };
            }

            // This is our new generic lookup method
            public static ComponentType GetComponentType<T>()
                where T : struct
            {
                var type = typeof(T);
                if (!typeToComponentType.TryGetValue(type, out var componentType))
                {
                    throw new InvalidOperationException(
                        $"Component type {type.Name} is not registered. "
                            + "Make sure to add it to the ComponentType.Registry."
                    );
                }
                return componentType;
            }

            // The existing methods remain the same
            public static ReadOnlySpan<ComponentType> GetAllTypes() => AllTypes;

            private static readonly ComponentType[] AllTypes =
            {
                Transform,
                MusicNote,
                PerfectLine,
                Corner,
            };
        }
    }
}

================
File: ComponentType.cs.meta
================
fileFormatVersion: 2
guid: 07d3246996a8eeb4ba2c5e2e4d0939c9

================
File: GlobalPoint.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public class GlobalPoint : MonoBehaviour
    {
        [Header("Game Settings")]
        [SerializeField]
        private MusicNoteCreationSetting musicNoteCreationSettings;

        [SerializeField]
        private PerfectLineSettingSO perfectLineSettingSO;

        private World world;

        private void Awake()
        {
            // Initialize our ECS world
            world = new World();

            SystemRegistry.Initialize(world);
            RegisterSystems();
            CreateSingletonComponent();
        }

        private void RegisterSystems()
        {
            SystemRegistry.AddSystem(new MusicNoteCreationSystem_(musicNoteCreationSettings));
        }

        private void CreateSingletonComponent()
        {
            var components = new object[] { new PerfectLineData(), new CornerComponent() };
            world.CreateEntityWithComponents(Archetype.Registry.PerfectLine, components);
        }

        private void Update()
        {
            // Update all systems with current frame's delta time
            SystemRegistry.Update(Time.deltaTime);
        }
    }
}

================
File: GlobalPoint.cs.meta
================
fileFormatVersion: 2
guid: a3234adf86578d14ca74bc8cc99f7901

================
File: MidiNoteParser.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

public static class MidiNoteParser
{
    public static MusicNoteMidiData ParseFromText(string content)
    {
        if (string.IsNullOrEmpty(content))
            throw new MidiParseException("MIDI content cannot be empty");

        var entries = content.Split(',', StringSplitOptions.RemoveEmptyEntries);
        if (entries.Length == 0)
            throw new MidiParseException("No valid MIDI entries found");

        // Split into note entries
        var data = new MusicNoteMidiData(entries.Length);

        for (int i = 0; i < entries.Length; i++)
        {
            try
            {
                ParseEntry(entries[i], i, ref data);
                data.TotalNotes++;
            }
            catch (Exception ex)
            {
                throw new MidiParseException($"Error parsing entry {i}: {ex.Message}");
            }
        }

        ValidateData(ref data);

        return data;
    }

    private static void ParseEntry(string entry, int index, ref MusicNoteMidiData data)
    {
        var properties = entry.Split('-');
        var requiredFields = new HashSet<string> { "id", "n", "ta", "ts", "d", "v", "pid" };
        var parsedFields = new HashSet<string>();

        foreach (var prop in properties)
        {
            var kv = prop.Split(':');
            if (kv.Length != 2)
                throw new MidiParseException($"Invalid property format: {prop}");

            if (!ParseProperty(kv[0], kv[1], index, ref data))
                throw new MidiParseException($"Failed to parse property: {kv[0]}");

            parsedFields.Add(kv[0]);
        }

        // Check for missing required fields
        requiredFields.ExceptWith(parsedFields);
        if (requiredFields.Count > 0)
            throw new MidiParseException(
                $"Missing required fields: {string.Join(", ", requiredFields)}"
            );
    }

    private static bool ParseProperty(
        string key,
        string value,
        int index,
        ref MusicNoteMidiData data
    )
    {
        try
        {
            switch (key)
            {
                case "id":
                    data.Ids[index] = int.Parse(value);
                    break;
                case "n":
                    data.NoteNumbers[index] = int.Parse(value);
                    break;
                case "ta":
                    data.TimeAppears[index] = float.Parse(value);
                    break;
                case "ts":
                    data.Timespans[index] = float.Parse(value);
                    break;
                case "d":
                    float duration = float.Parse(value);
                    data.Durations[index] = duration;
                    data.MinDuration = Mathf.Min(data.MinDuration, duration);
                    break;
                case "v":
                    data.Velocities[index] = float.Parse(value);
                    break;
                case "pid":
                    data.PositionIds[index] = int.Parse(value);
                    break;
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static void ValidateData(ref MusicNoteMidiData data)
    {
        if (data.MinDuration <= 0)
            throw new MidiParseException("Invalid minimum duration");

        if (data.TotalNotes <= 0)
            throw new MidiParseException("No valid notes parsed");
    }
}

public class MidiParseException : Exception
{
    public MidiParseException(string message)
        : base(message) { }
}

================
File: MidiNoteParser.cs.meta
================
fileFormatVersion: 2
guid: ccd8b8d0c202c4c46a3c94a768d54c37
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MusicNoteCreationSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a5af8e59dd796d941989a811a2c8754b, type: 3}
  m_Name: MusicNoteCreationSetting_SO
  m_EditorClassIdentifier: 
  midiContent: {fileID: 4900000, guid: 5651cca0434e843a4af2569038996f88, type: 3}
  shortNoteScaleYFactor: 0
  longNoteScaleYFactor: 0

================
File: MusicNoteCreationSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: 5d1ed20f8d24fbd4f95a64d2f692fb66
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MusicNoteCreationSystem_.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteCreationSystem_ : ECS_MagicTile.IGameSystem
    {
        private MusicNoteCreationSetting musicNoteCreationSetting;
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public MusicNoteCreationSystem_(MusicNoteCreationSetting musicNoteCreationSetting)
        {
            this.musicNoteCreationSetting = musicNoteCreationSetting;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            MusicNoteMidiData musicNoteMidiData = MidiNoteParser.ParseFromText(
                musicNoteCreationSetting.midiContent.text
            );

            for (int i = 0; i < musicNoteMidiData.TotalNotes; i++)
            {
                var components = new object[]
                {
                    new TransformComponent(),
                    new MusicNoteComponent(),
                };

                World.CreateEntityWithComponents(Archetype.Registry.MusicNote, components);
            }

            ArchetypeStorage musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);
            ArchetypeStorage perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            TransformComponent[] transforms = musicNoteStorage.GetComponents<TransformComponent>();
            MusicNoteComponent[] musicNotes = musicNoteStorage.GetComponents<MusicNoteComponent>();

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            ref CornerComponent perfectLineCorner =
                ref perfectLineStorage.GetComponents<CornerComponent>()[0];

            for (int i = 0; i < musicNoteStorage.Count; i++) { }
        }

        public void Update(float deltaTime)
        {
            //
        }

        public void Cleanup()
        {
            //
        }
    }
}

================
File: MusicNoteCreationSystem_.cs.meta
================
fileFormatVersion: 2
guid: 27223b00486847b4b86f21b0b74f2e53

================
File: StorageManager.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Manages all archetype storages in our game
    public class StorageManager
    {
        // Maps archetype hashes to their storage
        private readonly Dictionary<int, ArchetypeStorage> storages;

        public StorageManager()
        {
            storages = new Dictionary<int, ArchetypeStorage>();

            // Pre-create storages for all known archetypes
            foreach (var archetype in Archetype.Registry.GetAllArchetypes())
            {
                storages[archetype.GetHash()] = new ArchetypeStorage(archetype);
            }
        }

        // Get storage for a specific archetype
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            if (!storages.TryGetValue(archetype.GetHash(), out var storage))
            {
                throw new InvalidOperationException($"No storage found for archetype {archetype}");
            }
            return storage;
        }
    }
}

================
File: StorageManager.cs.meta
================
fileFormatVersion: 2
guid: 6e34b51edd65cc54298a958d1e7db250

================
File: SystemRegistry.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public interface IGameSystem
    {
        void SetWorld(World world);
        void Initialize(); // Called when system is first created
        void Update(float deltaTime); // Called every frame
        void Cleanup();
        bool IsEnabled { get; set; } // Controls if system should be updated
        World World { get; set; }
    }

    // Our central system management class
    public static class SystemRegistry
    {
        // Interface that all our game systems will implement


        // Store systems in order of execution priority
        private static readonly List<IGameSystem> updateSystems = new();
        private static World world;
        private static bool isInitialized;

        // Initialize our registry with a world reference
        public static void Initialize(World gameWorld)
        {
            // Prevent multiple initializations
            if (isInitialized)
            {
                Debug.LogWarning("SystemRegistry already initialized!");
                return;
            }

            world = gameWorld;
            isInitialized = true;
        }

        // Allow adding systems from GlobalPoint
        public static void AddSystem(IGameSystem system)
        {
            if (!isInitialized)
            {
                Debug.LogError("SystemRegistry not initialized! Call Initialize first.");
                return;
            }

            // Provide the system with world reference and initialize it
            system.SetWorld(world);
            system.Initialize();

            updateSystems.Add(system);

            Debug.Log($"Added system: {system.GetType().Name}");
        }

        public static void Update(float deltaTime)
        {
            if (!isInitialized)
                return;

            foreach (var system in updateSystems)
            {
                if (system.IsEnabled)
                {
                    try
                    {
                        system.Update(deltaTime);
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error in system {system.GetType().Name}: {e}");
                    }
                }
            }
        }

        public static void Cleanup()
        {
            foreach (var system in updateSystems)
            {
                system.Cleanup();
            }

            updateSystems.Clear();
            isInitialized = false;
            world = null;
        }
    }
}

================
File: SystemRegistry.cs.meta
================
fileFormatVersion: 2
guid: ae3ac3479b706d64f83a41cf766e7021

================
File: World.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    public class World
    {
        private readonly StorageManager storageManager;
        private int nextEntityId = 1000; // Starting from 1000 to leave room for special IDs

        public World()
        {
            storageManager = new StorageManager();
        }

        // Creates an entity of a specific archetype
        private int CreateEntity()
        {
            int entityId = nextEntityId++;
            return entityId;
        }

        // Gets a specific storage for systems to use
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            return storageManager.GetStorage(archetype);
        }

        // Helper method to create and set up an entity in one go
        public int CreateEntityWithComponents(Archetype archetype, ReadOnlySpan<object> components)
        {
            int entityId = CreateEntity();
            ArchetypeStorage storage = GetStorage(archetype);
            storage.Add(entityId, components);
            return entityId;
        }
    }
}

================
File: World.cs.meta
================
fileFormatVersion: 2
guid: 1df84a3b9711fcb41b790ef98664b125
