This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-07T03:21:24.452Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
Core/
  Archetype.cs
  Archetype.cs.meta
  ArchetypeStorage.cs
  ArchetypeStorage.cs.meta
  ArchetypeSyncer.cs
  ArchetypeSyncer.cs.meta
  ComponentType.cs
  ComponentType.cs.meta
  EntityIdHolder.cs
  EntityIdHolder.cs.meta
  EntityViewFactory.cs
  EntityViewFactory.cs.meta
  GlobalPoint.cs
  GlobalPoint.cs.meta
  IComponent.cs
  IComponent.cs.meta
  IEntityHolder.cs
  IEntityHolder.cs.meta
  IGameSystem.cs
  IGameSystem.cs.meta
  StorageManager.cs
  StorageManager.cs.meta
  SystemRegistry.cs
  SystemRegistry.cs.meta
  World.cs
  World.cs.meta
DataComponents/
  ActiveStateComponent.cs
  ActiveStateComponent.cs.meta
  CornerComponent.cs
  CornerComponent.cs.meta
  GraphicComponent.cs
  GraphicComponent.cs.meta
  InputStateComponent.cs
  InputStateComponent.cs.meta
  LongNoteTagComponent.cs
  LongNoteTagComponent.cs.meta
  MusicNoteComponent.cs
  MusicNoteComponent.cs.meta
  MusicNoteFillerComponent.cs
  MusicNoteFillerComponent.cs.meta
  MusicNoteInteractionComponent.cs
  MusicNoteInteractionComponent.cs.meta
  PerfectLineTagComponent.cs
  PerfectLineTagComponent.cs.meta
  ScoreComponent.cs
  ScoreComponent.cs.meta
  ScoreEffectComponent.cs
  ScoreEffectComponent.cs.meta
  ScoreStateComponent.cs
  ScoreStateComponent.cs.meta
  ShortNoteTagComponent.cs
  ShortNoteTagComponent.cs.meta
  StartingNoteTagComponent.cs
  StartingNoteTagComponent.cs.meta
  TransformComponent.cs
  TransformComponent.cs.meta
DTO/
  MusicNoteMidiData.cs
  MusicNoteMidiData.cs.meta
EventChannels/
  BoolEventChannel.cs
  BoolEventChannel.cs.meta
  EntityIdChannel.asset
  EntityIdChannel.asset.meta
  IntEventChannel.cs
  IntEventChannel.cs.meta
  SO_ScoreSignalEffectChannel.asset
  SO_ScoreSignalEffectChannel.asset.meta
MonoScripts/
  BurstMovement.cs
  BurstMovement.cs.meta
  BurstMovementUI.cs
  BurstMovementUI.cs.meta
  RaycastToObjects.cs
  RaycastToObjects.cs.meta
  SatelliteAnimationManager.cs
  SatelliteAnimationManager.cs.meta
  ScoreEffectController.cs
  ScoreEffectController.cs.meta
Settings/
  GeneralGameSetting_SO.asset
  GeneralGameSetting_SO.asset.meta
  GeneralGameSetting.cs
  GeneralGameSetting.cs.meta
  MidiNoteParser.cs
  MidiNoteParser.cs.meta
  MusicNoteCreationSetting_SO.asset
  MusicNoteCreationSetting_SO.asset.meta
  MusicNoteCreationSetting.cs
  MusicNoteCreationSetting.cs.meta
  ScoreEffectSettings_SO.asset
  ScoreEffectSettings_SO.asset.meta
  ScoreEffectSettings.cs
  ScoreEffectSettings.cs.meta
Syncers/
  MusicNoteSyncer.cs
  MusicNoteSyncer.cs.meta
  ScoreUISyncer.cs
  ScoreUISyncer.cs.meta
  StartingNoteSyncer.cs
  StartingNoteSyncer.cs.meta
Systems/
  GameStateSystem.cs
  GameStateSystem.cs.meta
  InputCollisionSystem.cs
  InputCollisionSystem.cs.meta
  InputSystem.cs
  InputSystem.cs.meta
  MovingNoteSystem.cs
  MovingNoteSystem.cs.meta
  MusicNoteCreationSystem.cs
  MusicNoteCreationSystem.cs.meta
  ScoreEffectCreationSystem.cs
  ScoreEffectCreationSystem.cs.meta
  ScoreEffectSystem.cs
  ScoreEffectSystem.cs.meta
  ScoringSystem.cs
  ScoringSystem.cs.meta
  SingletonCreationSystem.cs
  SingletonCreationSystem.cs.meta
Core.meta
DataComponents.meta
DTO.meta
EGameState.cs
EGameState.cs.meta
EventChannels.meta
MonoScripts.meta
Settings.meta
Syncers.meta
Systems.meta

================================================================
Repository Files
================================================================

================
File: Core/Archetype.cs
================
using System;
using System.Linq;

namespace ECS_MagicTile
{
    public class Archetype
    {
        private readonly ComponentType[] types;
        private readonly int hash;
        private readonly bool isAspect;

        public bool IsAspect => isAspect;

        private Archetype(ComponentType[] types, bool isAspect = false)
        {
            // Store types in a fixed order for consistent hashing
            this.types = types.OrderBy(t => t.Id).ToArray();
            this.hash = CalculateHash(this.types);
            this.isAspect = isAspect;
        }

        // Utility methods for archetype management
        public ReadOnlySpan<ComponentType> GetTypes() => types;

        public int GetHash() => hash;

        private static int CalculateHash(ComponentType[] types)
        {
            // Simple but effective hash calculation for fixed component combinations
            int hash = 17;
            foreach (var type in types)
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        // Game-specific archetypes
        public static class Registry
        {
            // Note archetypes
            public static readonly Archetype MusicNote = new(
                new[]
                {
                    ComponentType.Registry.Transform,
                    ComponentType.Registry.MusicNote,
                    ComponentType.Registry.Corner, // Added CornerComponent
                    ComponentType.Registry.MusicNoteInteraction,
                    ComponentType.Registry.MusicNoteFiller,
                    ComponentType.Registry.NoteScoreState,
                }
            );

            // Game setup archetypes
            public static readonly Archetype PerfectLine = new(
                new[] { ComponentType.Registry.PerfectLine, ComponentType.Registry.Corner }
            );

            public static readonly Archetype Input = new(new[] { ComponentType.Registry.Input });
            public static readonly Archetype StartingNote = new(
                new[]
                {
                    ComponentType.Registry.Transform,
                    ComponentType.Registry.ActiveState,
                    ComponentType.Registry.StartingNote,
                }
            );

            public static readonly Archetype GameScore = new(
                new[]
                {
                    ComponentType
                        .Registry
                        .GameScore // New score component
                    ,
                }
            );

            public static readonly Archetype ScoreEffect = new(
                new[]
                {
                    ComponentType.Registry.Transform,
                    ComponentType.Registry.TransformGroup,
                    ComponentType.Registry.Graphics,
                }
            );

            // Keep track of all archetypes for initialization
            private static readonly Archetype[] AllArchetypes =
            {
                MusicNote,
                PerfectLine,
                Input,
                StartingNote,
                GameScore,
                ScoreEffect,
            };

            public static ReadOnlySpan<Archetype> GetAllArchetypes() => AllArchetypes;
        }
    }
}

================
File: Core/Archetype.cs.meta
================
fileFormatVersion: 2
guid: 6a700f18bf185134ebcd378e0ebfe28f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/ArchetypeStorage.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_MagicTile
{
    public class ArchetypeStorage
    {
        // Store component arrays indexed by their ComponentType
        private readonly Dictionary<ComponentType, Array> componentArrays;
        private int[] entityIds; // Tracks which entities are in this storage
        private readonly Dictionary<int, int> entityToIndex = new Dictionary<int, int>();
        private int count; // Number of active entities

        private const int DEFAULT_CAPACITY = 64; // Starting size for our arrays
        private const float GROWTH_FACTOR = 2.0f; // How much to grow when we need more space

        public ArchetypeStorage(Archetype archetype, int initialCapacity = DEFAULT_CAPACITY)
        {
            componentArrays = new Dictionary<ComponentType, Array>();

            // Create typed arrays for each component in the archetype
            foreach (var componentType in archetype.GetTypes())
            {
                // Creates an array of the proper type with our initial capacity
                componentArrays[componentType] = Array.CreateInstance(
                    componentType.Type,
                    initialCapacity
                );
            }

            entityIds = new int[initialCapacity];

            count = 0;
        }

        // Provides type-safe access to component arrays
        public T[] GetComponents<T>()
            where T : struct
        {
            var componentType = ComponentType.Registry.GetComponentType<T>();
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {typeof(T)} not found in archetype"
                );
            }
            return (T[])array;
        }

        // Adds an entity with its components to this storage
        public void Add(int entityId, ReadOnlySpan<object> components)
        {
            // Grow arrays if needed
            if (count >= entityIds.Length)
            {
                Grow();
            }

            // Add components to their respective arrays
            int componentIndex = 0;
            foreach (var array in componentArrays.Values)
            {
                Array.Copy(new[] { components[componentIndex] }, 0, array, count, 1);
                componentIndex++;
            }

            // Track the entity
            entityIds[count] = entityId;
            entityToIndex[entityId] = count;
            count++;
        }

        // Efficiently removes an entity by swapping with the last element
        public void Remove(int entityId)
        {
            // Find the entity's index
            int index = Array.IndexOf(entityIds, entityId, 0, count);
            if (index == -1)
                return;

            // If it's not the last element, swap with the last one
            int lastIndex = count - 1;
            if (index < lastIndex)
            {
                foreach (var array in componentArrays.Values)
                {
                    Array.Copy(array, lastIndex, array, index, 1);
                }
                entityIds[index] = entityIds[lastIndex];
                entityToIndex[entityIds[lastIndex]] = index;
            }

            entityToIndex.Remove(entityId);
            count--;
        }

        private void Grow()
        {
            int newCapacity = (int)(entityIds.Length * GROWTH_FACTOR);

            // Grow all component arrays
            foreach (var kvp in componentArrays.ToList())
            {
                var oldArray = kvp.Value;
                var newArray = Array.CreateInstance(kvp.Key.Type, newCapacity);
                Array.Copy(oldArray, 0, newArray, 0, count);
                componentArrays[kvp.Key] = newArray;
            }

            // Grow entity ID array
            Array.Resize(ref entityIds, newCapacity);
        }

        // And we need to add this method to ArchetypeStorage
        public Array GetComponentArrayRaw(ComponentType componentType)
        {
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {componentType.Type.Name} not found in archetype"
                );
            }
            return array;
        }

        public int GetEntityIndex(int entityId)
        {
            return entityToIndex.TryGetValue(entityId, out int index) ? index : -1;
        }

        // Properties for accessing storage information
        public int Count => count;
        public ReadOnlySpan<int> EntityIds => new ReadOnlySpan<int>(entityIds, 0, count);
    }
}

================
File: Core/ArchetypeStorage.cs.meta
================
fileFormatVersion: 2
guid: 785407d53c9c26746adb34ba3d74b58d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/ArchetypeSyncer.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public abstract class ArchetypeSyncer : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        protected ArchetypeStorage DedicatedStorage => World.GetStorage(Archetype);
        protected abstract Archetype Archetype { get; }

        public abstract EGameState GameStateToExecute { get; }

        public void SetWorld(World world)
        {
            World = world;
        }

        public virtual void Initialize() { }

        public virtual void Update(float deltaTime) { }

        public virtual void Cleanup() { }
    }
}

================
File: Core/ArchetypeSyncer.cs.meta
================
fileFormatVersion: 2
guid: 0df86895fba8144229e53825e79322a5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/ComponentType.cs
================
using System;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using NUnit.Framework.Constraints;

namespace ECS_MagicTile
{
    public readonly struct ComponentType
    {
        public readonly Type Type;
        public readonly int Id;

        // Private constructor ensures all types are created through registry
        private ComponentType(Type type, int id)
        {
            Type = type;
            Id = id;
        }

        // Static registry of all component types in our game
        public static class Registry
        {
            // Core Components
            public static readonly ComponentType Transform = new(typeof(TransformComponent), 0);
            public static readonly ComponentType MusicNote = new(typeof(MusicNoteComponent), 1);

            public static readonly ComponentType PerfectLine = new(
                typeof(PerfectLineTagComponent),
                3
            );
            public static readonly ComponentType Corner = new(typeof(CornerComponent), 4);

            public static readonly ComponentType Input = new(typeof(InputStateComponent), 5);
            public static readonly ComponentType MusicNoteInteraction = new(
                typeof(MusicNoteInteractionComponent),
                6
            );
            public static readonly ComponentType MusicNoteFiller = new(
                typeof(MusicNoteFillerComponent),
                7
            );

            public static readonly ComponentType ActiveState = new(typeof(ActiveStateComponent), 8);
            public static readonly ComponentType StartingNote = new(
                typeof(StartingNoteTagComponent),
                9
            );
            public static readonly ComponentType GameScore = new(typeof(ScoreComponent), 10);
            public static readonly ComponentType NoteScoreState = new(
                typeof(ScoreStateComponent),
                11
            );

            public static readonly ComponentType TransformGroup = new(
                typeof(TransformComponentGroup),
                12
            );

            public static readonly ComponentType Graphics = new(typeof(GraphicComponent), 13);

            // A lookup dictionary to quickly find ComponentType by Type
            private static readonly Dictionary<Type, ComponentType> typeToComponentType =
                new Dictionary<Type, ComponentType>
                {
                    { typeof(TransformComponent), Transform },
                    { typeof(MusicNoteComponent), MusicNote },
                    { typeof(PerfectLineTagComponent), PerfectLine },
                    { typeof(CornerComponent), Corner },
                    { typeof(InputStateComponent), Input },
                    { typeof(MusicNoteInteractionComponent), MusicNoteInteraction },
                    { typeof(MusicNoteFillerComponent), MusicNoteFiller },
                    { typeof(ActiveStateComponent), ActiveState },
                    { typeof(StartingNoteTagComponent), StartingNote },
                    { typeof(ScoreComponent), GameScore },
                    { typeof(ScoreStateComponent), NoteScoreState },
                    { typeof(TransformComponentGroup), TransformGroup },
                    { typeof(GraphicComponent), Graphics },
                };

            // This is our new generic lookup method
            public static ComponentType GetComponentType<T>()
                where T : struct
            {
                var type = typeof(T);
                if (!typeToComponentType.TryGetValue(type, out var componentType))
                {
                    throw new InvalidOperationException(
                        $"Component type {type.Name} is not registered. "
                            + "Make sure to add it to the ComponentType.Registry."
                    );
                }
                return componentType;
            }

            // The existing methods remain the same
            public static ReadOnlySpan<ComponentType> GetAllTypes() => AllTypes;

            private static readonly ComponentType[] AllTypes =
            {
                Transform,
                MusicNote,
                PerfectLine,
                Corner,
            };
        }
    }
}

================
File: Core/ComponentType.cs.meta
================
fileFormatVersion: 2
guid: 07d3246996a8eeb4ba2c5e2e4d0939c9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/EntityIdHolder.cs
================
using System.Linq;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EntityIdHolder : MonoBehaviour, IEntityHolder
    {
        public int EntityId { get; private set; }

        public void SetEntityId(int id)
        {
            EntityId = id;
            // Optional: Make the GameObject name more readable without losing the ID reference
            gameObject.name = $"{id}_{gameObject.name.Split('_').LastOrDefault() ?? "entity"}";
        }
    }
}

================
File: Core/EntityIdHolder.cs.meta
================
fileFormatVersion: 2
guid: 17dde60b87c53b14884d92c6a0f07c99
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/EntityViewFactory.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EntityViewFactory
    {
        private readonly Dictionary<int, GameObject> entityViews = new();
        private readonly GameObject prefabSource;
        private readonly Transform viewRoot;

        public EntityViewFactory() { }

        public EntityViewFactory(GameObject prefabSource, Transform viewRoot)
        {
            this.prefabSource = prefabSource;
            this.viewRoot = viewRoot;
        }

        public GameObject GetOrCreateView(int entityId, string nameOnCreation = "")
        {
            if (entityViews.TryGetValue(entityId, out var existing))
            {
                return existing;
            }

            var prefab = prefabSource;

            GameObject view = GameObject.Instantiate(prefab, viewRoot);
            EntityIdHolder viewEntityIdHolder = view.AddComponent<EntityIdHolder>();
            viewEntityIdHolder.SetEntityId(entityId);
            entityViews[entityId] = view;
            return view;
        }

        public GameObject GetView(int entityId)
        {
            return entityViews.TryGetValue(entityId, out var view) ? view : null;
        }
    }
}

================
File: Core/EntityViewFactory.cs.meta
================
fileFormatVersion: 2
guid: f36c2cdebdbc74a8db63bff96d758abd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/GlobalPoint.cs
================
using ECS_MagicTile.Components;
using ECS_MagicTile.Settings;
using EventChannel;
using TMPro;
using UnityEngine;

namespace ECS_MagicTile
{
    public class GlobalPoint : MonoBehaviour
    {
        [Header("Game Settings")]
        public GeneralGameSetting generalGameSetting;

        public MusicNoteCreationSetting musicNoteCreationSettings;

        public PerfectLineSettingSO perfectLineSettingSO;
        public ECS_MagicTile.Settings.ScoreEffectSettings scoreEffectSettings;

        [Header("Event Channel")]
        public IntEventChannel entityIdChannel;
        public BoolEventChannel scoreEffectChannel;

        [Header("UI references")]
        public TextMeshProUGUI scoreText;

        [Header("Scene View Object references")]
        public GameObject perfectScoreEffectPrefab;
        public GameObject greatScoreEffectPrefab;

        private World world;

        private void Awake()
        {
            // Initialize our ECS world
            world = new World();

            SystemRegistry.Initialize(world);
            RegisterSystems();
        }

        private void RegisterSystems()
        {
            //Singleton Creation system
            SystemRegistry.AddSystem(new SingletonCreationSystem(this));

            //Creation System
            SystemRegistry.AddSystem(
                new MusicNoteCreationSystem(musicNoteCreationSettings, generalGameSetting)
            );
            SystemRegistry.AddSystem(new ScoreEffectCreationSystem(this));

            //Handling Data system
            SystemRegistry.AddSystem(new MovingNoteSystem(generalGameSetting));
            SystemRegistry.AddSystem(new InputSystem());
            SystemRegistry.AddSystem(new InputCollisionSystem(generalGameSetting));
            SystemRegistry.AddSystem(new ScoringSystem(this));
            SystemRegistry.AddSystem(new ScoreEffectSystem(this));

            //Syncer systems
            SystemRegistry.AddSystem(new MusicNoteSyncer(this));
            SystemRegistry.AddSystem(new StartingNoteSyncer(this));
            SystemRegistry.AddSystem(new ScoreUISyncer(this));

            //Game State system
            SystemRegistry.AddSystem(new GameStateSystem(this));
        }

        private void Update()
        {
            // Update all systems with current frame's delta time
            SystemRegistry.Update(Time.deltaTime);
        }
    }
}

================
File: Core/GlobalPoint.cs.meta
================
fileFormatVersion: 2
guid: a3234adf86578d14ca74bc8cc99f7901
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/IComponent.cs
================
namespace ECS_MagicTile
{
    public interface IComponent { }
}

================
File: Core/IComponent.cs.meta
================
fileFormatVersion: 2
guid: 5bfc30fb61b4b4792b8875b3f63c5a3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/IEntityHolder.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public interface IEntityHolder
    {
        public int EntityId { get; }

        public void SetEntityId(int id);
    }
}

================
File: Core/IEntityHolder.cs.meta
================
fileFormatVersion: 2
guid: 1049762c28d04a94da5cb9e99c65ebb4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/IGameSystem.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    // Interface that all our game systems will implement

    public interface IGameSystem
    {
        void SetWorld(World world);
        void Initialize(); // Called when system is first created
        void Update(float deltaTime); // Called every frame
        void Cleanup();
        bool IsEnabled { get; set; } // Controls if system should be updated
        World World { get; set; }
        EGameState GameStateToExecute { get; }
    }
}

================
File: Core/IGameSystem.cs.meta
================
fileFormatVersion: 2
guid: 38d38b21b37a3cf4dbb318fce0f3efdf
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/StorageManager.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Manages all archetype storages in our game
    public class StorageManager
    {
        // Maps archetype hashes to their storage
        private readonly Dictionary<int, ArchetypeStorage> storages;
        private readonly Dictionary<int, List<ArchetypeStorage>> aspectStorages;

        public StorageManager()
        {
            storages = new Dictionary<int, ArchetypeStorage>();
            aspectStorages = new Dictionary<int, List<ArchetypeStorage>>();

            // First, create regular storages
            foreach (var archetype in Archetype.Registry.GetAllArchetypes())
            {
                if (!IsAspectArchetype(archetype))
                {
                    storages[archetype.GetHash()] = new ArchetypeStorage(archetype);
                }

                if (IsAspectArchetype(archetype))
                {
                    // Find all archetypes that contain these components
                    var matchingStorages = FindMatchingStorages(archetype);
                    aspectStorages[archetype.GetHash()] = matchingStorages;
                }
            }
        }

        private bool IsAspectArchetype(Archetype archetype)
        {
            // You could mark aspect archetypes explicitly, or use a naming convention,
            // or determine based on component count
            return archetype.IsAspect;
        }

        private List<ArchetypeStorage> FindMatchingStorages(Archetype aspectArchetype)
        {
            var matchingStorages = new List<ArchetypeStorage>();
            var requiredComponents = aspectArchetype.GetTypes();

            foreach (var storage in storages.Values)
            {
                // Check if this storage's archetype contains all required components
                bool matches = true;
                foreach (var component in requiredComponents)
                {
                    if (!HasComponent(storage, component))
                    {
                        matches = false;
                        break;
                    }
                }

                if (matches)
                {
                    matchingStorages.Add(storage);
                }
            }

            return matchingStorages;
        }

        // Get storage for a specific archetype
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            if (!storages.TryGetValue(archetype.GetHash(), out var storage))
            {
                throw new InvalidOperationException($"No storage found for archetype {archetype}");
            }
            return storage;
        }

        public IEnumerable<ArchetypeStorage> GetStoragesForAspect(Archetype aspectArchetype)
        {
            if (aspectStorages.TryGetValue(aspectArchetype.GetHash(), out var storageList))
            {
                return storageList;
            }
            return Array.Empty<ArchetypeStorage>();
        }

        private bool HasComponent(ArchetypeStorage storage, ComponentType componentType)
        {
            try
            {
                // We try to get the component array - if it exists, the storage has this component
                Array componentArray = storage.GetComponentArrayRaw(componentType);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}

================
File: Core/StorageManager.cs.meta
================
fileFormatVersion: 2
guid: 6e34b51edd65cc54298a958d1e7db250
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/SystemRegistry.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Our central system management class
    public static class SystemRegistry
    {
        // Store systems in order of execution priority
        private static readonly List<IGameSystem> updateSystems = new();
        private static World world;
        private static bool isInitialized;
        private static EGameState currentGameState = EGameState.WaitingToStart;

        // Initialize our registry with a world reference
        public static void Initialize(World gameWorld)
        {
            // Prevent multiple initializations
            if (isInitialized)
            {
                Debug.LogWarning("SystemRegistry already initialized!");
                return;
            }

            world = gameWorld;
            isInitialized = true;
        }

        // Allow adding systems from GlobalPoint
        public static void AddSystem(IGameSystem system)
        {
            if (!isInitialized)
            {
                Debug.LogError("SystemRegistry not initialized! Call Initialize first.");
                return;
            }

            // Provide the system with world reference and initialize it
            system.SetWorld(world);
            system.Initialize();

            updateSystems.Add(system);

            Debug.Log($"Added system: {system.GetType().Name}");
        }

        public static void Update(float deltaTime)
        {
            if (!isInitialized)
                return;

            foreach (var system in updateSystems)
            {
                if (
                    system.IsEnabled
                    && (
                        system.GameStateToExecute == currentGameState
                        || system.GameStateToExecute == EGameState.All
                    )
                )
                {
                    try
                    {
                        system.Update(deltaTime);
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error in system {system.GetType().Name}: {e}");
                    }
                }
            }
        }

        public static void Cleanup()
        {
            foreach (var system in updateSystems)
            {
                system.Cleanup();
            }

            updateSystems.Clear();
            isInitialized = false;
            world = null;
        }

        public static void SetGameState(EGameState newState)
        {
            currentGameState = newState;
        }
    }
}

================
File: Core/SystemRegistry.cs.meta
================
fileFormatVersion: 2
guid: ae3ac3479b706d64f83a41cf766e7021
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/World.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    public class World
    {
        private readonly StorageManager storageManager;
        private int nextEntityId = 1000; // Starting from 1000 to leave room for special IDs

        public World()
        {
            storageManager = new StorageManager();
        }

        // Creates an entity of a specific archetype
        private int CreateEntity()
        {
            int entityId = nextEntityId++;
            return entityId;
        }

        // Gets a specific storage for systems to use
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            return storageManager.GetStorage(archetype);
        }

        // Helper method to create and set up an entity in one go
        public int CreateEntityWithComponents(Archetype archetype, ReadOnlySpan<object> components)
        {
            int entityId = CreateEntity();
            ArchetypeStorage storage = GetStorage(archetype);
            storage.Add(entityId, components);
            return entityId;
        }
    }
}

================
File: Core/World.cs.meta
================
fileFormatVersion: 2
guid: 1df84a3b9711fcb41b790ef98664b125
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/ActiveStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ActiveStateComponent : IComponent
    {
        public bool isActive;
    }
}

================
File: DataComponents/ActiveStateComponent.cs.meta
================
fileFormatVersion: 2
guid: a3c5cd13e343b874085a9dacaa62d089
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/CornerComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct CornerComponent : IComponent
    {
        public Vector2 TopLeft;
        public Vector2 TopRight;
        public Vector2 BottomLeft;
        public Vector2 BottomRight;
    }
}

================
File: DataComponents/CornerComponent.cs.meta
================
fileFormatVersion: 2
guid: b96e4a6c6cb604761b6ec117819be5b4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/GraphicComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct GraphicComponent : IComponent
    {
        public float Alpha;
    }
}

================
File: DataComponents/GraphicComponent.cs.meta
================
fileFormatVersion: 2
guid: 82ef7ef712a2447df8b498a1935315b2

================
File: DataComponents/InputStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct InputStateComponent : IComponent
    {
        public bool IsActive;
        public Vector2 Position;
        public Vector2 PreviousPosition;
        public InputState State;
        public int FrameCount;
    }
}

================
File: DataComponents/InputStateComponent.cs.meta
================
fileFormatVersion: 2
guid: 97c04fe8669d4470d94eec98d4274ef1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/LongNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct LongNoteTagComponent : IComponent { }
}

================
File: DataComponents/LongNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 58353002a3593244d8bf12e61f349c98
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/MusicNoteComponent.cs
================
using ECS_MagicTile;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteComponent : IComponent
    {
        public int PostionId;
        public float TimeAppear;
        public float Duration;
        public MusicNoteType musicNoteType;
    }
}

================
File: DataComponents/MusicNoteComponent.cs.meta
================
fileFormatVersion: 2
guid: e13eda0f52da940ceaec30f721998b78
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/MusicNoteFillerComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteFillerComponent : IComponent
    {
        public bool IsVisible;
        public float FillPercent;
    }
}

================
File: DataComponents/MusicNoteFillerComponent.cs.meta
================
fileFormatVersion: 2
guid: d7e3fc83bb7c04b7b9b06366cc8a2202
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/MusicNoteInteractionComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteInteractionComponent : IComponent
    {
        public MusicNoteInteractiveState State;
    }
}

================
File: DataComponents/MusicNoteInteractionComponent.cs.meta
================
fileFormatVersion: 2
guid: e6da2d26198754d3382d07b0e55fa2f1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/PerfectLineTagComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct PerfectLineTagComponent : IComponent
    {
        public float PerfectLineWidth;
    }
}

================
File: DataComponents/PerfectLineTagComponent.cs.meta
================
fileFormatVersion: 2
guid: e18089c9ed33d49f8b76960358f6a4d2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/ScoreComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ScoreComponent : IComponent
    {
        public int TotalScore;
    }
}

================
File: DataComponents/ScoreComponent.cs.meta
================
fileFormatVersion: 2
guid: fa68460c39b07454594ff59898fdcbbe
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/ScoreEffectComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct TransformComponentGroup : IComponent
    {
        public TransformComponent[] satelliteEffects;
    }
}

================
File: DataComponents/ScoreEffectComponent.cs.meta
================
fileFormatVersion: 2
guid: 363408fdc911f4ec2b3d751d95811afb

================
File: DataComponents/ScoreStateComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile
{
    public struct ScoreStateComponent : IComponent
    {
        public bool HasBeenScored;
    }
}

================
File: DataComponents/ScoreStateComponent.cs.meta
================
fileFormatVersion: 2
guid: f7658e090bcd30d46b50748601faa672
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/ShortNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ShortNoteTagComponent : IComponent { }
}

================
File: DataComponents/ShortNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 83c9ef9fdf039c843b9556bfba72a05a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/StartingNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct StartingNoteTagComponent : IComponent
    {
        public int initalLane;
    }
}

================
File: DataComponents/StartingNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 60788d363c63c884e898300f27bf2be1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/TransformComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct TransformComponent : IComponent
    {
        public Vector2 Posision;
        public Vector2 Size;
        public Vector2 rotation;
    }
}

================
File: DataComponents/TransformComponent.cs.meta
================
fileFormatVersion: 2
guid: ff2e94255bc1f499a986a60df04d62ec
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DTO/MusicNoteMidiData.cs
================
using UnityEngine;

public struct MusicNoteMidiData : IDataComponent
{
    // Core data arrays
    public int[] Ids;
    public int[] NoteNumbers;
    public int[] PositionIds;
    public float[] TimeAppears;
    public float[] Timespans;
    public float[] Durations;
    public float[] Velocities;

    // Metadata
    public int TotalNotes;
    public float MinDuration;

    public MusicNoteMidiData(int capacity)
    {
        // Preallocate arrays with specified capacity
        Ids = new int[capacity];
        NoteNumbers = new int[capacity];
        TimeAppears = new float[capacity];
        Timespans = new float[capacity];
        Durations = new float[capacity];
        Velocities = new float[capacity];
        PositionIds = new int[capacity];

        TotalNotes = 0;
        MinDuration = float.MaxValue;
    }
}

================
File: DTO/MusicNoteMidiData.cs.meta
================
fileFormatVersion: 2
guid: 0772d691d2fae418b83ddb22ddc64cc6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannels/BoolEventChannel.cs
================
using UnityEngine;

namespace EventChannel
{
    [CreateAssetMenu(
        fileName = "SO_ScoreSignalEffectChannel",
        menuName = "Event Channels/Score Signal Effect Channel"
    )]
    public class BoolEventChannel : EventChannelSO<bool> { }
}

================
File: EventChannels/BoolEventChannel.cs.meta
================
fileFormatVersion: 2
guid: 20ec6d5789c44934380628f5b1389ae7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannels/EntityIdChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 84c124985c8ec984998e8fd8a7792f33, type: 3}
  m_Name: EntityIdChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: EventChannels/EntityIdChannel.asset.meta
================
fileFormatVersion: 2
guid: 44439b2ecef163c4e8e6b70a713339a8
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannels/IntEventChannel.cs
================
using UnityEngine;

namespace EventChannel
{
    [CreateAssetMenu(fileName = "IntEventChannel", menuName = "Event Channels/Int event channel")]
    public class IntEventChannel : EventChannelSO<int> { }
}

================
File: EventChannels/IntEventChannel.cs.meta
================
fileFormatVersion: 2
guid: 84c124985c8ec984998e8fd8a7792f33
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannels/SO_ScoreSignalEffectChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 20ec6d5789c44934380628f5b1389ae7, type: 3}
  m_Name: SO_ScoreSignalEffectChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: EventChannels/SO_ScoreSignalEffectChannel.asset.meta
================
fileFormatVersion: 2
guid: ea0ef8d03bdeb4c4784bc02c8a47c318
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/BurstMovement.cs
================
using UnityEngine;

/// <summary>
/// Implements a customizable burst movement behavior where an object accelerates to a maximum speed,
/// maintains that speed for a configurable distance, then smoothly decelerates to a stop.
/// The movement uses exponential functions to create natural-feeling acceleration and deceleration.
/// </summary>
/// <remarks>
/// The movement is divided into two phases:
/// 1. Burst Phase: Object accelerates from initial speed to max speed using a smooth exponential curve
/// 2. Deceleration Phase: Object gradually slows down to a stop using natural exponential decay
///
/// Mathematical formulas used:
/// - Acceleration: speed = maxSpeed * (initialPercent + (1-initialPercent) * (1-e^(-aF * x)))
/// - Deceleration: speed = maxSpeed * e^(-dF * x)
/// Where:
/// - aF = acceleration factor
/// - dF = deceleration factor
/// - x = progress (0 to 1) in current phase
/// </remarks>
public class BurstMovement : MonoBehaviour
{
    [Header("Movement Properties")]
    [SerializeField]
    private Vector3 direction = Vector3.forward;

    [SerializeField]
    private float maxDistance = 10f;

    [Header("Speed Properties")]
    [SerializeField]
    private float maxSpeed = 10f;

    [SerializeField, Range(0.5f, 5f)]
    private float accelerationFactor = 2f;

    [SerializeField, Range(0.5f, 5f)]
    private float decelerationFactor = 1.5f;

    [Header("Burst Configuration")]
    [SerializeField, Range(0f, 100f)]
    private float burstEndPercentage = 50f;

    [SerializeField, Range(0f, 1f)]
    private float initialSpeedPercent = 0.1f;

    private Vector3 startPosition;
    private float currentSpeed;
    private bool hasStarted;

    /// <summary>
    /// Initializes the movement component by storing the starting position and normalizing the direction vector.
    /// </summary>
    private void Start()
    {
        startPosition = transform.position;
        direction = direction.normalized;
        hasStarted = true;

        Debug.Log(
            $"=== Initial Parameters ===\n"
                + $"Max Speed: {maxSpeed}\n"
                + $"Max Distance: {maxDistance}\n"
                + $"Acceleration Factor: {accelerationFactor}\n"
                + $"Deceleration Factor: {decelerationFactor}\n"
                + $"Direction: {direction}"
        );
    }

    /// <summary>
    /// Updates the object's position each frame based on the current movement phase and calculated speed.
    /// Handles progression through acceleration and deceleration phases until reaching the target distance.
    /// </summary>
    private void Update()
    {
        if (!hasStarted)
            return;

        float distanceTraveled = Vector3.Distance(transform.position, startPosition);
        float distancePercentage = (distanceTraveled / maxDistance) * 100f;

        if (distancePercentage >= 100f)
        {
            hasStarted = false;
            return;
        }

        currentSpeed = CalculateSpeed(distancePercentage);
        transform.position += direction * (currentSpeed * Time.deltaTime);
    }

    /// <summary>
    /// Calculates the current speed based on the percentage of total distance traveled.
    /// Uses different mathematical formulas for acceleration and deceleration phases.
    /// </summary>
    /// <param name="distancePercentage">Current distance traveled as a percentage (0-100) of total distance</param>
    /// <returns>The calculated speed for the current frame</returns>
    /// <remarks>
    /// During acceleration (0% to burstEndPercentage):
    /// - Starts at initialSpeedPercent of maxSpeed
    /// - Smoothly accelerates to maxSpeed using exponential approach
    ///
    /// During deceleration (burstEndPercentage to 100%):
    /// - Starts at maxSpeed
    /// - Exponentially decays to zero
    /// </remarks>
    private float CalculateSpeed(float distancePercentage)
    {
        // Acceleration phase
        if (distancePercentage <= burstEndPercentage)
        {
            float accelerationProgress = distancePercentage / burstEndPercentage;
            return maxSpeed
                * (
                    initialSpeedPercent
                    + (1f - initialSpeedPercent)
                        * (1f - Mathf.Exp(-accelerationFactor * accelerationProgress))
                );
        }
        // Deceleration phase
        else
        {
            float decelerationProgress =
                (distancePercentage - burstEndPercentage) / (100f - burstEndPercentage);
            return maxSpeed * Mathf.Exp(-decelerationFactor * decelerationProgress);
        }
    }

    /// <summary>
    /// Draws debug visualization in the Scene view to help understand the movement path and progress.
    /// </summary>
    private void OnDrawGizmos()
    {
        if (!Application.isPlaying)
            return;

        // Draw the full path
        Gizmos.color = Color.yellow;
        Gizmos.DrawLine(startPosition, startPosition + direction * maxDistance);

        // Draw burst end point
        Vector3 burstEndPoint =
            startPosition + direction * (maxDistance * burstEndPercentage / 100f);
        Gizmos.color = Color.blue;
        Gizmos.DrawWireSphere(burstEndPoint, 0.3f);

        // Draw current position
        Gizmos.color = Color.green;
        Gizmos.DrawWireSphere(transform.position, 0.2f);
    }
}

================
File: MonoScripts/BurstMovement.cs.meta
================
fileFormatVersion: 2
guid: 8e0f7f48d9c2e439db3417617e6b029a

================
File: MonoScripts/BurstMovementUI.cs
================
using UnityEngine;

/// <summary>
/// Implements a customizable burst movement behavior for UI elements using RectTransform.
/// The movement creates smooth acceleration and deceleration using exponential functions,
/// while working in UI space coordinates.
/// </summary>
/// <remarks>
/// This version is specifically designed for UI elements and uses anchoredPosition
/// for movement calculations. The mathematical principles remain the same as the
/// Transform version, but adapted for 2D UI space.
/// </remarks>
public class UIBurstMovement : MonoBehaviour
{
    [Header("Movement Properties")]
    [SerializeField]
    private Vector2 direction = Vector2.right;

    [SerializeField]
    private float maxDistance = 100f; // In UI units

    [Header("Speed Properties")]
    [SerializeField]
    private float maxSpeed = 500f; // UI units per second

    [SerializeField, Range(0.5f, 5f)]
    private float accelerationFactor = 2f;

    [SerializeField, Range(0.5f, 5f)]
    private float decelerationFactor = 1.5f;

    [Header("Burst Configuration")]
    [SerializeField, Range(0f, 100f)]
    private float burstEndPercentage = 50f;

    [SerializeField, Range(0f, 1f)]
    private float initialSpeedPercent = 0.1f;

    private RectTransform rectTransform;
    private Vector2 startPosition; // Starting anchoredPosition
    private float currentSpeed;
    private bool hasStarted;

    /// <summary>
    /// Initializes the UI movement component by getting the RectTransform component
    /// and storing the initial anchoredPosition.
    /// </summary>
    private void Start()
    {
        // Get the RectTransform component (required for UI elements)
        rectTransform = GetComponent<RectTransform>();
        if (rectTransform == null)
        {
            Debug.LogError("UIBurstMovement requires a RectTransform component!");
            enabled = false;
            return;
        }

        // Store initial anchored position and normalize direction
        startPosition = rectTransform.anchoredPosition;
        direction = direction.normalized;
        hasStarted = true;

        Debug.Log(
            $"=== UI Movement Parameters ===\n"
                + $"Start Position: {startPosition}\n"
                + $"Direction: {direction}\n"
                + $"Max Distance: {maxDistance} UI units\n"
                + $"Max Speed: {maxSpeed} UI units/sec"
        );
    }

    /// <summary>
    /// Updates the UI element's position each frame using RectTransform's anchoredPosition.
    /// </summary>
    private void Update()
    {
        if (!hasStarted)
            return;

        // Calculate distance in UI space
        float distanceTraveled = Vector2.Distance(rectTransform.anchoredPosition, startPosition);
        float distancePercentage = (distanceTraveled / maxDistance) * 100f;

        if (distancePercentage >= 100f)
        {
            hasStarted = false;
            return;
        }

        // Calculate and apply movement in UI space
        currentSpeed = CalculateSpeed(distancePercentage);
        Vector2 newPosition =
            (Vector2)rectTransform.anchoredPosition + direction * (currentSpeed * Time.deltaTime);
        rectTransform.anchoredPosition = newPosition;
    }

    // The CalculateSpeed method remains the same as it works with abstract units
    private float CalculateSpeed(float distancePercentage)
    {
        if (distancePercentage <= burstEndPercentage)
        {
            float accelerationProgress = distancePercentage / burstEndPercentage;
            return maxSpeed
                * (
                    initialSpeedPercent
                    + (1f - initialSpeedPercent)
                        * (1f - Mathf.Exp(-accelerationFactor * accelerationProgress))
                );
        }
        else
        {
            float decelerationProgress =
                (distancePercentage - burstEndPercentage) / (100f - burstEndPercentage);
            return maxSpeed * Mathf.Exp(-decelerationFactor * decelerationProgress);
        }
    }
}

================
File: MonoScripts/BurstMovementUI.cs.meta
================
fileFormatVersion: 2
guid: 16ca30dd2c053408ca1f8899ec5e4e9e

================
File: MonoScripts/RaycastToObjects.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class RaycastToObjects : MonoBehaviour
    {
        [SerializeField]
        private LayerMask targetLayer;

        [SerializeField]
        private IntEventChannel startNoteEntityIdChannel;

        // Update is called once per frame
        void Update()
        {
            if (Input.GetMouseButtonDown(0))
            {
                FireRaycast();
            }
        }

        private void FireRaycast()
        {
            Vector2 mousePosition = Camera.main.ScreenToWorldPoint(Input.mousePosition);
            RaycastHit2D hit = Physics2D.Raycast(
                mousePosition,
                Vector2.zero,
                Mathf.Infinity,
                targetLayer
            );

            if (hit.collider != null)
            {
                if (hit.collider.tag == "StartNote")
                {
                    startNoteEntityIdChannel?.RaiseEvent(
                        hit.collider.GetComponent<IEntityHolder>().EntityId
                    );
                }
            }
            else
            {
                Debug.Log("No object hit.");
            }
        }
    }
}

================
File: MonoScripts/RaycastToObjects.cs.meta
================
fileFormatVersion: 2
guid: 2b6518ec189777e4cbad7fdd60b44c76
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/SatelliteAnimationManager.cs
================
using System.Collections;
using ECS_MagicTile;
using PrimeTween;
using UnityEngine;

/// <summary>
/// Handles the movement and animation of satellite UI elements that spread out from a central point.
/// </summary>
public class SatelliteAnimationManager : MonoBehaviour { }

================
File: MonoScripts/SatelliteAnimationManager.cs.meta
================
fileFormatVersion: 2
guid: 27711f19893204562bebc1bae58b056f

================
File: MonoScripts/ScoreEffectController.cs
================
using System;
using EventChannel;
using PrimeTween;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class ScoreEffectController : MonoBehaviour
    {
        [Header("Event Channels")]
        [SerializeField]
        private BoolEventChannel scoreSignalEffectChannel;

        [SerializeField]
        private ScoreEffectSettings perfectScoreEffectSettings;

        [SerializeField]
        private ScoreEffectSettings greatScoreEffectSettings;

        private Sequence sequence;

        void OnEnable()
        {
            scoreSignalEffectChannel.Subscribe(PlayEffect);
            sequence = Sequence.Create();
        }

        void OnDisable()
        {
            scoreSignalEffectChannel.Unsubscribe(PlayEffect);
        }

        private void PlayEffect(bool isPerfect) { }
    }

    [System.Serializable]
    public class ScoreEffectSettings
    {
        public Image mainEffectRect;
        public float timeToCompleteScaleUp;
        public float timeDelayToFade;
        public float timeToCompleteFadeOut;
        public SatelliteSettings[] satellite;
        public AnimationCurve customCurve;

        public RectTransform mainRect
        {
            get => mainEffectRect.rectTransform;
        }
    }

    [Serializable]
    public class SatelliteSettings
    {
        public Image image; // Changed from RectTransform to Image
        public Vector2 destPointAwayFromOrigin;
        public float rotatonSpanStart;
        public float rotationSpanEnd;
    }
}

================
File: MonoScripts/ScoreEffectController.cs.meta
================
fileFormatVersion: 2
guid: 4c404b5dc2d1b3243807aa10259f386a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/GeneralGameSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 24a2a689475a5aa4997e54b10cc3c33c, type: 3}
  m_Name: GeneralGameSetting_SO
  m_EditorClassIdentifier: 
  GameSpeed: 8

================
File: Settings/GeneralGameSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: cc747aeaca6f5864099880016a577e56
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/GeneralGameSetting.cs
================
using UnityEngine;

[CreateAssetMenu(fileName = "GeneralGameSetting_SO", menuName = "Settings/GeneralGameSetting")]
public class GeneralGameSetting : ScriptableObject
{
    public float GameSpeed;
}

================
File: Settings/GeneralGameSetting.cs.meta
================
fileFormatVersion: 2
guid: 24a2a689475a5aa4997e54b10cc3c33c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/MidiNoteParser.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

public static class MidiNoteParser
{
    public static MusicNoteMidiData ParseFromText(string content)
    {
        if (string.IsNullOrEmpty(content))
            throw new MidiParseException("MIDI content cannot be empty");

        var entries = content.Split(',', StringSplitOptions.RemoveEmptyEntries);
        if (entries.Length == 0)
            throw new MidiParseException("No valid MIDI entries found");

        // Split into note entries
        var data = new MusicNoteMidiData(entries.Length);

        for (int i = 0; i < entries.Length; i++)
        {
            try
            {
                ParseEntry(entries[i], i, ref data);
                data.TotalNotes++;
            }
            catch (Exception ex)
            {
                throw new MidiParseException($"Error parsing entry {i}: {ex.Message}");
            }
        }

        ValidateData(ref data);

        return data;
    }

    private static void ParseEntry(string entry, int index, ref MusicNoteMidiData data)
    {
        var properties = entry.Split('-');
        var requiredFields = new HashSet<string> { "id", "n", "ta", "ts", "d", "v", "pid" };
        var parsedFields = new HashSet<string>();

        foreach (var prop in properties)
        {
            var kv = prop.Split(':');
            if (kv.Length != 2)
                throw new MidiParseException($"Invalid property format: {prop}");

            if (!ParseProperty(kv[0], kv[1], index, ref data))
                throw new MidiParseException($"Failed to parse property: {kv[0]}");

            parsedFields.Add(kv[0]);
        }

        // Check for missing required fields
        requiredFields.ExceptWith(parsedFields);
        if (requiredFields.Count > 0)
            throw new MidiParseException(
                $"Missing required fields: {string.Join(", ", requiredFields)}"
            );
    }

    private static bool ParseProperty(
        string key,
        string value,
        int index,
        ref MusicNoteMidiData data
    )
    {
        try
        {
            switch (key)
            {
                case "id":
                    data.Ids[index] = int.Parse(value);
                    break;
                case "n":
                    data.NoteNumbers[index] = int.Parse(value);
                    break;
                case "ta":
                    data.TimeAppears[index] = float.Parse(value);
                    break;
                case "ts":
                    data.Timespans[index] = float.Parse(value);
                    break;
                case "d":
                    float duration = float.Parse(value);
                    data.Durations[index] = duration;
                    data.MinDuration = Mathf.Min(data.MinDuration, duration);
                    break;
                case "v":
                    data.Velocities[index] = float.Parse(value);
                    break;
                case "pid":
                    data.PositionIds[index] = int.Parse(value);
                    break;
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static void ValidateData(ref MusicNoteMidiData data)
    {
        if (data.MinDuration <= 0)
            throw new MidiParseException("Invalid minimum duration");

        if (data.TotalNotes <= 0)
            throw new MidiParseException("No valid notes parsed");
    }
}

public class MidiParseException : Exception
{
    public MidiParseException(string message)
        : base(message) { }
}

================
File: Settings/MidiNoteParser.cs.meta
================
fileFormatVersion: 2
guid: ccd8b8d0c202c4c46a3c94a768d54c37
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/MusicNoteCreationSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a5af8e59dd796d941989a811a2c8754b, type: 3}
  m_Name: MusicNoteCreationSetting_SO
  m_EditorClassIdentifier: 
  MidiContent: {fileID: 4900000, guid: 5651cca0434e843a4af2569038996f88, type: 3}
  ShortNoteScaleYFactor: 1.4
  LongNoteScaleYFactor: 2.5
  startingNoteLane: 0
  LongTilePrefab: {fileID: 8137537297466452066, guid: 12f1ab7db8533406285c2148378e45d8, type: 3}
  ShortTilePrefab: {fileID: 8137537297466452066, guid: 8c1c272d019a341fa8cc13b90b199606, type: 3}
  startingNotePrefab: {fileID: 8137537297466452066, guid: 3ab92a42b30f7d440901bcd50afe0d58, type: 3}

================
File: Settings/MusicNoteCreationSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: 5d1ed20f8d24fbd4f95a64d2f692fb66
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/MusicNoteCreationSetting.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(
        fileName = "MusicNoteCreationSetting_SO",
        menuName = "Settings/MusicNoteCreationSetting"
    )]
    public class MusicNoteCreationSetting : ScriptableObject
    {
        [Header("Song Data")]
        public TextAsset MidiContent;

        [Header("Note Configuration")]
        public float ShortNoteScaleYFactor;
        public float LongNoteScaleYFactor;
        public float startingNoteLane;

        [Header("Prefabs")]
        public GameObject LongTilePrefab;
        public GameObject ShortTilePrefab;
        public GameObject startingNotePrefab;
    }
}

================
File: Settings/MusicNoteCreationSetting.cs.meta
================
fileFormatVersion: 2
guid: a5af8e59dd796d941989a811a2c8754b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/ScoreEffectSettings_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 90b3ef9aef2e740baa6d7b0a8da6158d, type: 3}
  m_Name: ScoreEffectSettings_SO
  m_EditorClassIdentifier: 
  perfectScoreEffectPrefab: {fileID: 0}
  greatScoreEffectPrefab: {fileID: 0}

================
File: Settings/ScoreEffectSettings_SO.asset.meta
================
fileFormatVersion: 2
guid: 0fc1bf2a08ee74502af5a8c06e294b7f
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/ScoreEffectSettings.cs
================
using UnityEngine;

namespace ECS_MagicTile.Settings
{
    [CreateAssetMenu(
        fileName = "ScoreEffectSettings_SO",
        menuName = "Settings/ScoreEffectSettings"
    )]
    public class ScoreEffectSettings : ScriptableObject
    {
        [Header("Perfect Score Effect")]
        public GameObject perfectScoreEffectPrefab;

        [Header("Great Score Prefab")]
        public GameObject greatScoreEffectPrefab;
    }
}

================
File: Settings/ScoreEffectSettings.cs.meta
================
fileFormatVersion: 2
guid: 90b3ef9aef2e740baa6d7b0a8da6158d

================
File: Syncers/MusicNoteSyncer.cs
================
using System;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteSyncer : ArchetypeSyncer
    {
        protected override Archetype Archetype => Archetype.Registry.MusicNote;

        public override EGameState GameStateToExecute { get; } = EGameState.Ingame;

        private readonly EntityViewFactory shortNoteViewFactory;
        private readonly EntityViewFactory longNoteViewFactory;

        // Cache component arrays to avoid getting them each frame
        private TransformComponent[] transforms;
        private MusicNoteComponent[] notes;
        private MusicNoteInteractionComponent[] interactions;
        private MusicNoteFillerComponent[] fillers;

        // Cache frequently accessed components
        private readonly Dictionary<int, SpriteRenderer> noteRenderers = new();
        private readonly Dictionary<int, (GameObject obj, SpriteRenderer renderer)> fillerCache =
            new();

        public MusicNoteSyncer(GlobalPoint globalPoint)
        {
            shortNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.ShortTilePrefab,
                globalPoint.transform
            );
            longNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.LongTilePrefab,
                globalPoint.transform
            );
        }

        public override void Initialize()
        {
            IsEnabled = true;

            // Initialize component array references
            transforms = DedicatedStorage.GetComponents<TransformComponent>();
            notes = DedicatedStorage.GetComponents<MusicNoteComponent>();
            interactions = DedicatedStorage.GetComponents<MusicNoteInteractionComponent>();
            fillers = DedicatedStorage.GetComponents<MusicNoteFillerComponent>();
        }

        public override void Update(float deltaTime)
        {
            // Process notes in batches for better cache utilization
            const int BATCH_SIZE = 64;
            int totalNotes = DedicatedStorage.Count;

            for (int batchStart = 0; batchStart < totalNotes; batchStart += BATCH_SIZE)
            {
                int batchEnd = Math.Min(batchStart + BATCH_SIZE, totalNotes);
                ProcessNoteBatch(batchStart, batchEnd);
            }
        }

        private void ProcessNoteBatch(int start, int end)
        {
            for (int i = start; i < end; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];

                // Get or create view based on note type
                GameObject view = GetOrCreateNoteView(entityId, notes[i].musicNoteType);

                view.transform.position = transforms[i].Posision;
                view.transform.localScale = transforms[i].Size;

                SyncNoteState(entityId, view, notes[i], interactions[i], fillers[i]);
            }
        }

        private GameObject GetOrCreateNoteView(int entityId, MusicNoteType noteType)
        {
            return noteType == MusicNoteType.LongNote
                ? longNoteViewFactory.GetOrCreateView(entityId, "longNote")
                : shortNoteViewFactory.GetOrCreateView(entityId, "shortNote");
        }

        private void SyncNoteState(
            int entityId,
            GameObject view,
            MusicNoteComponent note,
            MusicNoteInteractionComponent interaction,
            MusicNoteFillerComponent filler
        )
        {
            // Get cached renderer or cache it
            if (!noteRenderers.TryGetValue(entityId, out var noteRenderer))
            {
                noteRenderer = view.GetComponent<SpriteRenderer>();
                noteRenderers[entityId] = noteRenderer;
            }

            // Update note color based on state
            UpdateNoteColor(noteRenderer, interaction.State);

            // Handle long note filler
            if (note.musicNoteType == MusicNoteType.LongNote)
            {
                SyncNoteFiller(entityId, view, filler);
            }
        }

        private static void UpdateNoteColor(
            SpriteRenderer renderer,
            MusicNoteInteractiveState state
        )
        {
            renderer.color = state switch
            {
                MusicNoteInteractiveState.Normal => Color.white,
                MusicNoteInteractiveState.Pressed or MusicNoteInteractiveState.Hold => Color.yellow,
                MusicNoteInteractiveState.Completed => new Color(1, 1, 1, 0.5f),
                _ => Color.white,
            };
        }

        private void SyncNoteFiller(int entityId, GameObject view, MusicNoteFillerComponent filler)
        {
            if (!fillerCache.TryGetValue(entityId, out var fillerComponents))
            {
                var fillerObj = view.transform.Find("Filler")?.gameObject;
                if (fillerObj != null)
                {
                    fillerComponents = (fillerObj, fillerObj.GetComponent<SpriteRenderer>());
                    fillerCache[entityId] = fillerComponents;
                }
            }

            if (fillerComponents.obj != null)
            {
                fillerComponents.obj.SetActive(filler.IsVisible);
                if (filler.IsVisible)
                {
                    UpdateFillerVisuals(
                        fillerComponents.obj,
                        fillerComponents.renderer,
                        filler.FillPercent
                    );
                }
            }
        }

        private static void UpdateFillerVisuals(
            GameObject fillerObj,
            SpriteRenderer renderer,
            float fillPercent
        )
        {
            Vector3 scale = fillerObj.transform.localScale;
            scale.y = fillPercent;
            SpriteUtility.ScaleFromPivot(renderer, scale, SpriteUtility.PivotPointXY.Bottom);
            renderer.color = Color.Lerp(Color.yellow, Color.green, fillPercent);
        }
    }
}

================
File: Syncers/MusicNoteSyncer.cs.meta
================
fileFormatVersion: 2
guid: 541f4a77356ee45a381eacb214f2b6e2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers/ScoreUISyncer.cs
================
using ECS_MagicTile;
using ECS_MagicTile.Components;
using TMPro;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ScoreUISyncer : ArchetypeSyncer
    {
        public override EGameState GameStateToExecute => EGameState.All;

        protected override Archetype Archetype => Archetype.Registry.GameScore;

        private readonly TextMeshProUGUI scoreText;

        // Instead of creating UI, we receive references to existing UI elements
        public ScoreUISyncer(GlobalPoint globalPoint)
        {
            this.scoreText = globalPoint.scoreText;
        }

        public override void Update(float deltaTime)
        {
            // Get score data from storage
            var scoreComponent = DedicatedStorage.GetComponents<ScoreComponent>()[0];

            // Update UI
            scoreText.text = $"Score: {scoreComponent.TotalScore}";
        }
    }
}

================
File: Syncers/ScoreUISyncer.cs.meta
================
fileFormatVersion: 2
guid: 3a2ef7a4a601b9a45a648bd1a5870c32
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers/StartingNoteSyncer.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class StartingNoteSyncer : ArchetypeSyncer
    {
        protected override Archetype Archetype => Archetype.Registry.StartingNote;

        public override EGameState GameStateToExecute => EGameState.Ingame;

        private readonly EntityViewFactory startingNoteFactory;

        private GameObject startingNoteViewObject;

        public StartingNoteSyncer(GlobalPoint globalPoint)
        {
            startingNoteFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.startingNotePrefab,
                globalPoint.transform
            );
        }

        public override void Initialize()
        {
            base.Initialize();
            IsEnabled = true;

            TransformComponent startingNoteTransform =
                DedicatedStorage.GetComponents<TransformComponent>()[0];

            int entityId_ = DedicatedStorage.EntityIds[0];

            startingNoteViewObject = startingNoteFactory.GetOrCreateView(entityId_, "StartingNote");

            startingNoteViewObject.transform.position = startingNoteTransform.Posision;
            startingNoteViewObject.transform.localScale = startingNoteTransform.Size;
        }

        public override void Update(float deltaTime)
        {
            ActiveStateComponent activeStateComponent =
                DedicatedStorage.GetComponents<ActiveStateComponent>()[0];
            startingNoteViewObject.SetActive(activeStateComponent.isActive);
        }
    }
}

================
File: Syncers/StartingNoteSyncer.cs.meta
================
fileFormatVersion: 2
guid: c69681375b44edd44bf95aec281d01af
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/GameStateSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class GameStateSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.All;

        private readonly IntEventChannel startNoteEntityIdChannel;

        public GameStateSystem(GlobalPoint globalPoint)
        {
            startNoteEntityIdChannel = globalPoint.entityIdChannel;
        }

        public void Cleanup()
        {
            //
        }

        public void Initialize()
        {
            startNoteEntityIdChannel.Subscribe(OnStartNoteInteraction);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            //
        }

        private void OnStartNoteInteraction(int startNoteId)
        {
            ArchetypeStorage storage = World.GetStorage(Archetype.Registry.StartingNote);
            storage.GetComponents<ActiveStateComponent>()[0].isActive = false;
            SystemRegistry.SetGameState(EGameState.Ingame);
        }
    }
}

================
File: Systems/GameStateSystem.cs.meta
================
fileFormatVersion: 2
guid: 01ad329a4e8ba17448b524ad53b02f01
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/InputCollisionSystem.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class InputCollisionSystem : IGameSystem
    {
        private const string LOG_PREFIX = "[Input Collision] ";
        private const int MAX_INPUTS = 2;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        private GeneralGameSetting generalGameSetting;

        public InputCollisionSystem(GeneralGameSetting generalGameSetting)
        {
            this.generalGameSetting = generalGameSetting;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize() { }

        public void Update(float deltaTime)
        {
            ArchetypeStorage inputStorage = World.GetStorage(Archetype.Registry.Input);
            ArchetypeStorage noteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            var inputStates = inputStorage.GetComponents<InputStateComponent>();
            var transforms = noteStorage.GetComponents<TransformComponent>();
            var corners = noteStorage.GetComponents<CornerComponent>();
            var interactions = noteStorage.GetComponents<MusicNoteInteractionComponent>();
            var fillers = noteStorage.GetComponents<MusicNoteFillerComponent>();
            var notes = noteStorage.GetComponents<MusicNoteComponent>();

            for (int inputIdx = 0; inputIdx < MAX_INPUTS; inputIdx++)
            {
                if (!inputStates[inputIdx].IsActive)
                    continue;

                for (int noteIdx = 0; noteIdx < noteStorage.Count; noteIdx++)
                {
                    ProcessNoteCollision(
                        noteStorage.EntityIds[noteIdx],
                        inputStates[inputIdx],
                        ref transforms[noteIdx],
                        ref corners[noteIdx],
                        ref interactions[noteIdx],
                        ref fillers[noteIdx],
                        notes[noteIdx]
                    );
                }
            }
        }

        private void ProcessNoteCollision(
            int entityId,
            InputStateComponent input,
            ref TransformComponent transform,
            ref CornerComponent corners,
            ref MusicNoteInteractionComponent interaction,
            ref MusicNoteFillerComponent filler,
            MusicNoteComponent note
        )
        {
            // Skip completed notes
            if (interaction.State == MusicNoteInteractiveState.Completed)
                return;

            bool isInsideNote = IsPointInNote(
                input.Position,
                corners.TopLeft,
                corners.TopRight,
                corners.BottomLeft,
                corners.BottomRight
            );

            if (!isInsideNote)
                return;

            ProcessNoteInteraction(
                entityId,
                input,
                ref interaction,
                ref transform,
                ref corners,
                ref filler,
                note
            );
        }

        private void ProcessNoteInteraction(
            int entityId,
            InputStateComponent input,
            ref MusicNoteInteractionComponent interaction,
            ref TransformComponent transform,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler,
            MusicNoteComponent note
        )
        {
            switch (input.State)
            {
                case InputState.JustPressed:
                    if (interaction.State == MusicNoteInteractiveState.Normal)
                    {
                        if (note.musicNoteType == MusicNoteType.ShortNote)
                        {
                            CompleteNote(ref interaction);
                        }
                        else
                        {
                            StartLongNote(input, ref interaction, ref corners, ref filler);
                        }
                    }
                    break;

                case InputState.Held:
                    if (note.musicNoteType == MusicNoteType.LongNote)
                    {
                        if (interaction.State == MusicNoteInteractiveState.Pressed)
                        {
                            interaction.State = MusicNoteInteractiveState.Hold;
                        }
                        else if (interaction.State == MusicNoteInteractiveState.Hold)
                        {
                            UpdateLongNoteFill(ref interaction, ref corners, ref filler);
                        }
                    }
                    break;

                case InputState.JustReleased:
                    if (
                        note.musicNoteType == MusicNoteType.LongNote
                        && (
                            interaction.State == MusicNoteInteractiveState.Pressed
                            || interaction.State == MusicNoteInteractiveState.Hold
                        )
                    )
                    {
                        CompleteNote(ref interaction);
                    }
                    break;
            }
        }

        private void CompleteNote(ref MusicNoteInteractionComponent interaction)
        {
            interaction.State = MusicNoteInteractiveState.Completed;
            Debug.Log($"{LOG_PREFIX} Note completed");
        }

        private void StartLongNote(
            InputStateComponent input,
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler
        )
        {
            interaction.State = MusicNoteInteractiveState.Pressed;
            filler.IsVisible = true;

            float sizeOfNote = corners.TopLeft.y - corners.BottomLeft.y;
            float fromTouchPositionToLowerOfNote = input.Position.y - corners.BottomLeft.y;
            float touchPercent = fromTouchPositionToLowerOfNote / sizeOfNote;
            filler.FillPercent = touchPercent + 0.1f;

            Debug.Log($"{LOG_PREFIX} Long note pressed");
        }

        private void UpdateLongNoteFill(
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler
        )
        {
            float noteLength = corners.TopLeft.y - corners.BottomLeft.y;
            float gameSpeed = generalGameSetting.GameSpeed;
            float fillSpeed = gameSpeed / noteLength;

            float nextFillPercent = filler.FillPercent + (fillSpeed * Time.deltaTime);
            nextFillPercent = Mathf.Min(nextFillPercent, 1f);

            filler.FillPercent = nextFillPercent;

            if (nextFillPercent >= 1f)
            {
                CompleteNote(ref interaction);
            }
        }

        private static bool IsPointInNote(
            Vector2 point,
            Vector2 topLeft,
            Vector2 topRight,
            Vector2 bottomLeft,
            Vector2 bottomRight
        )
        {
            int wn = 0; // Winding number

            Vector2[] vertices = { topLeft, topRight, bottomRight, bottomLeft };

            for (int i = 0; i < vertices.Length; i++)
            {
                Vector2 current = vertices[i];
                Vector2 next = vertices[(i + 1) % vertices.Length];

                if (current.y <= point.y)
                {
                    if (next.y > point.y && IsLeftOf(current, next, point) > 0)
                        wn++;
                }
                else
                {
                    if (next.y <= point.y && IsLeftOf(current, next, point) < 0)
                        wn--;
                }
            }

            return wn != 0;
        }

        private static float IsLeftOf(Vector2 a, Vector2 b, Vector2 point)
        {
            return (b.x - a.x) * (point.y - a.y) - (point.x - a.x) * (b.y - a.y);
        }

        public void Cleanup() { }
    }
}

================
File: Systems/InputCollisionSystem.cs.meta
================
fileFormatVersion: 2
guid: a0d38e0610e6340709395f4e4d69e409
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/InputSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class InputSystem : IGameSystem
    {
        private const int MAX_INPUTS = 2;
        private const string LOG_PREFIX = "[Input System] ";
        private bool wasMousePressed;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            // Create input entities
            for (int i = 0; i < MAX_INPUTS; i++)
            {
                var inputComponent = new InputStateComponent
                {
                    IsActive = false,
                    Position = Vector2.zero,
                    PreviousPosition = Vector2.zero,
                    State = InputState.None,
                    FrameCount = 0,
                };

                World.CreateEntityWithComponents(
                    Archetype.Registry.Input,
                    new object[] { inputComponent }
                );
            }
        }

        public void Update(float deltaTime)
        {
            ArchetypeStorage inputStorage = World.GetStorage(Archetype.Registry.Input);
            var inputStates = inputStorage.GetComponents<InputStateComponent>();

            // Update previous states
            UpdatePreviousStates(inputStates);

            // Process new input
            if (Input.touchCount > 0)
            {
                ProcessTouchInput(inputStates);
            }
            else
            {
                ProcessMouseInput(inputStates);
            }
        }

        private void UpdatePreviousStates(InputStateComponent[] inputStates)
        {
            for (int i = 0; i < MAX_INPUTS; i++)
            {
                if (inputStates[i].State == InputState.JustReleased)
                {
                    inputStates[i].State = InputState.None;
                    inputStates[i].FrameCount = 0;
                    inputStates[i].IsActive = false;
                }
                else if (inputStates[i].State == InputState.JustPressed)
                {
                    inputStates[i].State = InputState.Held;
                }
            }
        }

        private void ProcessMouseInput(InputStateComponent[] inputStates)
        {
            bool isCurrentlyPressed = Input.GetMouseButton(0);
            Vector2 worldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);

            ref var currentState = ref inputStates[0];
            InputState newState = DetermineNewInputState(isCurrentlyPressed, wasMousePressed);

            // Only update if state changed or position changed
            if (newState != currentState.State || worldPos != currentState.Position)
            {
                UpdateInputState(ref currentState, worldPos, newState);
            }

            wasMousePressed = isCurrentlyPressed;
        }

        private void ProcessTouchInput(InputStateComponent[] inputStates)
        {
            int touchCount = Mathf.Min(Input.touchCount, MAX_INPUTS);

            // Reset unused input slots
            for (int i = touchCount; i < MAX_INPUTS; i++)
            {
                if (inputStates[i].IsActive)
                {
                    inputStates[i].State = InputState.None;
                    inputStates[i].IsActive = false;
                }
            }

            // Process active touches
            for (int i = 0; i < touchCount; i++)
            {
                Touch touch = Input.GetTouch(i);
                Vector2 worldPos = Camera.main.ScreenToWorldPoint(touch.position);

                InputState newState = touch.phase switch
                {
                    TouchPhase.Began => InputState.JustPressed,
                    TouchPhase.Moved => InputState.Held,
                    TouchPhase.Stationary => InputState.Held,
                    TouchPhase.Ended => InputState.JustReleased,
                    TouchPhase.Canceled => InputState.JustReleased,
                    _ => InputState.None,
                };

                UpdateInputState(ref inputStates[i], worldPos, newState);
            }
        }

        private void UpdateInputState(
            ref InputStateComponent state,
            Vector2 position,
            InputState newState
        )
        {
            state.PreviousPosition = state.Position;
            state.Position = position;
            state.State = newState;
            state.IsActive = newState != InputState.None;

            if (newState != state.State)
            {
                state.FrameCount = 0;
            }
            state.FrameCount++;
        }

        private InputState DetermineNewInputState(bool isPressed, bool wasPressed)
        {
            if (isPressed && !wasPressed)
                return InputState.JustPressed;
            if (!isPressed && wasPressed)
                return InputState.JustReleased;
            if (isPressed)
                return InputState.Held;
            return InputState.None;
        }

        public void Cleanup()
        {
            // Nothing to cleanup for now
        }
    }
}

================
File: Systems/InputSystem.cs.meta
================
fileFormatVersion: 2
guid: 3a7c2b94a0f5a416c8d8401ea289c387
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/MovingNoteSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MovingNoteSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        private readonly GeneralGameSetting generalGameSetting;

        public MovingNoteSystem(GeneralGameSetting generalGameSetting)
        {
            this.generalGameSetting = generalGameSetting;
        }

        public void Cleanup() { }

        public void Initialize() { }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            ArchetypeStorage musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            TransformComponent[] transforms = musicNoteStorage.GetComponents<TransformComponent>();
            CornerComponent[] corners = musicNoteStorage.GetComponents<CornerComponent>();

            float gameSpeed = generalGameSetting.GameSpeed;

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                // Update position
                Vector2 newPos = transforms[i].Posision;
                newPos.y -= gameSpeed * Time.deltaTime;
                transforms[i].Posision = newPos;

                // Update corners based on new position and size
                Vector2 halfSize = transforms[i].Size * 0.5f;
                corners[i].TopLeft = new Vector2(newPos.x - halfSize.x, newPos.y + halfSize.y);
                corners[i].TopRight = new Vector2(newPos.x + halfSize.x, newPos.y + halfSize.y);
                corners[i].BottomLeft = new Vector2(newPos.x - halfSize.x, newPos.y - halfSize.y);
                corners[i].BottomRight = new Vector2(newPos.x + halfSize.x, newPos.y - halfSize.y);
            }
        }
    }
}

================
File: Systems/MovingNoteSystem.cs.meta
================
fileFormatVersion: 2
guid: 23e31434417084f63bbc9efc34471f1f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/MusicNoteCreationSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteCreationSystem : IGameSystem
    {
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;
        private readonly GeneralGameSetting generalGameSetting;
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.WaitingToStart;

        public MusicNoteCreationSystem(
            MusicNoteCreationSetting musicNoteCreationSetting,
            GeneralGameSetting generalGameSetting
        )
        {
            this.musicNoteCreationSetting = musicNoteCreationSetting;
            this.generalGameSetting = generalGameSetting;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            MusicNoteMidiData musicNoteMidiData = MidiNoteParser.ParseFromText(
                musicNoteCreationSetting.MidiContent.text
            );

            ArchetypeStorage perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            ref CornerComponent perfectLineCorners =
                ref perfectLineStorage.GetComponents<CornerComponent>()[0];

            // Calculate lane width once
            float totalWidth = perfectLineCorners.TopRight.x - perfectLineCorners.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            for (int i = 0; i < musicNoteMidiData.TotalNotes; i++)
            {
                MusicNoteType musicNoteType = MusicNoteType.ShortNote;
                if (musicNoteMidiData.Durations[i] > musicNoteMidiData.MinDuration)
                {
                    musicNoteType = MusicNoteType.LongNote;
                }

                object[] components = new object[]
                {
                    new TransformComponent { },
                    new MusicNoteComponent
                    {
                        Duration = musicNoteMidiData.Durations[i],
                        PostionId = musicNoteMidiData.PositionIds[i],
                        TimeAppear = musicNoteMidiData.TimeAppears[i],
                        musicNoteType = musicNoteType,
                    },
                    new CornerComponent { },
                    new MusicNoteInteractionComponent { },
                    new MusicNoteFillerComponent { },
                    new ScoreStateComponent { HasBeenScored = false },
                };

                World.CreateEntityWithComponents(Archetype.Registry.MusicNote, components);
            }

            ArchetypeStorage musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            TransformComponent[] transforms = musicNoteStorage.GetComponents<TransformComponent>();
            MusicNoteComponent[] musicNotes = musicNoteStorage.GetComponents<MusicNoteComponent>();

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                float spawnX =
                    perfectLineCorners.TopLeft.x
                    + (musicNoteMidiData.PositionIds[i] * laneWidth)
                    + halfLaneWidth;

                float spawnY =
                    perfectLineCorners.TopLeft.y
                    + (musicNoteMidiData.TimeAppears[i] * generalGameSetting.GameSpeed)
                    + transforms[i].Size.y / 2f;

                transforms[i].Posision = new Vector2(spawnX, spawnY);

                float scaleX = PerfectLine.PerfectLineWidth / 4;

                float scaleY;

                if (musicNotes[i].musicNoteType == MusicNoteType.ShortNote)
                {
                    scaleY = MagicTileHelper.CalculateScaleY(
                        musicNoteCreationSetting.ShortNoteScaleYFactor,
                        scaleX
                    );
                }
                else
                {
                    scaleY = MagicTileHelper.CalculateScaleY(
                        musicNoteCreationSetting.LongNoteScaleYFactor,
                        scaleX,
                        musicNotes[i].Duration
                    );
                }

                transforms[i].Size = new Vector2(scaleX, scaleY);
            }
        }

        public void Update(float deltaTime)
        {
            //
        }

        public void Cleanup()
        {
            //
        }
    }
}

================
File: Systems/MusicNoteCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: 27223b00486847b4b86f21b0b74f2e53
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/ScoreEffectCreationSystem.cs
================
using ECS_MagicTile.Components;
using ECS_MagicTile.Settings;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ScoreEffectCreationSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.WaitingToStart;

        GameObject perfectScoreViewObject;
        GameObject greatScoreViewObject;

        public ScoreEffectCreationSystem(GlobalPoint globalPoint)
        {
            perfectScoreViewObject = globalPoint.perfectScoreEffectPrefab;
            greatScoreViewObject = globalPoint.greatScoreEffectPrefab;
        }

        public void Cleanup()
        {
            //
        }

        public void Initialize()
        {
            object[] components = new object[]
            {
                new TransformComponent { },
                new TransformComponentGroup
                {
                    satelliteEffects = new TransformComponent[
                        perfectScoreViewObject.transform.childCount
                    ],
                },
                new GraphicComponent { Alpha = 0 },
            };

            //Perfect score effect
            World.CreateEntityWithComponents(Archetype.Registry.ScoreEffect, components);

            components = new object[]
            {
                new TransformComponent { },
                new TransformComponentGroup
                {
                    satelliteEffects = new TransformComponent[
                        greatScoreViewObject.transform.childCount
                    ],
                },
                new GraphicComponent { Alpha = 0 },
            };
            //Great score effect
            World.CreateEntityWithComponents(Archetype.Registry.ScoreEffect, components);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            //
        }
    }
}

================
File: Systems/ScoreEffectCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: 545921f1e11704859948e18b90d69dff

================
File: Systems/ScoreEffectSystem.cs
================
using EventChannel;
using PrimeTween;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ScoreEffectSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        private readonly BoolEventChannel scoreEffectChannel;

        public ScoreEffectSystem(GlobalPoint globalPoint)
        {
            this.scoreEffectChannel = globalPoint.scoreEffectChannel;
        }

        public void Cleanup()
        {
            scoreEffectChannel.Unsubscribe(ExecuteEffect);
        }

        public void Initialize()
        {
            scoreEffectChannel.Subscribe(ExecuteEffect);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            //
        }

        private void ExecuteEffect(bool isPerfect)
        {
            ArchetypeStorage storage = World.GetStorage(Archetype.Registry.ScoreEffect);
        }
    }
}

================
File: Systems/ScoreEffectSystem.cs.meta
================
fileFormatVersion: 2
guid: 94c85bc6f50e84ab696b93a4a49862b1

================
File: Systems/ScoringSystem.cs
================
using System;
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ScoringSystem : IGameSystem
    {
        private const int PERFECT_SCORE = 100;
        private const int GREAT_SCORE = 50;

        // How close to perfect line needed for perfect score (in units)
        private const float PERFECT_THRESHOLD = 0.1f;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        ArchetypeStorage noteStorage;
        ArchetypeStorage gameScoreStorage;
        ArchetypeStorage perfectLineStorage;

        MusicNoteInteractionComponent[] musicNoteInteractionComponents;
        TransformComponent[] musicNoteTransformComponents;
        ScoreStateComponent[] musicScoreStateComponents;
        MusicNoteComponent[] musicNoteComponents;

        BoolEventChannel scoreSignalEffectChannel;

        public ScoringSystem(GlobalPoint globalPoint)
        {
            this.scoreSignalEffectChannel = globalPoint.scoreEffectChannel;
        }

        public void Cleanup()
        {
            //
        }

        public void Initialize()
        {
            noteStorage = World.GetStorage(Archetype.Registry.MusicNote);
            gameScoreStorage = World.GetStorage(Archetype.Registry.GameScore);
            perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            musicNoteComponents = noteStorage.GetComponents<MusicNoteComponent>();
            musicNoteInteractionComponents =
                noteStorage.GetComponents<MusicNoteInteractionComponent>();
            musicNoteTransformComponents = noteStorage.GetComponents<TransformComponent>();
            musicScoreStateComponents = noteStorage.GetComponents<ScoreStateComponent>();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            var perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>()[0];
            ref var gameScore = ref gameScoreStorage.GetComponents<ScoreComponent>()[0];

            //process note
            for (int i = 0; i < noteStorage.Count; i++)
            {
                // Only process notes that were just hit and haven't been scored
                if (musicScoreStateComponents[i].HasBeenScored)
                {
                    continue;
                }

                if (musicNoteComponents[i].musicNoteType == MusicNoteType.LongNote)
                {
                    if (
                        musicNoteInteractionComponents[i].State == MusicNoteInteractiveState.Pressed
                    )
                    {
                        ProcessNoteScore(
                            musicNoteTransformComponents[i],
                            perfectLineCorners,
                            ref gameScore,
                            ref musicScoreStateComponents[i]
                        );
                    }
                }
                else
                {
                    if (
                        musicNoteInteractionComponents[i].State == MusicNoteInteractiveState.Pressed
                        || musicNoteInteractionComponents[i].State
                            == MusicNoteInteractiveState.Completed
                    )
                    {
                        ProcessNoteScore(
                            musicNoteTransformComponents[i],
                            perfectLineCorners,
                            ref gameScore,
                            ref musicScoreStateComponents[i]
                        );
                    }
                }
            }
        }

        private void ProcessNoteScore(
            TransformComponent musicTransform,
            CornerComponent perfectLineCorners,
            ref ScoreComponent gameScore,
            ref ScoreStateComponent scoreStateComponent
        )
        {
            float distanceFromPerfect = Mathf.Abs(
                musicTransform.Posision.y - perfectLineCorners.TopLeft.y
            );

            int scoreToAdd;

            if (distanceFromPerfect <= PERFECT_THRESHOLD)
            {
                scoreToAdd = PERFECT_SCORE;
                scoreSignalEffectChannel.RaiseEvent(true);
            }
            else
            {
                scoreToAdd = GREAT_SCORE;
                scoreSignalEffectChannel.RaiseEvent(false);
            }

            gameScore.TotalScore += scoreToAdd;
            scoreStateComponent.HasBeenScored = true;
        }
    }
}

================
File: Systems/ScoringSystem.cs.meta
================
fileFormatVersion: 2
guid: 8fca9e9bcd6671c42bc6b410aa575c9e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/SingletonCreationSystem.cs
================
using ECS_MagicTile.Components;
using UnityEditor.Tilemaps;
using UnityEngine;

namespace ECS_MagicTile
{
    public class SingletonCreationSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.WaitingToStart;

        private readonly PerfectLineSettingSO perfectLineSettingSO;
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;

        public SingletonCreationSystem(GlobalPoint globalPoint)
        {
            this.perfectLineSettingSO = globalPoint.perfectLineSettingSO;
            this.musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
        }

        public void Cleanup()
        {
            //
        }

        public void Initialize()
        {
            CreatePerfectLine();
            CreateStartingNote();
            CreateGameScore();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            //
        }

        private void CreatePerfectLine()
        {
            //The perfect line singleton
            var components = new object[] { new PerfectLineTagComponent(), new CornerComponent() };
            World.CreateEntityWithComponents(Archetype.Registry.PerfectLine, components);

            ArchetypeStorage perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            ref CornerComponent perfectLineCorner =
                ref perfectLineStorage.GetComponents<CornerComponent>()[0];

            PerfectLine.PerfectLineWidth = perfectLineSettingSO.PerfectLineWidth();
            perfectLineCorner.TopLeft = perfectLineSettingSO.TopLeft;
            perfectLineCorner.TopRight = perfectLineSettingSO.TopRight;
            perfectLineCorner.BottomLeft = perfectLineSettingSO.BottomLeft;
            perfectLineCorner.BottomRight = perfectLineSettingSO.BottomRight;
        }

        private void CreateStartingNote()
        {
            var components = new object[]
            {
                new TransformComponent(),
                new ActiveStateComponent(),
                new StartingNoteTagComponent(),
            };
            World.CreateEntityWithComponents(Archetype.Registry.StartingNote, components);

            ArchetypeStorage storage = World.GetStorage(Archetype.Registry.StartingNote);
            ArchetypeStorage perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            ref ActiveStateComponent activeState =
                ref storage.GetComponents<ActiveStateComponent>()[0];
            ref TransformComponent transform = ref storage.GetComponents<TransformComponent>()[0];

            ref CornerComponent perfectLineCorners =
                ref perfectLineStorage.GetComponents<CornerComponent>()[0];

            // Calculate lane width
            float totalWidth = perfectLineCorners.TopRight.x - perfectLineCorners.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            activeState.isActive = true;

            // Calculate spawn position
            float spawnX = perfectLineCorners.TopLeft.x + (0 * laneWidth) + halfLaneWidth;
            float spawnY = perfectLineCorners.TopLeft.y;

            transform.Posision = new Vector2(spawnX, spawnY);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            float scaleX = PerfectLine.PerfectLineWidth / 4;

            float scaleY = MagicTileHelper.CalculateScaleY(
                musicNoteCreationSetting.ShortNoteScaleYFactor,
                scaleX
            );

            transform.Size = new Vector2(scaleX, scaleY);
        }

        private void CreateGameScore()
        {
            var components = new object[] { new ScoreComponent { TotalScore = 0 } };
            World.CreateEntityWithComponents(Archetype.Registry.GameScore, components);
        }
    }
}

================
File: Systems/SingletonCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: 0363a30a155e7de4492faa5045403325
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core.meta
================
fileFormatVersion: 2
guid: b57c2d5fbb39b489e9c51a111e5e8e4f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents.meta
================
fileFormatVersion: 2
guid: 401cb534838cf40049f69183b5206b9c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DTO.meta
================
fileFormatVersion: 2
guid: c3e7f3ef03f524e6089d969eb175e299
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EGameState.cs
================
namespace ECS_MagicTile
{
    public enum EGameState
    {
        WaitingToStart,
        Ingame,
        Outro,
        All,
    }
}

================
File: EGameState.cs.meta
================
fileFormatVersion: 2
guid: ea96b7999d1692748b0c374877fef0d4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannels.meta
================
fileFormatVersion: 2
guid: a808c7b858a7cf1459c4ba6cf1d5efe8
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts.meta
================
fileFormatVersion: 2
guid: eca84261f4209ea438546467839df383
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings.meta
================
fileFormatVersion: 2
guid: 27da12294979945e1b5cbf9800389eb4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers.meta
================
fileFormatVersion: 2
guid: 200d0ba3dc7c04ac6920253abe6c74a4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems.meta
================
fileFormatVersion: 2
guid: c822eec9dba9f4d4b88020ce8c3090ef
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
