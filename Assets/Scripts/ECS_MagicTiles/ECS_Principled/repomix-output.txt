This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-24T11:08:53.485Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
Core/
  Archetype.cs
  Archetype.cs.meta
  ArchetypeStorage.cs
  ArchetypeStorage.cs.meta
  ArchetypeSyncer.cs
  ArchetypeSyncer.cs.meta
  ComponentType.cs
  ComponentType.cs.meta
  EntityViewFactory.cs
  EntityViewFactory.cs.meta
  GlobalPoint.cs
  GlobalPoint.cs.meta
  IComponent.cs
  IComponent.cs.meta
  StorageManager.cs
  StorageManager.cs.meta
  SystemRegistry.cs
  SystemRegistry.cs.meta
  World.cs
  World.cs.meta
DataComponent/
  CornerComponent.cs
  CornerComponent.cs.meta
  LongNoteTagComponent.cs
  LongNoteTagComponent.cs.meta
  MusicNoteComponent.cs
  MusicNoteComponent.cs.meta
  PerfectLineTagComponent.cs
  PerfectLineTagComponent.cs.meta
  ShortNoteTagComponent.cs
  ShortNoteTagComponent.cs.meta
  TransformComponent.cs
  TransformComponent.cs.meta
Syncer/
  MusicNoteSyncer.cs
  MusicNoteSyncer.cs.meta
System/
  MovingNoteSystem.cs
  MovingNoteSystem.cs.meta
  MusicNoteCreationSystem_.cs
  MusicNoteCreationSystem_.cs.meta
Core.meta
DataComponent.meta
Syncer.meta
System.meta

================================================================
Repository Files
================================================================

================
File: Core/Archetype.cs
================
using System;
using System.Linq;

namespace ECS_MagicTile
{
    public class Archetype
    {
        private readonly ComponentType[] types;
        private readonly int hash;
        private readonly bool isAspect;

        public bool IsAspect => isAspect;

        private Archetype(ComponentType[] types, bool isAspect = false)
        {
            // Store types in a fixed order for consistent hashing
            this.types = types.OrderBy(t => t.Id).ToArray();
            this.hash = CalculateHash(this.types);
            this.isAspect = isAspect;
        }

        // Utility methods for archetype management
        public ReadOnlySpan<ComponentType> GetTypes() => types;

        public int GetHash() => hash;

        private static int CalculateHash(ComponentType[] types)
        {
            // Simple but effective hash calculation for fixed component combinations
            int hash = 17;
            foreach (var type in types)
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        // Game-specific archetypes
        public static class Registry
        {
            // Note archetypes


            public static readonly Archetype MusicNote = new(
                new[] { ComponentType.Registry.Transform, ComponentType.Registry.MusicNote }
            );

            // Game setup archetypes
            public static readonly Archetype PerfectLine = new(
                new[] { ComponentType.Registry.PerfectLine, ComponentType.Registry.Corner }
            );

            // Keep track of all archetypes for initialization
            private static readonly Archetype[] AllArchetypes = { MusicNote, PerfectLine };

            public static ReadOnlySpan<Archetype> GetAllArchetypes() => AllArchetypes;
        }
    }
}

================
File: Core/Archetype.cs.meta
================
fileFormatVersion: 2
guid: 6a700f18bf185134ebcd378e0ebfe28f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/ArchetypeStorage.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_MagicTile
{
    public class ArchetypeStorage
    {
        // Store component arrays indexed by their ComponentType
        private readonly Dictionary<ComponentType, Array> componentArrays;
        private int[] entityIds; // Tracks which entities are in this storage
        private int count; // Number of active entities

        private const int DEFAULT_CAPACITY = 64; // Starting size for our arrays
        private const float GROWTH_FACTOR = 2.0f; // How much to grow when we need more space

        public ArchetypeStorage(Archetype archetype, int initialCapacity = DEFAULT_CAPACITY)
        {
            componentArrays = new Dictionary<ComponentType, Array>();

            // Create typed arrays for each component in the archetype
            foreach (var componentType in archetype.GetTypes())
            {
                // Creates an array of the proper type with our initial capacity
                componentArrays[componentType] = Array.CreateInstance(
                    componentType.Type,
                    initialCapacity
                );
            }

            entityIds = new int[initialCapacity];
            count = 0;
        }

        // Provides type-safe access to component arrays
        public T[] GetComponents<T>()
            where T : struct
        {
            var componentType = ComponentType.Registry.GetComponentType<T>();
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {typeof(T)} not found in archetype"
                );
            }
            return (T[])array;
        }

        // Adds an entity with its components to this storage
        public void Add(int entityId, ReadOnlySpan<object> components)
        {
            // Grow arrays if needed
            if (count >= entityIds.Length)
            {
                Grow();
            }

            // Add components to their respective arrays
            int componentIndex = 0;
            foreach (var array in componentArrays.Values)
            {
                Array.Copy(new[] { components[componentIndex] }, 0, array, count, 1);
                componentIndex++;
            }

            // Track the entity
            entityIds[count] = entityId;
            count++;
        }

        // Efficiently removes an entity by swapping with the last element
        public void Remove(int entityId)
        {
            // Find the entity's index
            int index = Array.IndexOf(entityIds, entityId, 0, count);
            if (index == -1)
                return;

            // If it's not the last element, swap with the last one
            int lastIndex = count - 1;
            if (index < lastIndex)
            {
                foreach (var array in componentArrays.Values)
                {
                    Array.Copy(array, lastIndex, array, index, 1);
                }
                entityIds[index] = entityIds[lastIndex];
            }

            count--;
        }

        private void Grow()
        {
            int newCapacity = (int)(entityIds.Length * GROWTH_FACTOR);

            // Grow all component arrays
            foreach (var kvp in componentArrays.ToList())
            {
                var oldArray = kvp.Value;
                var newArray = Array.CreateInstance(kvp.Key.Type, newCapacity);
                Array.Copy(oldArray, 0, newArray, 0, count);
                componentArrays[kvp.Key] = newArray;
            }

            // Grow entity ID array
            Array.Resize(ref entityIds, newCapacity);
        }

        // And we need to add this method to ArchetypeStorage
        public Array GetComponentArrayRaw(ComponentType componentType)
        {
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {componentType.Type.Name} not found in archetype"
                );
            }
            return array;
        }

        // Properties for accessing storage information
        public int Count => count;
        public ReadOnlySpan<int> EntityIds => new ReadOnlySpan<int>(entityIds, 0, count);
    }
}

================
File: Core/ArchetypeStorage.cs.meta
================
fileFormatVersion: 2
guid: 785407d53c9c26746adb34ba3d74b58d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/ArchetypeSyncer.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public abstract class ArchetypeSyncer : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        protected ArchetypeStorage DedicatedStorage => World.GetStorage(Archetype);
        protected abstract Archetype Archetype { get; }

        public void SetWorld(World world)
        {
            World = world;
        }

        public virtual void Initialize() { }

        public virtual void Update(float deltaTime) { }

        public virtual void Cleanup() { }

        protected abstract void SyncEntityToView(int entityId, GameObject view);
    }
}

================
File: Core/ArchetypeSyncer.cs.meta
================
fileFormatVersion: 2
guid: 0df86895fba8144229e53825e79322a5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/ComponentType.cs
================
using System;
using System.Collections.Generic;

namespace ECS_MagicTile
{
    public readonly struct ComponentType
    {
        public readonly Type Type;
        public readonly int Id;

        // Private constructor ensures all types are created through registry
        private ComponentType(Type type, int id)
        {
            Type = type;
            Id = id;
        }

        // Static registry of all component types in our game
        public static class Registry
        {
            // Core Components
            public static readonly ComponentType Transform = new(typeof(TransformComponent), 0);
            public static readonly ComponentType MusicNote = new(typeof(MusicNoteComponent), 1);

            public static readonly ComponentType PerfectLine =
                new(typeof(PerfectLineTagComponent), 3);
            public static readonly ComponentType Corner = new(typeof(CornerComponent), 4);

            // A lookup dictionary to quickly find ComponentType by Type
            private static readonly Dictionary<Type, ComponentType> typeToComponentType;

            // Initialize our lookup dictionary when the class is first used
            static Registry()
            {
                typeToComponentType = new Dictionary<Type, ComponentType>
                {
                    { typeof(TransformComponent), Transform },
                    { typeof(MusicNoteComponent), MusicNote },
                    { typeof(PerfectLineTagComponent), PerfectLine },
                    { typeof(CornerComponent), Corner },
                };
            }

            // This is our new generic lookup method
            public static ComponentType GetComponentType<T>()
                where T : struct
            {
                var type = typeof(T);
                if (!typeToComponentType.TryGetValue(type, out var componentType))
                {
                    throw new InvalidOperationException(
                        $"Component type {type.Name} is not registered. "
                            + "Make sure to add it to the ComponentType.Registry."
                    );
                }
                return componentType;
            }

            // The existing methods remain the same
            public static ReadOnlySpan<ComponentType> GetAllTypes() => AllTypes;

            private static readonly ComponentType[] AllTypes =
            {
                Transform,
                MusicNote,
                PerfectLine,
                Corner,
            };
        }
    }
}

================
File: Core/ComponentType.cs.meta
================
fileFormatVersion: 2
guid: 07d3246996a8eeb4ba2c5e2e4d0939c9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/EntityViewFactory.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EntityViewFactory
{
    private readonly Dictionary<int, GameObject> entityViews = new();
    private readonly GameObject prefabSource;
    private readonly Transform viewRoot;

    public EntityViewFactory(GameObject prefabSource, Transform viewRoot)
    {
        this.prefabSource = prefabSource;
        this.viewRoot = viewRoot;
    }

    public GameObject GetOrCreateView(int entityId, string nameOnCreation = "")
    {
        if (entityViews.TryGetValue(entityId, out var existing))
        {
            return existing;
        }

        var prefab = prefabSource;

        var view = GameObject.Instantiate(prefab, viewRoot);
        view.name = $"{entityId}_{nameOnCreation}";
        entityViews[entityId] = view;
        return view;
    }

    public GameObject GetView(int entityId)
    {
        return entityViews.TryGetValue(entityId, out var view) ? view : null;
    }
}

================
File: Core/EntityViewFactory.cs.meta
================
fileFormatVersion: 2
guid: f36c2cdebdbc74a8db63bff96d758abd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/GlobalPoint.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public class GlobalPoint : MonoBehaviour
    {
        [Header("Game Settings")]
        [SerializeField]
        private GeneralGameSetting generalGameSetting;

        [SerializeField]
        private MusicNoteCreationSetting musicNoteCreationSettings;

        [SerializeField]
        private PerfectLineSettingSO perfectLineSettingSO;

        private World world;

        private void Awake()
        {
            // Initialize our ECS world
            world = new World();

            CreateSingletonComponent();

            SystemRegistry.Initialize(world);
            RegisterSystems();
        }

        private void RegisterSystems()
        {
            SystemRegistry.AddSystem(
                new MusicNoteCreationSystem_(musicNoteCreationSettings, generalGameSetting)
            );

            SystemRegistry.AddSystem(new MovingNoteSystem(generalGameSetting));

            //Syncer systems
            SystemRegistry.AddSystem(
                new MusicNoteSyncer(
                    musicNoteCreationSettings.ShortTilePrefab,
                    musicNoteCreationSettings.LongTilePrefab,
                    transform
                )
            );
        }

        private void CreateSingletonComponent()
        {
            var components = new object[] { new PerfectLineTagComponent(), new CornerComponent() };
            world.CreateEntityWithComponents(Archetype.Registry.PerfectLine, components);

            ArchetypeStorage perfectLineStorage = world.GetStorage(Archetype.Registry.PerfectLine);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            ref CornerComponent perfectLineCorner =
                ref perfectLineStorage.GetComponents<CornerComponent>()[0];

            PerfectLine.PerfectLineWidth = perfectLineSettingSO.PerfectLineWidth();
            perfectLineCorner.TopLeft = perfectLineSettingSO.TopLeft;
            perfectLineCorner.TopRight = perfectLineSettingSO.TopRight;
            perfectLineCorner.BottomLeft = perfectLineSettingSO.BottomLeft;
            perfectLineCorner.BottomRight = perfectLineSettingSO.BottomRight;
        }

        private void Update()
        {
            // Update all systems with current frame's delta time
            SystemRegistry.Update(Time.deltaTime);
        }
    }
}

================
File: Core/GlobalPoint.cs.meta
================
fileFormatVersion: 2
guid: a3234adf86578d14ca74bc8cc99f7901
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/IComponent.cs
================
namespace ECS_MagicTile
{
    public interface IComponent { }
}

================
File: Core/IComponent.cs.meta
================
fileFormatVersion: 2
guid: 5bfc30fb61b4b4792b8875b3f63c5a3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/StorageManager.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Manages all archetype storages in our game
    public class StorageManager
    {
        // Maps archetype hashes to their storage
        private readonly Dictionary<int, ArchetypeStorage> storages;
        private readonly Dictionary<int, List<ArchetypeStorage>> aspectStorages;

        public StorageManager()
        {
            storages = new Dictionary<int, ArchetypeStorage>();
            aspectStorages = new Dictionary<int, List<ArchetypeStorage>>();

            // First, create regular storages
            foreach (var archetype in Archetype.Registry.GetAllArchetypes())
            {
                if (!IsAspectArchetype(archetype))
                {
                    storages[archetype.GetHash()] = new ArchetypeStorage(archetype);
                }

                if (IsAspectArchetype(archetype))
                {
                    // Find all archetypes that contain these components
                    var matchingStorages = FindMatchingStorages(archetype);
                    aspectStorages[archetype.GetHash()] = matchingStorages;
                }
            }
        }

        private bool IsAspectArchetype(Archetype archetype)
        {
            // You could mark aspect archetypes explicitly, or use a naming convention,
            // or determine based on component count
            return archetype.IsAspect;
        }

        private List<ArchetypeStorage> FindMatchingStorages(Archetype aspectArchetype)
        {
            var matchingStorages = new List<ArchetypeStorage>();
            var requiredComponents = aspectArchetype.GetTypes();

            foreach (var storage in storages.Values)
            {
                // Check if this storage's archetype contains all required components
                bool matches = true;
                foreach (var component in requiredComponents)
                {
                    if (!HasComponent(storage, component))
                    {
                        matches = false;
                        break;
                    }
                }

                if (matches)
                {
                    matchingStorages.Add(storage);
                }
            }

            return matchingStorages;
        }

        // Get storage for a specific archetype
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            if (!storages.TryGetValue(archetype.GetHash(), out var storage))
            {
                throw new InvalidOperationException($"No storage found for archetype {archetype}");
            }
            return storage;
        }

        public IEnumerable<ArchetypeStorage> GetStoragesForAspect(Archetype aspectArchetype)
        {
            if (aspectStorages.TryGetValue(aspectArchetype.GetHash(), out var storageList))
            {
                return storageList;
            }
            return Array.Empty<ArchetypeStorage>();
        }

        private bool HasComponent(ArchetypeStorage storage, ComponentType componentType)
        {
            try
            {
                // We try to get the component array - if it exists, the storage has this component
                Array componentArray = storage.GetComponentArrayRaw(componentType);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}

================
File: Core/StorageManager.cs.meta
================
fileFormatVersion: 2
guid: 6e34b51edd65cc54298a958d1e7db250
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/SystemRegistry.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public interface IGameSystem
    {
        void SetWorld(World world);
        void Initialize(); // Called when system is first created
        void Update(float deltaTime); // Called every frame
        void Cleanup();
        bool IsEnabled { get; set; } // Controls if system should be updated
        World World { get; set; }
    }

    // Our central system management class
    public static class SystemRegistry
    {
        // Interface that all our game systems will implement


        // Store systems in order of execution priority
        private static readonly List<IGameSystem> updateSystems = new();
        private static World world;
        private static bool isInitialized;

        // Initialize our registry with a world reference
        public static void Initialize(World gameWorld)
        {
            // Prevent multiple initializations
            if (isInitialized)
            {
                Debug.LogWarning("SystemRegistry already initialized!");
                return;
            }

            world = gameWorld;
            isInitialized = true;
        }

        // Allow adding systems from GlobalPoint
        public static void AddSystem(IGameSystem system)
        {
            if (!isInitialized)
            {
                Debug.LogError("SystemRegistry not initialized! Call Initialize first.");
                return;
            }

            // Provide the system with world reference and initialize it
            system.SetWorld(world);
            system.Initialize();

            updateSystems.Add(system);

            Debug.Log($"Added system: {system.GetType().Name}");
        }

        public static void Update(float deltaTime)
        {
            if (!isInitialized)
                return;

            foreach (var system in updateSystems)
            {
                if (system.IsEnabled)
                {
                    try
                    {
                        system.Update(deltaTime);
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error in system {system.GetType().Name}: {e}");
                    }
                }
            }
        }

        public static void Cleanup()
        {
            foreach (var system in updateSystems)
            {
                system.Cleanup();
            }

            updateSystems.Clear();
            isInitialized = false;
            world = null;
        }
    }
}

================
File: Core/SystemRegistry.cs.meta
================
fileFormatVersion: 2
guid: ae3ac3479b706d64f83a41cf766e7021
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/World.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    public class World
    {
        private readonly StorageManager storageManager;
        private int nextEntityId = 1000; // Starting from 1000 to leave room for special IDs

        public World()
        {
            storageManager = new StorageManager();
        }

        // Creates an entity of a specific archetype
        private int CreateEntity()
        {
            int entityId = nextEntityId++;
            return entityId;
        }

        // Gets a specific storage for systems to use
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            return storageManager.GetStorage(archetype);
        }

        // Helper method to create and set up an entity in one go
        public int CreateEntityWithComponents(Archetype archetype, ReadOnlySpan<object> components)
        {
            int entityId = CreateEntity();
            ArchetypeStorage storage = GetStorage(archetype);
            storage.Add(entityId, components);
            return entityId;
        }
    }
}

================
File: Core/World.cs.meta
================
fileFormatVersion: 2
guid: 1df84a3b9711fcb41b790ef98664b125
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent/CornerComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

public struct CornerComponent : IComponent
{
    public Vector2 TopLeft;
    public Vector2 TopRight;
    public Vector2 BottomLeft;
    public Vector2 BottomRight;
}

================
File: DataComponent/CornerComponent.cs.meta
================
fileFormatVersion: 2
guid: b96e4a6c6cb604761b6ec117819be5b4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent/LongNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

public struct LongNoteTagComponent : IComponent { }

================
File: DataComponent/LongNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 58353002a3593244d8bf12e61f349c98
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent/MusicNoteComponent.cs
================
using ECS_MagicTile;

public struct MusicNoteComponent : IComponent
{
    public int PostionId;
    public float TimeAppear;
    public float Duration;
    public MusicNoteType musicNoteType;
}

================
File: DataComponent/MusicNoteComponent.cs.meta
================
fileFormatVersion: 2
guid: e13eda0f52da940ceaec30f721998b78
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent/PerfectLineTagComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

public struct PerfectLineTagComponent : IComponent
{
    public float PerfectLineWidth;
}

================
File: DataComponent/PerfectLineTagComponent.cs.meta
================
fileFormatVersion: 2
guid: e18089c9ed33d49f8b76960358f6a4d2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent/ShortNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

public struct ShortNoteTagComponent : IComponent { }

================
File: DataComponent/ShortNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 83c9ef9fdf039c843b9556bfba72a05a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent/TransformComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

public struct TransformComponent : IComponent
{
    public Vector2 Posision;
    public Vector2 Size;
}

================
File: DataComponent/TransformComponent.cs.meta
================
fileFormatVersion: 2
guid: ff2e94255bc1f499a986a60df04d62ec
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncer/MusicNoteSyncer.cs
================
using System;
using System.Collections;
using System.Collections.Generic;
using NUnit.Framework.Constraints;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteSyncer : ArchetypeSyncer
    {
        protected override Archetype Archetype => Archetype.Registry.MusicNote;

        private readonly EntityViewFactory shortNoteViewFactory;
        private readonly EntityViewFactory longNoteViewFactory;

        public MusicNoteSyncer(
            GameObject shortNotePrefab,
            GameObject longNotePrefab,
            Transform root = null
        )
        {
            shortNoteViewFactory = new EntityViewFactory(shortNotePrefab, root);
            longNoteViewFactory = new EntityViewFactory(longNotePrefab, root);
        }

        public override void Initialize()
        {
            base.Initialize();
            IsEnabled = true;
        }

        public override void Update(float deltaTime)
        {
            base.Update(deltaTime);
            MusicNoteComponent[] notes = DedicatedStorage.GetComponents<MusicNoteComponent>();

            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];
                GameObject view;
                if (notes[i].musicNoteType == MusicNoteType.LongNote)
                {
                    view = longNoteViewFactory.GetOrCreateView(entityId, "longNote");
                }
                else
                {
                    view = shortNoteViewFactory.GetOrCreateView(entityId, "shortNote");
                }

                SyncEntityToView(entityId, view);
            }
        }

        protected override void SyncEntityToView(int entityId, GameObject view)
        {
            TransformComponent[] transforms = DedicatedStorage.GetComponents<TransformComponent>();
            int index = Array.IndexOf(DedicatedStorage.EntityIds.ToArray(), entityId);

            if (index != -1)
            {
                view.transform.position = transforms[index].Posision;
                view.transform.localScale = transforms[index].Size;
                // Sync other visual properties specific to MusicNote
            }
        }
    }
}

================
File: Syncer/MusicNoteSyncer.cs.meta
================
fileFormatVersion: 2
guid: 541f4a77356ee45a381eacb214f2b6e2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: System/MovingNoteSystem.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MovingNoteSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        private readonly GeneralGameSetting generalGameSetting;

        public MovingNoteSystem(GeneralGameSetting generalGameSetting)
        {
            this.generalGameSetting = generalGameSetting;
        }

        public void Cleanup() { }

        public void Initialize() { }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            Vector2 newPos = Vector2.zero;

            float gameSpeed = generalGameSetting.GameSpeed;

            ArchetypeStorage musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            TransformComponent[] transforms = musicNoteStorage.GetComponents<TransformComponent>();

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                newPos.x = transforms[i].Posision.x;
                newPos.y = transforms[i].Posision.y - gameSpeed * Time.deltaTime;

                transforms[i].Posision = newPos;
            }
        }
    }
}

================
File: System/MovingNoteSystem.cs.meta
================
fileFormatVersion: 2
guid: 23e31434417084f63bbc9efc34471f1f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: System/MusicNoteCreationSystem_.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteCreationSystem_ : IGameSystem
    {
        private MusicNoteCreationSetting musicNoteCreationSetting;
        private GeneralGameSetting generalGameSetting;
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public MusicNoteCreationSystem_(
            MusicNoteCreationSetting musicNoteCreationSetting,
            GeneralGameSetting generalGameSetting
        )
        {
            this.musicNoteCreationSetting = musicNoteCreationSetting;
            this.generalGameSetting = generalGameSetting;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            MusicNoteMidiData musicNoteMidiData = MidiNoteParser.ParseFromText(
                musicNoteCreationSetting.MidiContent.text
            );

            ArchetypeStorage perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            ref CornerComponent perfectLineCorners =
                ref perfectLineStorage.GetComponents<CornerComponent>()[0];

            // Calculate lane width once
            float totalWidth = perfectLineCorners.TopRight.x - perfectLineCorners.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            for (int i = 0; i < musicNoteMidiData.TotalNotes; i++)
            {
                MusicNoteType musicNoteType = MusicNoteType.ShortNote;
                if (musicNoteMidiData.Durations[i] > musicNoteMidiData.MinDuration)
                {
                    musicNoteType = MusicNoteType.LongNote;
                }

                var components = new object[]
                {
                    new TransformComponent { },
                    new MusicNoteComponent
                    {
                        Duration = musicNoteMidiData.Durations[i],
                        PostionId = musicNoteMidiData.PositionIds[i],
                        TimeAppear = musicNoteMidiData.TimeAppears[i],
                        musicNoteType = musicNoteType,
                    },
                };

                World.CreateEntityWithComponents(Archetype.Registry.MusicNote, components);
            }

            ArchetypeStorage musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            TransformComponent[] transforms = musicNoteStorage.GetComponents<TransformComponent>();
            MusicNoteComponent[] musicNotes = musicNoteStorage.GetComponents<MusicNoteComponent>();

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                float spawnX =
                    perfectLineCorners.TopLeft.x
                    + (musicNoteMidiData.PositionIds[i] * laneWidth)
                    + halfLaneWidth;

                float spawnY =
                    perfectLineCorners.TopLeft.y
                    + (musicNoteMidiData.TimeAppears[i] * generalGameSetting.GameSpeed)
                    + transforms[i].Size.y / 2f;

                transforms[i].Posision = new Vector2(spawnX, spawnY);

                float scaleX = PerfectLine.PerfectLineWidth / 4;

                float scaleY;

                if (musicNotes[i].musicNoteType == MusicNoteType.ShortNote)
                {
                    scaleY = MagicTileHelper.CalculateScaleY(
                        musicNoteCreationSetting.ShortNoteScaleYFactor,
                        scaleX
                    );
                }
                else
                {
                    scaleY = MagicTileHelper.CalculateScaleY(
                        musicNoteCreationSetting.LongNoteScaleYFactor,
                        scaleX,
                        musicNotes[i].Duration
                    );
                }

                transforms[i].Size = new Vector2(scaleX, scaleY);
            }
        }

        public void Update(float deltaTime)
        {
            //
        }

        public void Cleanup()
        {
            //
        }
    }
}

================
File: System/MusicNoteCreationSystem_.cs.meta
================
fileFormatVersion: 2
guid: 27223b00486847b4b86f21b0b74f2e53
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core.meta
================
fileFormatVersion: 2
guid: b57c2d5fbb39b489e9c51a111e5e8e4f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent.meta
================
fileFormatVersion: 2
guid: 401cb534838cf40049f69183b5206b9c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncer.meta
================
fileFormatVersion: 2
guid: 200d0ba3dc7c04ac6920253abe6c74a4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: System.meta
================
fileFormatVersion: 2
guid: c822eec9dba9f4d4b88020ce8c3090ef
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
