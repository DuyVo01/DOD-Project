This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-31T08:04:58.021Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
DataComponent/
  CornerComponent.cs
  CornerComponent.cs.meta
  LongNoteTagComponent.cs
  LongNoteTagComponent.cs.meta
  MusicNoteComponent.cs
  MusicNoteComponent.cs.meta
  PerfectLineTagComponent.cs
  PerfectLineTagComponent.cs.meta
  ShortNoteTagComponent.cs
  ShortNoteTagComponent.cs.meta
  TransformComponent.cs
  TransformComponent.cs.meta
DTO/
  MusicNoteMidiData.cs
  MusicNoteMidiData.cs.meta
ECS_Core/
  Mock/
    MockComponentData.cs
    MockComponentData.cs.meta
    MockDebugSystem.cs
    MockDebugSystem.cs.meta
  Archetype.cs
  Archetype.cs.meta
  ArchetypeManager.cs
  ArchetypeManager.cs.meta
  ComponentType.cs
  ComponentType.cs.meta
  IComponent.cs
  IComponent.cs.meta
  Mock.meta
  QueryCache.cs
  QueryCache.cs.meta
  QueryDescription.cs
  QueryDescription.cs.meta
  repomix-output.txt
  repomix-output.txt.meta
  SingletonCache.cs
  SingletonCache.cs.meta
  SparseSet.cs
  SparseSet.cs.meta
  StructuralChangeVersion.cs
  StructuralChangeVersion.cs.meta
  SystemManager.cs
  SystemManager.cs.meta
  World.cs
  World.cs.meta
Systems/
  MusicNoteCreationSystem.cs
  MusicNoteCreationSystem.cs.meta
DataComponent.meta
DTO.meta
ECS_Core.meta
GlobalPoint.cs
GlobalPoint.cs.meta
MidiNoteParser.cs
MidiNoteParser.cs.meta
PrefabSourceSO.cs
PrefabSourceSO.cs.meta
SceneObjectSpawner.cs
SceneObjectSpawner.cs.meta
Systems.meta

================================================================
Repository Files
================================================================

================
File: DataComponent/CornerComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_Core;
using UnityEngine;

public struct CornerComponent : IComponent
{
    public Vector2 TopLeft;
    public Vector2 TopRight;
    public Vector2 BottomLeft;
    public Vector2 BottomRight;
}

================
File: DataComponent/CornerComponent.cs.meta
================
fileFormatVersion: 2
guid: b96e4a6c6cb604761b6ec117819be5b4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent/LongNoteTagComponent.cs
================
using ECS_Core;
using UnityEngine;

public struct LongNoteTagComponent : IComponent { }

================
File: DataComponent/LongNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 58353002a3593244d8bf12e61f349c98
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent/MusicNoteComponent.cs
================
using ECS_Core;

public struct MusicNoteComponent : IComponent
{
    public int PostionId;
    public float TimeAppear;
    public float Duration;
}

================
File: DataComponent/MusicNoteComponent.cs.meta
================
fileFormatVersion: 2
guid: e13eda0f52da940ceaec30f721998b78
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent/PerfectLineTagComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_Core;
using UnityEngine;

public struct PerfectLineTagComponent : IComponent { }

================
File: DataComponent/PerfectLineTagComponent.cs.meta
================
fileFormatVersion: 2
guid: e18089c9ed33d49f8b76960358f6a4d2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent/ShortNoteTagComponent.cs
================
using ECS_Core;
using UnityEngine;

public struct ShortNoteTagComponent : IComponent { }

================
File: DataComponent/ShortNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 83c9ef9fdf039c843b9556bfba72a05a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent/TransformComponent.cs
================
using ECS_Core;
using UnityEngine;

public struct TransformComponent : IComponent
{
    public Vector2 Posision;
    public Vector2 Size;
}

================
File: DataComponent/TransformComponent.cs.meta
================
fileFormatVersion: 2
guid: ff2e94255bc1f499a986a60df04d62ec
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DTO/MusicNoteMidiData.cs
================
using UnityEngine;

public struct MusicNoteMidiData : IDataComponent
{
    // Core data arrays
    public int[] Ids;
    public int[] NoteNumbers;
    public int[] PositionIds;
    public float[] TimeAppears;
    public float[] Timespans;
    public float[] Durations;
    public float[] Velocities;

    // Metadata
    public int TotalNotes;
    public float MinDuration;

    public MusicNoteMidiData(int capacity)
    {
        // Preallocate arrays with specified capacity
        Ids = new int[capacity];
        NoteNumbers = new int[capacity];
        TimeAppears = new float[capacity];
        Timespans = new float[capacity];
        Durations = new float[capacity];
        Velocities = new float[capacity];
        PositionIds = new int[capacity];

        TotalNotes = 0;
        MinDuration = float.MaxValue;
    }
}

================
File: DTO/MusicNoteMidiData.cs.meta
================
fileFormatVersion: 2
guid: 0772d691d2fae418b83ddb22ddc64cc6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/Mock/MockComponentData.cs
================
using ECS_Core;
using UnityEngine;

public struct MockComponentData : IComponent
{
    public int Value;
}

================
File: ECS_Core/Mock/MockComponentData.cs.meta
================
fileFormatVersion: 2
guid: c445691cf3452bf4f84afb339d70c9a4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/Mock/MockDebugSystem.cs
================
using ECS_Core;
using UnityEngine;

public struct MockDebugSystem : ECS_Core.IGameSystem
{
    public bool AutoUpdate { get; set; }
    public ArchetypeManager ArchetypeManager { get; set; }

    public void Cleanup()
    {
        //
    }

    public void Initialize()
    {
        AutoUpdate = true;
    }

    public void Start()
    {
        //
    }

    public void Update() { }
}

================
File: ECS_Core/Mock/MockDebugSystem.cs.meta
================
fileFormatVersion: 2
guid: 07a7f8a2f4cb6de4793b923993ed50c8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/Archetype.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace ECS_Core
{
    public class Archetype
    {
        private const int DEFAULT_INITIAL_CAPACITY = 16;
        private readonly HashSet<ComponentType> componentTypes = new();
        private readonly Dictionary<ComponentType, SparseSet<object>> componentSets = new();
        private readonly List<int> entities = new();
        private readonly Dictionary<int, int> entityToIndex = new();
        private int count = 0;

        public Archetype(ComponentType[] types)
        {
            foreach (var type in types)
            {
                componentTypes.Add(type);
                componentSets[type] = new SparseSet<object>(DEFAULT_INITIAL_CAPACITY);
            }
        }

        public bool HasComponent(ComponentType type) => componentTypes.Contains(type);

        public void Add(int entityId, Dictionary<ComponentType, object> components)
        {
            // For each component type and value pair
            foreach (var kvp in components)
            {
                if (componentSets.TryGetValue(kvp.Key, out var sparseSet))
                {
                    // Add directly to sparse set
                    sparseSet.Add(entityId, kvp.Value);
                }
            }

            // Keep your existing entity tracking
            entities.Add(entityId);
            entityToIndex[entityId] = count;
            count++;
        }

        public T[] GetComponentArray<T>()
            where T : struct, IComponent
        {
            var type = ComponentType.Of<T>();
            if (!componentSets.TryGetValue(type, out var sparseSet))
            {
                throw new ArgumentException($"Component type {typeof(T)} not found in archetype");
            }

            var span = sparseSet.GetDataSpan();
            var result = new T[span.Length];
            for (int i = 0; i < span.Length; i++)
            {
                result[i] = (T)span[i];
            }
            return result;
        }

        public void RemoveEntity(int entityId)
        {
            foreach (var sparseSet in componentSets.Values)
            {
                sparseSet.Remove(entityId);
            }

            entities.Remove(entityId);
            entityToIndex.Remove(entityId);
            count--;
        }

        public bool HasEntity(int entityId)
        {
            var firstSet = componentSets.Values.GetEnumerator().Current;
            return firstSet?.Contains(entityId) ?? false;
        }

        public int Count => count;
        public IReadOnlyList<int> Entities => entities;

        public IEnumerable<ComponentType> ComponentTypes => componentTypes;

        public Array GetComponentArrayRaw(ComponentType type)
        {
            if (!componentSets.TryGetValue(type, out var sparseSet))
                throw new ArgumentException(
                    $"ComponentType {type.Type.Name} not found in archetype."
                );

            // Convert to array for compatibility
            var span = sparseSet.GetDataSpan();
            var array = Array.CreateInstance(type.Type, span.Length);
            for (int i = 0; i < span.Length; i++)
            {
                array.SetValue(span[i], i);
            }
            return array;
        }

        public int GetEntityIndex(int entityId)
        {
            if (!entityToIndex.TryGetValue(entityId, out var index))
                throw new ArgumentException($"Entity {entityId} not found in archetype.");

            return index;
        }

        // Get all entities in this archetype
        public ReadOnlySpan<int> GetEntities()
        {
            // Since we're using SparseSet, we can get the dense array of entities
            // from any component set (they all track the same entities)
            SparseSet<object> firstSet = componentSets.Values.FirstOrDefault();
            if (firstSet != null)
            {
                return firstSet.GetEntityIds();
            }

            // Fallback to empty span if no components (shouldn't happen in practice)
            return ReadOnlySpan<int>.Empty;
        }

        // For compatibility with existing code that expects IReadOnlyList
    }
}

================
File: ECS_Core/Archetype.cs.meta
================
fileFormatVersion: 2
guid: b4381e7b77d7446289e01f3738e6d8dc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/ArchetypeManager.cs
================
using System.Collections.Generic;
using System.Linq;

namespace ECS_Core
{
    public class ArchetypeManager
    {
        private readonly Dictionary<int, Archetype> archetypes = new();
        private readonly World world;

        public ArchetypeManager(World world)
        {
            this.world = world;
        }

        public Archetype GetOrCreateArchetype(ComponentType[] types)
        {
            int hash = CalculateArchetypeHash(types);
            if (!archetypes.TryGetValue(hash, out var archetype))
            {
                archetype = new Archetype(types);
                archetypes[hash] = archetype;
                // Notify world that a new archetype was created
                world.GetQueryCache(types); // This will create a cache entry for the new archetype
            }

            return archetype;
        }

        public IEnumerable<Archetype> GetArchetypesWithComponents(ComponentType[] types)
        {
            foreach (var archetype in archetypes.Values)
            {
                if (DoesArchetypeMatchQuery(archetype, types))
                {
                    yield return archetype;
                }
            }
        }

        private static bool DoesArchetypeMatchQuery(Archetype archetype, ComponentType[] queryTypes)
        {
            foreach (var queryType in queryTypes)
            {
                if (!archetype.HasComponent(queryType))
                {
                    return false;
                }
            }
            return true;
        }

        private static int CalculateArchetypeHash(ComponentType[] types)
        {
            int hash = 17;
            foreach (var type in types.OrderBy(t => t.Id))
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        public void CleanupEmptyArchetypes()
        {
            var emptyArchetypes = archetypes
                .Where(kvp => kvp.Value.Count == 0)
                .Select(kvp => kvp.Key)
                .ToList();

            if (emptyArchetypes.Count > 0)
            {
                foreach (var hash in emptyArchetypes)
                {
                    archetypes.Remove(hash);
                }
            }
        }
    }
}

================
File: ECS_Core/ArchetypeManager.cs.meta
================
fileFormatVersion: 2
guid: 5358525b5829c452d9abb4891f4431ba
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/ComponentType.cs
================
using System;
using System.Collections.Generic;

namespace ECS_Core
{
    public struct ComponentType
    {
        public readonly Type Type;
        public readonly int Id;
        private static int NextId = 0;
        private static Dictionary<Type, ComponentType> typeRegistry = new();

        private ComponentType(Type type)
        {
            Type = type;
            Id = NextId++;
        }

        public static ComponentType Of<T>()
            where T : struct, IComponent
        {
            var type = typeof(T);
            if (!typeRegistry.ContainsKey(type))
            {
                typeRegistry[type] = new ComponentType(type);
            }

            return typeRegistry[type];
        }
    }
}

================
File: ECS_Core/ComponentType.cs.meta
================
fileFormatVersion: 2
guid: 2e3cff646cf254dee8948a45e56ad066
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/IComponent.cs
================
namespace ECS_Core
{
    public interface IComponent { }
}

================
File: ECS_Core/IComponent.cs.meta
================
fileFormatVersion: 2
guid: 5bfc30fb61b4b4792b8875b3f63c5a3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/Mock.meta
================
fileFormatVersion: 2
guid: 5ca9bd3fd7f2d6f4dbea65f7c213d993
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/QueryCache.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_Core
{
    // Stores cached data for a specific archetype in a query
    public class QueryArchetypeCache
    {
        public Archetype Archetype { get; }
        public Array[] ComponentArrays { get; private set; }
        public IReadOnlyList<int> Entities => Archetype.Entities;
        public int Count => Archetype.Count;
        private readonly ComponentType[] queryTypes;
        private readonly int[] componentIndices;

        public QueryArchetypeCache(Archetype archetype, ComponentType[] types)
        {
            Archetype = archetype;
            queryTypes = types;
            componentIndices = new int[types.Length];
            ComponentArrays = new Array[types.Length];
            UpdateArrays();

            // Precalculate component indices for faster access
            for (int i = 0; i < types.Length; i++)
            {
                componentIndices[i] = Array.IndexOf(archetype.ComponentTypes.ToArray(), types[i]);
            }
        }

        public void UpdateArrays()
        {
            for (int i = 0; i < queryTypes.Length; i++)
            {
                ComponentArrays[i] = Archetype.GetComponentArrayRaw(queryTypes[i]);
            }
        }

        public ReadOnlySpan<T> GetComponents<T>()
            where T : struct, IComponent
        {
            var type = ComponentType.Of<T>();
            int index = Array.IndexOf(queryTypes, type);
            if (index < 0)
                throw new ArgumentException($"Type {typeof(T)} not in query");

            return Archetype.GetComponentArray<T>();
        }

        public ReadOnlySpan<int> GetEntities() => Archetype.GetEntities();
    }

    // Main cache for a specific query type combination
    public class QueryCache
    {
        private readonly ComponentType[] queryTypes;
        private readonly List<QueryArchetypeCache> archetypeCaches = new();
        private readonly World world;
        private QueryVersionInfo versionInfo;
        public bool IsDirty { get; set; } = true;
        public uint lastProcessedVersion
        {
            get => versionInfo.lastProcessedVersion;
            set => versionInfo.lastProcessedVersion = value;
        }

        public ComponentType[] QueryTypes => queryTypes;

        public QueryCache(World world, ComponentType[] types)
        {
            this.world = world;
            this.queryTypes = types;
        }

        public IReadOnlyList<QueryArchetypeCache> GetArchetypeCaches()
        {
            var worldVersion = world.GetStructuralVersion();
            if (versionInfo.IsValid(worldVersion))
            {
                UpdateCache(worldVersion);
            }

            return archetypeCaches;
        }

        private void UpdateCache(in StructuralChangeVersion worldVersion)
        {
            archetypeCaches.Clear();
            var matchingArchetypes = world.ArchetypeManager.GetArchetypesWithComponents(queryTypes);

            foreach (var archetype in matchingArchetypes)
            {
                if (archetype.Count > 0)
                {
                    archetypeCaches.Add(new QueryArchetypeCache(archetype, queryTypes));
                }
            }

            // Update version info
            versionInfo.lastProcessedVersion = worldVersion.GlobalVersion;
            versionInfo.lastUpdatedFrame = worldVersion.FrameNumber;
        }
    }

    // Cache manager to store and retrieve query caches
    public class QueryCacheManager
    {
        private readonly Dictionary<int, QueryCache> queryCaches = new();
        private readonly ArchetypeManager archetypeManager;
        private readonly World world;

        public QueryCacheManager(World world, ArchetypeManager archetypeManager)
        {
            this.world = world;
            this.archetypeManager = archetypeManager;
        }

        public QueryCache GetOrCreateCache(ComponentType[] types)
        {
            int hash = CalculateQueryHash(types);

            if (!queryCaches.TryGetValue(hash, out var cache))
            {
                cache = new QueryCache(world, types);
                queryCaches[hash] = cache;
            }

            return cache;
        }

        private int CalculateQueryHash(ComponentType[] types)
        {
            int hash = 17;
            foreach (var type in types.OrderBy(t => t.Id))
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        public void MarkAllDirty()
        {
            foreach (var cache in queryCaches.Values)
            {
                cache.IsDirty = true;
            }
        }
    }

    // Helper extension for QueryCache
    public static class QueryCacheExtensions
    {
        public static void MarkDirty(this QueryCache cache)
        {
            // Forces the cache to update on next use
            cache.lastProcessedVersion = 0;
        }

        public static bool UsesComponent(this QueryCache cache, ComponentType type)
        {
            return cache.QueryTypes.Contains(type);
        }
    }
}

================
File: ECS_Core/QueryCache.cs.meta
================
fileFormatVersion: 2
guid: 5c1ab0718029c7e43b756e76e9aa74a3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/QueryDescription.cs
================
namespace ECS_Core
{
    public delegate void ActionRef<T1>(ref T1 item);
    public delegate void ActionRef<T1, T2>(T1 index, ref T2 item);
    public delegate void ActionRef<T1, T2, T3>(T1 index, ref T2 item1, ref T3 item2);
    public delegate void ActionRef<T1, T2, T3, T4>(
        T1 index,
        ref T2 item1,
        ref T3 item2,
        ref T4 item3
    );
    public delegate void ActionRef<T1, T2, T3, T4, T5>(
        T1 index,
        ref T2 item1,
        ref T3 item2,
        ref T4 item3,
        ref T5 item4
    );

    public readonly struct QueryDescription<T1>
        where T1 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[] { ComponentType.Of<T1>() };

        public void ForEach(World world, ActionRef<int, T1> action)
        {
            var cache = world.GetQueryCache(componentTypes);
            var archetypeCaches = cache.GetArchetypeCaches();

            foreach (var archetypeCache in archetypeCaches)
            {
                var components1 = (T1[])archetypeCache.ComponentArrays[0];
                var entities = archetypeCache.Entities;

                for (int i = 0; i < archetypeCache.Count; i++)
                {
                    action(entities[i], ref components1[i]);
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
        };

        public void ForEach(World world, ActionRef<int, T1, T2> action)
        {
            var cache = world.GetQueryCache(componentTypes);
            var archetypeCaches = cache.GetArchetypeCaches();

            foreach (var archetypeCache in archetypeCaches)
            {
                var components1 = (T1[])archetypeCache.ComponentArrays[0];
                var components2 = (T2[])archetypeCache.ComponentArrays[1];
                var entities = archetypeCache.Entities;

                for (int i = 0; i < archetypeCache.Count; i++)
                {
                    action(entities[i], ref components1[i], ref components2[i]);
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2, T3>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
        where T3 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
            ComponentType.Of<T3>(),
        };

        public void ForEach(World world, ActionRef<int, T1, T2, T3> action)
        {
            var cache = world.GetQueryCache(componentTypes);
            var archetypeCaches = cache.GetArchetypeCaches();

            foreach (var archetypeCache in archetypeCaches)
            {
                var components1 = (T1[])archetypeCache.ComponentArrays[0];
                var components2 = (T2[])archetypeCache.ComponentArrays[1];
                var components3 = (T3[])archetypeCache.ComponentArrays[2];
                var entities = archetypeCache.Entities;

                for (int i = 0; i < archetypeCache.Count; i++)
                {
                    action(entities[i], ref components1[i], ref components2[i], ref components3[i]);
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2, T3, T4>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
        where T3 : struct, IComponent
        where T4 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
            ComponentType.Of<T3>(),
            ComponentType.Of<T4>(),
        };

        public void ForEach(World world, ActionRef<int, T1, T2, T3, T4> action)
        {
            var cache = world.GetQueryCache(componentTypes);
            var archetypeCaches = cache.GetArchetypeCaches();

            foreach (var archetypeCache in archetypeCaches)
            {
                var component1Array = (T1[])archetypeCache.ComponentArrays[0];
                var component2Array = (T2[])archetypeCache.ComponentArrays[1];
                var component3Array = (T3[])archetypeCache.ComponentArrays[2];
                var component4Array = (T4[])archetypeCache.ComponentArrays[3];
                var entities = archetypeCache.Entities;

                for (int i = 0; i < archetypeCache.Count; i++)
                {
                    action(
                        entities[i],
                        ref component1Array[i],
                        ref component2Array[i],
                        ref component3Array[i],
                        ref component4Array[i]
                    );
                }
            }
        }
    }
}

================
File: ECS_Core/QueryDescription.cs.meta
================
fileFormatVersion: 2
guid: 88b70e4e0660742a3aef862f0ee483f7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-30T11:21:52.889Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
Mock/
  MockComponentData.cs
  MockComponentData.cs.meta
  MockDebugSystem.cs
  MockDebugSystem.cs.meta
Archetype.cs
Archetype.cs.meta
ArchetypeManager.cs
ArchetypeManager.cs.meta
ComponentType.cs
ComponentType.cs.meta
IComponent.cs
IComponent.cs.meta
Mock.meta
QueryCache.cs
QueryCache.cs.meta
QueryDescription.cs
QueryDescription.cs.meta
SingletonCache.cs
SingletonCache.cs.meta
SystemManager.cs
SystemManager.cs.meta
World.cs
World.cs.meta

================================================================
Repository Files
================================================================

================
File: Mock/MockComponentData.cs
================
using ECS_Core;
using UnityEngine;

public struct MockComponentData : IComponent
{
    public int Value;
}

================
File: Mock/MockComponentData.cs.meta
================
fileFormatVersion: 2
guid: c445691cf3452bf4f84afb339d70c9a4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Mock/MockDebugSystem.cs
================
using ECS_Core;
using UnityEngine;

public struct MockDebugSystem : ECS_Core.IGameSystem
{
    public bool AutoUpdate { get; set; }
    public ArchetypeManager ArchetypeManager { get; set; }

    public void Cleanup()
    {
        //
    }

    public void Initialize()
    {
        AutoUpdate = true;
    }

    public void Start()
    {
        //
    }

    public void Update() { }
}

================
File: Mock/MockDebugSystem.cs.meta
================
fileFormatVersion: 2
guid: 07a7f8a2f4cb6de4793b923993ed50c8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Archetype.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace ECS_Core
{
    public class Archetype
    {
        private const int DEFAULT_INITIAL_CAPACITY = 16;
        private const float GROWTH_FACTOR = 2.0f;
        private readonly HashSet<ComponentType> componentTypes = new();
        private readonly Dictionary<ComponentType, Array> componentArrays = new();
        private readonly List<int> entities = new();
        private readonly Dictionary<int, int> entityToIndex = new();
        private int count = 0;

        public Archetype(ComponentType[] types)
        {
            foreach (var type in types)
            {
                componentTypes.Add(type);
                componentArrays[type] = Array.CreateInstance(type.Type, DEFAULT_INITIAL_CAPACITY); // Initial capacity
            }
        }

        public bool HasComponent(ComponentType type) => componentTypes.Contains(type);

        public T[] GetComponentArray<T>()
            where T : struct, IComponent
        {
            var type = ComponentType.Of<T>();
            return (T[])componentArrays[type];
        }

        public void Add(int entityId, Dictionary<ComponentType, object> components)
        {
            if (count == componentArrays.First().Value.Length)
            {
                Grow();
            }

            entityToIndex[entityId] = count;
            entities.Add(entityId);

            foreach (var kvp in components)
            {
                var array = componentArrays[kvp.Key];
                Array.Copy(new[] { kvp.Value }, 0, array, count, 1);
            }

            count++;
        }

        // New overload for when components are already copied
        public void AddWithoutComponents(int entityId)
        {
            if (count == componentArrays.First().Value.Length)
            {
                Grow();
            }

            entityToIndex[entityId] = count;
            entities.Add(entityId);
            count++;
        }

        public void RemoveEntity(int entityId)
        {
            if (!entityToIndex.TryGetValue(entityId, out int indexToRemove))
                return;

            int lastIndex = count - 1;
            if (indexToRemove < lastIndex)
            {
                int lastEntityId = entities[lastIndex];

                foreach (var componentArray in componentArrays.Values)
                {
                    Array.Copy(componentArray, lastIndex, componentArray, indexToRemove, 1);
                }

                entityToIndex[lastEntityId] = indexToRemove;
                entities[indexToRemove] = lastEntityId;
            }

            entityToIndex.Remove(entityId);
            entities.RemoveAt(count - 1);
            count--;
        }

        private void Grow()
        {
            var newCapacity = (int)(componentArrays.First().Value.Length * GROWTH_FACTOR);
            foreach (var type in componentArrays.Keys.ToList())
            {
                var oldArray = componentArrays[type];
                var newArray = Array.CreateInstance(type.Type, newCapacity);

                // Use Array.Copy instead of Buffer.BlockCopy
                // This properly handles copying of value types (structs)
                Array.Copy(oldArray, 0, newArray, 0, count);

                componentArrays[type] = newArray;
            }
        }

        public bool HasEntity(int entityId) => entityToIndex.ContainsKey(entityId);

        public int Count => count;
        public IReadOnlyList<int> Entities => entities;

        public IEnumerable<ComponentType> ComponentTypes => componentTypes;

        public Array GetComponentArrayRaw(ComponentType type)
        {
            if (!componentArrays.TryGetValue(type, out var array))
                throw new ArgumentException(
                    $"ComponentType {type.Type.Name} not found in archetype."
                );

            return array;
        }

        public int GetEntityIndex(int entityId)
        {
            if (!entityToIndex.TryGetValue(entityId, out var index))
                throw new ArgumentException($"Entity {entityId} not found in archetype.");

            return index;
        }

        public void TransferEntityComponents(
            int entityId,
            Archetype targetArchetype,
            HashSet<ComponentType> componentTypesToTransfer
        )
        {
            // Get source entity index
            var sourceIndex = GetEntityIndex(entityId);
            if (sourceIndex == -1)
                throw new ArgumentException($"Entity {entityId} not found in source archetype.");

            foreach (var type in componentTypesToTransfer)
            {
                if (
                    !componentArrays.ContainsKey(type)
                    || !targetArchetype.componentArrays.ContainsKey(type)
                )
                    continue;

                var sourceArray = componentArrays[type];
                var targetArray = targetArchetype.componentArrays[type];
                var elementSize = Marshal.SizeOf(type.Type);

                // Ensure target has space
                if (targetArchetype.count >= targetArray.Length)
                    targetArchetype.Grow();

                // Direct memory copy for the component
                Buffer.BlockCopy(
                    sourceArray, // Source array
                    sourceIndex * elementSize, // Source offset
                    targetArray, // Target array
                    targetArchetype.count * elementSize, // Target offset
                    elementSize // How many bytes to copy
                );
            }
        }
    }
}

================
File: Archetype.cs.meta
================
fileFormatVersion: 2
guid: b4381e7b77d7446289e01f3738e6d8dc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ArchetypeManager.cs
================
using System.Collections.Generic;
using System.Linq;

namespace ECS_Core
{
    public class ArchetypeManager
    {
        private readonly Dictionary<int, Archetype> archetypes = new();
        private readonly World world;

        public ArchetypeManager(World world)
        {
            this.world = world;
        }

        public Archetype GetOrCreateArchetype(ComponentType[] types)
        {
            int hash = CalculateArchetypeHash(types);
            if (!archetypes.TryGetValue(hash, out var archetype))
            {
                archetype = new Archetype(types);
                archetypes[hash] = archetype;
                // Notify world that a new archetype was created
                world.GetQueryCache(types); // This will create a cache entry for the new archetype
            }

            return archetype;
        }

        public IEnumerable<Archetype> GetArchetypesWithComponents(ComponentType[] types)
        {
            foreach (var archetype in archetypes.Values)
            {
                if (DoesArchetypeMatchQuery(archetype, types))
                {
                    yield return archetype;
                }
            }
        }

        private static bool DoesArchetypeMatchQuery(Archetype archetype, ComponentType[] queryTypes)
        {
            foreach (var queryType in queryTypes)
            {
                if (!archetype.HasComponent(queryType))
                {
                    return false;
                }
            }
            return true;
        }

        private static int CalculateArchetypeHash(ComponentType[] types)
        {
            int hash = 17;
            foreach (var type in types.OrderBy(t => t.Id))
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        public void CleanupEmptyArchetypes()
        {
            var emptyArchetypes = archetypes
                .Where(kvp => kvp.Value.Count == 0)
                .Select(kvp => kvp.Key)
                .ToList();

            if (emptyArchetypes.Count > 0)
            {
                foreach (var hash in emptyArchetypes)
                {
                    archetypes.Remove(hash);
                }
            }
        }
    }
}

================
File: ArchetypeManager.cs.meta
================
fileFormatVersion: 2
guid: 5358525b5829c452d9abb4891f4431ba
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ComponentType.cs
================
using System;
using System.Collections.Generic;

namespace ECS_Core
{
    public struct ComponentType
    {
        public readonly Type Type;
        public readonly int Id;
        private static int NextId = 0;
        private static Dictionary<Type, ComponentType> typeRegistry = new();

        private ComponentType(Type type)
        {
            Type = type;
            Id = NextId++;
        }

        public static ComponentType Of<T>()
            where T : struct, IComponent
        {
            var type = typeof(T);
            if (!typeRegistry.ContainsKey(type))
            {
                typeRegistry[type] = new ComponentType(type);
            }

            return typeRegistry[type];
        }
    }
}

================
File: ComponentType.cs.meta
================
fileFormatVersion: 2
guid: 2e3cff646cf254dee8948a45e56ad066
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: IComponent.cs
================
namespace ECS_Core
{
    public interface IComponent { }
}

================
File: IComponent.cs.meta
================
fileFormatVersion: 2
guid: 5bfc30fb61b4b4792b8875b3f63c5a3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Mock.meta
================
fileFormatVersion: 2
guid: 5ca9bd3fd7f2d6f4dbea65f7c213d993
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: QueryCache.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_Core
{
    // Stores cached data for a specific archetype in a query
    public class QueryArchetypeCache
    {
        public Archetype Archetype { get; }
        public Array[] ComponentArrays { get; private set; }
        public IReadOnlyList<int> Entities => Archetype.Entities;
        public int Count => Archetype.Count;
        private readonly ComponentType[] queryTypes;

        public QueryArchetypeCache(Archetype archetype, ComponentType[] types)
        {
            Archetype = archetype;
            queryTypes = types;
            ComponentArrays = new Array[types.Length];
            UpdateArrays();
        }

        public void UpdateArrays()
        {
            for (int i = 0; i < queryTypes.Length; i++)
            {
                ComponentArrays[i] = Archetype.GetComponentArrayRaw(queryTypes[i]);
            }
        }
    }

    // Main cache for a specific query type combination
    public class QueryCache
    {
        private readonly ComponentType[] queryTypes;
        private readonly List<QueryArchetypeCache> archetypeCaches = new();
        private readonly ArchetypeManager archetypeManager;
        public bool IsDirty { get; set; } = true;

        public QueryCache(ArchetypeManager archetypeManager, ComponentType[] types)
        {
            this.archetypeManager = archetypeManager;
            this.queryTypes = types;
        }

        public IReadOnlyList<QueryArchetypeCache> GetArchetypeCaches()
        {
            if (IsDirty)
            {
                UpdateCache();
            }
            return archetypeCaches;
        }

        private void UpdateCache()
        {
            archetypeCaches.Clear();
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(queryTypes);

            foreach (var archetype in matchingArchetypes)
            {
                archetypeCaches.Add(new QueryArchetypeCache(archetype, queryTypes));
            }

            IsDirty = false;
        }
    }

    // Cache manager to store and retrieve query caches
    public class QueryCacheManager
    {
        private readonly Dictionary<int, QueryCache> queryCaches = new();
        private readonly ArchetypeManager archetypeManager;

        public QueryCacheManager(ArchetypeManager archetypeManager)
        {
            this.archetypeManager = archetypeManager;
        }

        public QueryCache GetOrCreateCache(ComponentType[] types)
        {
            int hash = CalculateQueryHash(types);

            if (!queryCaches.TryGetValue(hash, out var cache))
            {
                cache = new QueryCache(archetypeManager, types);
                queryCaches[hash] = cache;
            }

            return cache;
        }

        private int CalculateQueryHash(ComponentType[] types)
        {
            int hash = 17;
            foreach (var type in types.OrderBy(t => t.Id))
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        public void MarkAllDirty()
        {
            foreach (var cache in queryCaches.Values)
            {
                cache.IsDirty = true;
            }
        }
    }
}

================
File: QueryCache.cs.meta
================
fileFormatVersion: 2
guid: 5c1ab0718029c7e43b756e76e9aa74a3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: QueryDescription.cs
================
namespace ECS_Core
{
    public delegate void ActionRef<T1>(ref T1 item);
    public delegate void ActionRef<T1, T2>(T1 index, ref T2 item);
    public delegate void ActionRef<T1, T2, T3>(T1 index, ref T2 item1, ref T3 item2);
    public delegate void ActionRef<T1, T2, T3, T4>(
        T1 index,
        ref T2 item1,
        ref T3 item2,
        ref T4 item3
    );
    public delegate void ActionRef<T1, T2, T3, T4, T5>(
        T1 index,
        ref T2 item1,
        ref T3 item2,
        ref T4 item3,
        ref T5 item4
    );

    public readonly struct QueryDescription<T1>
        where T1 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[] { ComponentType.Of<T1>() };

        public void ForEach(World world, ActionRef<int, T1> action)
        {
            var cache = world.GetQueryCache(componentTypes);
            var archetypeCaches = cache.GetArchetypeCaches();

            foreach (var archetypeCache in archetypeCaches)
            {
                var component1Array = (T1[])archetypeCache.ComponentArrays[0];
                var entities = archetypeCache.Entities;

                for (int i = 0; i < archetypeCache.Count; i++)
                {
                    action(entities[i], ref component1Array[i]);
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
        };

        public void ForEach(World world, ActionRef<int, T1, T2> action)
        {
            var cache = world.GetQueryCache(componentTypes);
            var archetypeCaches = cache.GetArchetypeCaches();

            foreach (var archetypeCache in archetypeCaches)
            {
                var component1Array = (T1[])archetypeCache.ComponentArrays[0];
                var component2Array = (T2[])archetypeCache.ComponentArrays[1];
                var entities = archetypeCache.Entities;

                for (int i = 0; i < archetypeCache.Count; i++)
                {
                    action(entities[i], ref component1Array[i], ref component2Array[i]);
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2, T3>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
        where T3 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
            ComponentType.Of<T3>(),
        };

        public void ForEach(World world, ActionRef<int, T1, T2, T3> action)
        {
            var cache = world.GetQueryCache(componentTypes);
            var archetypeCaches = cache.GetArchetypeCaches();

            foreach (var archetypeCache in archetypeCaches)
            {
                var component1Array = (T1[])archetypeCache.ComponentArrays[0];
                var component2Array = (T2[])archetypeCache.ComponentArrays[1];
                var component3Array = (T3[])archetypeCache.ComponentArrays[2];
                var entities = archetypeCache.Entities;

                for (int i = 0; i < archetypeCache.Count; i++)
                {
                    action(
                        entities[i],
                        ref component1Array[i],
                        ref component2Array[i],
                        ref component3Array[i]
                    );
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2, T3, T4>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
        where T3 : struct, IComponent
        where T4 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
            ComponentType.Of<T3>(),
            ComponentType.Of<T4>(),
        };

        public void ForEach(World world, ActionRef<int, T1, T2, T3, T4> action)
        {
            var cache = world.GetQueryCache(componentTypes);
            var archetypeCaches = cache.GetArchetypeCaches();

            foreach (var archetypeCache in archetypeCaches)
            {
                var component1Array = (T1[])archetypeCache.ComponentArrays[0];
                var component2Array = (T2[])archetypeCache.ComponentArrays[1];
                var component3Array = (T3[])archetypeCache.ComponentArrays[2];
                var component4Array = (T4[])archetypeCache.ComponentArrays[3];
                var entities = archetypeCache.Entities;

                for (int i = 0; i < archetypeCache.Count; i++)
                {
                    action(
                        entities[i],
                        ref component1Array[i],
                        ref component2Array[i],
                        ref component3Array[i],
                        ref component4Array[i]
                    );
                }
            }
        }
    }
}

================
File: QueryDescription.cs.meta
================
fileFormatVersion: 2
guid: 88b70e4e0660742a3aef862f0ee483f7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: SingletonCache.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_Core
{
    // Specialized cache just for singletons
    public class SingletonCache
    {
        private struct CachedComponents
        {
            public Array[] ComponentArrays;
            public int EntityIndex;
            public int EntityId;
            public Archetype Archetype; // Store reference to archetype for direct access
        }

        private readonly Dictionary<int, CachedComponents> cacheByFlagType = new();
        private readonly World world;
        private bool isDirty;

        public SingletonCache(World world)
        {
            this.world = world;
        }

        public void GetComponents<TFlag, T1>(out T1 component1)
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();
            var comp1Type = ComponentType.Of<T1>();

            if (!TryGetCachedComponents(flagType, out var cached))
            {
                // Cache miss - find the singleton
                cached = FindAndCacheSingleton<TFlag>(new[] { comp1Type });
            }

            // Direct array access with type safety
            component1 = ((T1[])cached.ComponentArrays[0])[cached.EntityIndex];
        }

        public void GetComponents<TFlag, T1, T2>(out T1 component1, out T2 component2)
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();
            var compTypes = new[] { ComponentType.Of<T1>(), ComponentType.Of<T2>() };

            if (!TryGetCachedComponents(flagType, out var cached))
            {
                cached = FindAndCacheSingleton<TFlag>(compTypes);
            }

            component1 = ((T1[])cached.ComponentArrays[0])[cached.EntityIndex];
            component2 = ((T2[])cached.ComponentArrays[1])[cached.EntityIndex];
        }

        public void GetComponents<TFlag, T1, T2, T3>(
            out T1 component1,
            out T2 component2,
            out T3 component3
        )
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();
            var compTypes = new[]
            {
                ComponentType.Of<T1>(),
                ComponentType.Of<T2>(),
                ComponentType.Of<T3>(),
            };

            if (!TryGetCachedComponents(flagType, out var cached))
            {
                cached = FindAndCacheSingleton<TFlag>(compTypes);
            }

            component1 = ((T1[])cached.ComponentArrays[0])[cached.EntityIndex];
            component2 = ((T2[])cached.ComponentArrays[1])[cached.EntityIndex];
            component3 = ((T3[])cached.ComponentArrays[2])[cached.EntityIndex];
        }

        private bool TryGetCachedComponents(ComponentType flagType, out CachedComponents cached)
        {
            if (
                !isDirty
                && cacheByFlagType.TryGetValue(flagType.Id, out cached)
                && world.EntityExists(cached.EntityId)
            )
            {
                return true;
            }

            cached = default;
            return false;
        }

        private CachedComponents FindAndCacheSingleton<TFlag>(ComponentType[] componentTypes)
            where TFlag : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();
            var allTypes = new[] { ComponentType.Of<SingletonFlag>(), flagType }
                .Concat(componentTypes)
                .ToArray();

            // Find matching archetype and entity
            var matchingArchetypes = world.ArchetypeManager.GetArchetypesWithComponents(allTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var entities = archetype.Entities;
                for (int i = 0; i < archetype.Count; i++)
                {
                    int entityId = entities[i];
                    if (!world.IsMarkedForDestruction(entityId))
                    {
                        // Create cache entry
                        var arrays = new Array[componentTypes.Length];
                        for (int j = 0; j < componentTypes.Length; j++)
                        {
                            arrays[j] = archetype.GetComponentArrayRaw(componentTypes[j]);
                        }

                        var cached = new CachedComponents
                        {
                            ComponentArrays = arrays,
                            EntityIndex = i,
                            EntityId = entityId,
                            Archetype = archetype,
                        };

                        cacheByFlagType[flagType.Id] = cached;
                        return cached;
                    }
                }
            }

            throw new InvalidOperationException(
                $"No singleton found with flag {typeof(TFlag).Name}"
            );
        }

        public void MarkDirty()
        {
            isDirty = true;
        }

        public void Clear()
        {
            cacheByFlagType.Clear();
            isDirty = true;
        }
    }
}

================
File: SingletonCache.cs.meta
================
fileFormatVersion: 2
guid: ec39014572c324d41b0b9ca52123b047
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: SystemManager.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_Core
{
    public interface IGameSystem
    {
        void Initialize();
        void Start();
        void Update();
        void Cleanup();
        bool AutoUpdate { get; set; }
        ArchetypeManager ArchetypeManager { get; set; }
    }

    public static class SystemManager
    {
        private static Dictionary<Type, IGameSystem> systems = new();
        private static bool isInitialized;

        public static void RegisterSystem<T>(T system)
            where T : struct, IGameSystem
        {
            if (systems.ContainsKey(typeof(T)))
            {
                Debug.LogWarning($"System {typeof(T)} is already registered. Skipping.");
                return;
            }

            systems[typeof(T)] = new GameSystemWrapper<T>(system);
        }

        public static ref T GetSystem<T>()
            where T : struct, IGameSystem
        {
            if (systems.TryGetValue(typeof(T), out var wrapper))
            {
                return ref ((GameSystemWrapper<T>)wrapper).System;
            }
            throw new KeyNotFoundException($"System {typeof(T)} not registered");
        }

        public static void InitializeSystems(World world)
        {
            if (isInitialized)
            {
                Debug.LogWarning("Systems are already initialized.");
                return;
            }

            foreach (var system in systems.Values)
            {
                try
                {
                    system.ArchetypeManager = world.ArchetypeManager;
                    system.Initialize();
                }
                catch (Exception e)
                {
                    Debug.LogError($"Failed to initialize system {system.GetType()}: {e}");
                }
            }

            isInitialized = true;
        }

        public static void SystemStart()
        {
            if (!isInitialized)
            {
                Debug.LogError("Systems not initialized. Call InitializeSystems first.");
                return;
            }
            foreach (var system in systems.Values)
            {
                // Only update systems that are enabled AND marked for auto-update
                if (((ISystemState)system).Enabled)
                {
                    try
                    {
                        system.Start();
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error Starting system {system.GetType()}: {e}");
                    }
                }
            }
        }

        public static void UpdateSystems()
        {
            if (!isInitialized)
            {
                Debug.LogError("Systems not initialized. Call InitializeSystems first.");
                return;
            }

            foreach (var system in systems.Values)
            {
                // Only update systems that are enabled AND marked for auto-update
                if (((ISystemState)system).Enabled && system.AutoUpdate)
                {
                    try
                    {
                        system.Update();
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error updating system {system.GetType()}: {e}");
                    }
                }
            }
        }

        public static void EnableSystem<T>()
            where T : struct, IGameSystem
        {
            if (systems.TryGetValue(typeof(T), out var system))
            {
                ((ISystemState)system).Enabled = true;
            }
        }

        public static void DisableSystem<T>()
            where T : struct, IGameSystem
        {
            if (systems.TryGetValue(typeof(T), out var system))
            {
                ((ISystemState)system).Enabled = false;
            }
        }

        public static void Clear()
        {
            if (!isInitialized)
                return;

            foreach (var system in systems.Values)
            {
                try
                {
                    system.Cleanup();
                }
                catch (Exception e)
                {
                    Debug.LogError($"Error cleaning up system {system.GetType()}: {e}");
                }
            }

            systems.Clear();
            isInitialized = false;
        }

        private interface ISystemState
        {
            bool Enabled { get; set; }
        }

        private class GameSystemWrapper<T> : IGameSystem, ISystemState
            where T : IGameSystem
        {
            public T System;
            public bool Enabled { get; set; } = true;
            public bool AutoUpdate
            {
                get => System.AutoUpdate;
                set => System.AutoUpdate = value;
            }
            public ArchetypeManager ArchetypeManager
            {
                get => System.ArchetypeManager;
                set => System.ArchetypeManager = value;
            }

            public GameSystemWrapper(T system)
            {
                System = system;
            }

            public void Initialize() => System.Initialize();

            public void Update() => System.Update();

            public void Cleanup() => System.Cleanup();

            public void Start() => System.Start();
        }
    }
}

// Example usage:

================
File: SystemManager.cs.meta
================
fileFormatVersion: 2
guid: cce3b968c17691b4bb5a1a080cdc9340
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: World.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_Core
{
    public class World
    {
        // Main cache storage - we use component type ID as the key for faster lookup

        #region Static Access
        private static World activeWorld;
        public static World Active => activeWorld;

        public static void SetActiveWorld(World world) => activeWorld = world;
        #endregion

        #region Constants
        private const int CLEANUP_THRESHOLD = 100;
        private const int FIRST_NORMAL_ENTITY_ID = 1000;
        private const int OPERATIONS_PER_FRAME = 100;
        #endregion

        #region Fields
        private readonly ArchetypeManager archetypeManager;
        private readonly Dictionary<int, Archetype> entityArchetypes = new();
        private readonly Dictionary<int, Dictionary<ComponentType, object>> pendingComponents =
            new();
        private readonly Dictionary<string, Dictionary<ComponentType, object>> templates = new();
        private readonly Dictionary<string, Archetype> archetypeCache = new();
        private readonly Queue<int> pendingDestructions = new();
        private readonly HashSet<int> markedForDestruction = new();
        private readonly Queue<(string template, Action<int> modifier)> pendingCreations = new();
        private readonly QueryCacheManager queryCacheManager;
        private readonly SingletonCache singletonCache;

        private int nextEntityId = FIRST_NORMAL_ENTITY_ID;
        private int pendingOperationCount = 0;
        private int creationBatchSize = 0;
        #endregion

        public ArchetypeManager ArchetypeManager => archetypeManager;

        public World()
        {
            archetypeManager = new ArchetypeManager(this);
            queryCacheManager = new QueryCacheManager(archetypeManager);
            singletonCache = new SingletonCache(this);
        }

        #region Entity Creation and Components

        public int CreateEntity()
        {
            var entityId = nextEntityId++;
            pendingComponents[entityId] = new Dictionary<ComponentType, object>();
            return entityId;
        }

        public void AddComponent<T>(int entityId, T component)
            where T : struct, IComponent
        {
            if (!pendingComponents.TryGetValue(entityId, out var components))
            {
                components = new Dictionary<ComponentType, object>();
                pendingComponents[entityId] = components;
            }

            components[ComponentType.Of<T>()] = component;
        }

        public void UpdateEntity(int entityId)
        {
            if (!pendingComponents.TryGetValue(entityId, out var components))
                return;

            // Check singleton uniqueness
            bool isSingleton = components.ContainsKey(ComponentType.Of<SingletonFlag>());
            if (isSingleton)
            {
                foreach (var componentType in components.Keys)
                {
                    if (componentType.Type == typeof(SingletonFlag))
                        continue;

                    bool singletonExists = false;
                    var query = new QueryDescription<SingletonFlag>();
                    query.ForEach(
                        this,
                        (int existingId, ref SingletonFlag _) =>
                        {
                            if (!IsMarkedForDestruction(existingId))
                            {
                                var existingArchetype = entityArchetypes[existingId];
                                if (existingArchetype.HasComponent(componentType))
                                    singletonExists = true;
                            }
                        }
                    );

                    if (singletonExists)
                        throw new InvalidOperationException(
                            $"Singleton of type {componentType.Type.Name} already exists"
                        );
                }
            }

            var types = components.Keys.ToArray();
            var archetype = archetypeManager.GetOrCreateArchetype(types);
            archetype.Add(entityId, components);
            entityArchetypes[entityId] = archetype;
            pendingComponents.Remove(entityId);

            // Add this line to invalidate caches
            queryCacheManager.MarkAllDirty();
            singletonCache.MarkDirty();
        }

        public void UpdateEntities(IEnumerable<int> entityIds)
        {
            var entitiesByArchetype =
                new Dictionary<
                    string,
                    List<(int id, Dictionary<ComponentType, object> components)>
                >();

            foreach (var entityId in entityIds)
            {
                if (!pendingComponents.TryGetValue(entityId, out var components))
                    continue;

                var typeKey = string.Join(",", components.Keys.Select(t => t.Id).OrderBy(id => id));
                if (!entitiesByArchetype.TryGetValue(typeKey, out var list))
                {
                    list = new List<(int, Dictionary<ComponentType, object>)>();
                    entitiesByArchetype[typeKey] = list;
                }
                list.Add((entityId, components));
            }

            foreach (var group in entitiesByArchetype)
            {
                Archetype archetype;
                if (!archetypeCache.TryGetValue(group.Key, out archetype))
                {
                    var types = group.Value[0].components.Keys.ToArray();
                    archetype = archetypeManager.GetOrCreateArchetype(types);
                    archetypeCache[group.Key] = archetype;
                }

                foreach (var (entityId, components) in group.Value)
                {
                    archetype.Add(entityId, components);
                    entityArchetypes[entityId] = archetype;
                    pendingComponents.Remove(entityId);
                }
            }
            queryCacheManager.MarkAllDirty();
        }
        #endregion

        #region Template System
        public void CreateTemplate(
            string templateName,
            Dictionary<ComponentType, object> components
        )
        {
            templates[templateName] = components;

            var types = components.Keys.ToArray();
            var typeKey = string.Join(",", types.Select(t => t.Id).OrderBy(id => id));
            if (!archetypeCache.ContainsKey(typeKey))
            {
                archetypeCache[typeKey] = archetypeManager.GetOrCreateArchetype(types);
            }
        }

        public int CreateEntityFromTemplate(string templateName)
        {
            if (!templates.TryGetValue(templateName, out var templateComponents))
                throw new ArgumentException($"Template {templateName} not found");

            var entityId = CreateEntity();
            var components = new Dictionary<ComponentType, object>(templateComponents);
            pendingComponents[entityId] = components;
            queryCacheManager.MarkAllDirty();
            return entityId;
        }

        public void QueueEntityCreation(string templateName, Action<int> modifyComponents = null)
        {
            pendingCreations.Enqueue((templateName, modifyComponents));
            creationBatchSize++;
        }

        public void ModifyPendingComponent<T>(int entityId, ActionRef<T> modifier)
            where T : struct, IComponent
        {
            if (!pendingComponents.TryGetValue(entityId, out var components))
                return;

            var componentType = ComponentType.Of<T>();
            if (components.TryGetValue(componentType, out var component))
            {
                var typed = (T)component;
                modifier(ref typed);
                components[componentType] = typed;
            }
        }
        #endregion

        #region Entity Management
        public void DestroyEntityDeferred(int entityId)
        {
            if (!markedForDestruction.Contains(entityId))
            {
                pendingDestructions.Enqueue(entityId);
                markedForDestruction.Add(entityId);
            }
            queryCacheManager.MarkAllDirty();
            singletonCache.MarkDirty();
        }

        public bool EntityExists(int entityId)
        {
            return entityArchetypes.ContainsKey(entityId)
                && !markedForDestruction.Contains(entityId);
        }

        public bool IsMarkedForDestruction(int entityId) => markedForDestruction.Contains(entityId);
        #endregion

        #region Query System
        // Add this method to access the cache
        internal QueryCache GetQueryCache(ComponentType[] types)
        {
            return queryCacheManager.GetOrCreateCache(types);
        }

        public static QueryDescription<T1> Query<T1>()
            where T1 : struct, IComponent
        {
            return new QueryDescription<T1>();
        }

        public static QueryDescription<T1, T2> Query<T1, T2>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            return new QueryDescription<T1, T2>();
        }

        public static QueryDescription<T1, T2, T3> Query<T1, T2, T3>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            return new QueryDescription<T1, T2, T3>();
        }

        public static QueryDescription<T1, T2, T3, T4> Query<T1, T2, T3, T4>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
            where T4 : struct, IComponent
        {
            return new QueryDescription<T1, T2, T3, T4>();
        }
        #endregion

        #region Singleton Access

        // Public API - TFlag is the singleton identifier, T1 is the component we want
        public void GetSingletonComponents<TFlag, T1>(out T1 component1)
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
        {
            singletonCache.GetComponents<TFlag, T1>(out component1);
        }

        // Overload for two components
        public void GetSingletonComponents<TFlag, T1, T2>(out T1 component1, out T2 component2)
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            singletonCache.GetComponents<TFlag, T1, T2>(out component1, out component2);
        }

        // Overload for three components
        public void GetSingletonComponents<TFlag, T1, T2, T3>(
            out T1 component1,
            out T2 component2,
            out T3 component3
        )
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            singletonCache.GetComponents<TFlag, T1, T2, T3>(
                out component1,
                out component2,
                out component3
            );
        }

        #endregion

        #region Update System
        public void Update()
        {
            ProcessPendingCreations();
            ProcessPendingDestructions();
        }

        private void ProcessPendingCreations()
        {
            if (creationBatchSize == 0)
                return;

            var entitiesToUpdate = new List<int>();
            var processCount = Math.Min(OPERATIONS_PER_FRAME, creationBatchSize);

            for (int i = 0; i < processCount; i++)
            {
                if (pendingCreations.Count == 0)
                    break;

                var (template, modifier) = pendingCreations.Dequeue();
                int entityId = CreateEntityFromTemplate(template);

                modifier?.Invoke(entityId);
                entitiesToUpdate.Add(entityId);
            }

            if (entitiesToUpdate.Count > 0)
            {
                UpdateEntities(entitiesToUpdate);
                creationBatchSize -= entitiesToUpdate.Count;
            }
        }

        private void ProcessPendingDestructions()
        {
            int processCount = Math.Min(OPERATIONS_PER_FRAME, pendingDestructions.Count);
            bool anyProcessed = false;

            for (int i = 0; i < processCount; i++)
            {
                if (pendingDestructions.Count == 0)
                    break;

                int entityId = pendingDestructions.Dequeue();
                markedForDestruction.Remove(entityId);

                if (entityArchetypes.TryGetValue(entityId, out var archetype))
                {
                    archetype.RemoveEntity(entityId);
                    entityArchetypes.Remove(entityId);
                    pendingOperationCount++;
                    anyProcessed = true;
                }
            }

            if (anyProcessed)
            {
                // Add this line when entities are actually destroyed
                queryCacheManager.MarkAllDirty();
            }

            if (pendingOperationCount >= CLEANUP_THRESHOLD)
            {
                archetypeManager.CleanupEmptyArchetypes();
                pendingOperationCount = 0;
                // Add this line after cleanup
                queryCacheManager.MarkAllDirty();
            }
        }

        // Add cleanup for query cache
        public void Clear()
        {
            // Existing cleanup logic...
            queryCacheManager.MarkAllDirty();
            singletonCache.Clear();
        }

        public (int creations, int destructions) GetPendingOperationCounts() =>
            (creationBatchSize, pendingDestructions.Count);
        #endregion
    }

    public struct SingletonFlag : IComponent { }
}

================
File: World.cs.meta
================
fileFormatVersion: 2
guid: 7af841868c71a4655bb50385d1c61ad1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/repomix-output.txt.meta
================
fileFormatVersion: 2
guid: b028166130eaf4141806f82ed23a9377
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/SingletonCache.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_Core
{
    // Specialized cache just for singletons
    public class SingletonCache
    {
        private struct CachedComponents
        {
            public Array[] ComponentArrays;
            public int EntityIndex;
            public int EntityId;
            public Archetype Archetype; // Store reference to archetype for direct access
        }

        private readonly Dictionary<int, CachedComponents> cacheByFlagType = new();
        private readonly World world;
        private bool isDirty;

        public SingletonCache(World world)
        {
            this.world = world;
        }

        public void GetComponents<TFlag, T1>(out T1 component1)
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();
            var comp1Type = ComponentType.Of<T1>();

            if (!TryGetCachedComponents(flagType, out var cached))
            {
                // Cache miss - find the singleton
                cached = FindAndCacheSingleton<TFlag>(new[] { comp1Type });
            }

            // Direct array access with type safety
            component1 = ((T1[])cached.ComponentArrays[0])[cached.EntityIndex];
        }

        public void GetComponents<TFlag, T1, T2>(out T1 component1, out T2 component2)
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();
            var compTypes = new[] { ComponentType.Of<T1>(), ComponentType.Of<T2>() };

            if (!TryGetCachedComponents(flagType, out var cached))
            {
                cached = FindAndCacheSingleton<TFlag>(compTypes);
            }

            component1 = ((T1[])cached.ComponentArrays[0])[cached.EntityIndex];
            component2 = ((T2[])cached.ComponentArrays[1])[cached.EntityIndex];
        }

        public void GetComponents<TFlag, T1, T2, T3>(
            out T1 component1,
            out T2 component2,
            out T3 component3
        )
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();
            var compTypes = new[]
            {
                ComponentType.Of<T1>(),
                ComponentType.Of<T2>(),
                ComponentType.Of<T3>(),
            };

            if (!TryGetCachedComponents(flagType, out var cached))
            {
                cached = FindAndCacheSingleton<TFlag>(compTypes);
            }

            component1 = ((T1[])cached.ComponentArrays[0])[cached.EntityIndex];
            component2 = ((T2[])cached.ComponentArrays[1])[cached.EntityIndex];
            component3 = ((T3[])cached.ComponentArrays[2])[cached.EntityIndex];
        }

        private bool TryGetCachedComponents(ComponentType flagType, out CachedComponents cached)
        {
            if (
                !isDirty
                && cacheByFlagType.TryGetValue(flagType.Id, out cached)
                && world.EntityExists(cached.EntityId)
            )
            {
                return true;
            }

            cached = default;
            return false;
        }

        private CachedComponents FindAndCacheSingleton<TFlag>(ComponentType[] componentTypes)
            where TFlag : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();
            var allTypes = new[] { ComponentType.Of<SingletonFlag>(), flagType }
                .Concat(componentTypes)
                .ToArray();

            // Find matching archetype and entity
            var matchingArchetypes = world.ArchetypeManager.GetArchetypesWithComponents(allTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var entities = archetype.Entities;
                for (int i = 0; i < archetype.Count; i++)
                {
                    int entityId = entities[i];
                    if (!world.IsMarkedForDestruction(entityId))
                    {
                        // Create cache entry
                        var arrays = new Array[componentTypes.Length];
                        for (int j = 0; j < componentTypes.Length; j++)
                        {
                            arrays[j] = archetype.GetComponentArrayRaw(componentTypes[j]);
                        }

                        var cached = new CachedComponents
                        {
                            ComponentArrays = arrays,
                            EntityIndex = i,
                            EntityId = entityId,
                            Archetype = archetype,
                        };

                        cacheByFlagType[flagType.Id] = cached;
                        return cached;
                    }
                }
            }

            throw new InvalidOperationException(
                $"No singleton found with flag {typeof(TFlag).Name}"
            );
        }

        public void MarkDirty()
        {
            isDirty = true;
        }

        public void Clear()
        {
            cacheByFlagType.Clear();
            isDirty = true;
        }
    }
}

================
File: ECS_Core/SingletonCache.cs.meta
================
fileFormatVersion: 2
guid: ec39014572c324d41b0b9ca52123b047
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/SparseSet.cs
================
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace ECS_Core
{
    public class SparseSet<T>
    {
        private const int DEFAULT_CAPACITY = 64;
        private const float GROWTH_FACTOR = 2.0f;

        private int[] sparse;
        private int[] dense;
        private T[] data;
        private int count;

        public SparseSet(int initialCapacity = DEFAULT_CAPACITY)
        {
            sparse = new int[initialCapacity];
            dense = new int[initialCapacity];
            data = new T[initialCapacity];
            count = 0;

            Array.Fill(sparse, -1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(int entityId, in T value)
        {
            if (entityId >= sparse.Length)
            {
                int newCapacity = Mathf.Max(sparse.Length * 2, entityId + 1);
                Array.Resize(ref sparse, newCapacity);

                Array.Fill(sparse, -1, sparse.Length / 2, newCapacity - sparse.Length / 2);
            }

            if (count >= dense.Length)
            {
                int newCapacity = (int)(dense.Length * GROWTH_FACTOR);
                Array.Resize(ref dense, newCapacity);
                Array.Resize(ref data, newCapacity);
            }

            // Add to sparse set
            sparse[entityId] = count;
            dense[count] = entityId;
            data[count] = value;
            count++;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Remove(int entityId)
        {
            if (!Contains(entityId))
            {
                return;
            }

            int denseIndex = sparse[entityId];
            int lastEntityId = dense[count - 1];

            if (denseIndex < count - 1)
            {
                data[denseIndex] = data[count - 1];
                dense[denseIndex] = lastEntityId;
                sparse[lastEntityId] = denseIndex;
            }

            sparse[entityId] = -1;
            count--;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Get(int entityId)
        {
            if (!Contains(entityId))
            {
                throw new ArgumentException($"Entity {entityId} not found in sparse set");
            }

            return ref data[sparse[entityId]];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGet(int entityId, out T value)
        {
            if (Contains(entityId))
            {
                value = data[sparse[entityId]];
                return true;
            }
            value = default;
            return false;
        }

        public void Set(int entityId, in T value)
        {
            if (Contains(entityId))
            {
                data[sparse[entityId]] = value;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(int entityId)
        {
            return entityId < sparse.Length && sparse[entityId] != -1 && sparse[entityId] < count;
        }

        // Efficient iteration methods
        public Span<T> GetDataSpan() => new Span<T>(data, 0, count);

        public Span<int> GetEntitySpan() => new Span<int>(dense, 0, count);

        // New method to get dense array of entity IDs
        public ReadOnlySpan<int> GetEntityIds()
        {
            return new ReadOnlySpan<int>(dense, 0, count);
        }

        public int GetEntityIndex(int entityId)
        {
            return Contains(entityId) ? sparse[entityId] : -1;
        }

        public void Clear()
        {
            Array.Fill(sparse, -1);
            count = 0;
        }

        public int Count => count;
    }
}

================
File: ECS_Core/SparseSet.cs.meta
================
fileFormatVersion: 2
guid: 7b84db72cd33f4edc932eff5aa003d13
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/StructuralChangeVersion.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_Core
{
    public struct StructuralChangeVersion
    {
        public uint GlobalVersion;
        public uint FrameNumber;

        public void IncrementVersion()
        {
            GlobalVersion++;
        }

        public bool HasChanged(uint lastVersion) => GlobalVersion > lastVersion;
    }

    public struct QueryVersionInfo
    {
        public uint lastProcessedVersion;
        public uint lastUpdatedFrame;

        public bool IsValid(in StructuralChangeVersion worldVersion)
        {
            return lastProcessedVersion == worldVersion.GlobalVersion
                && lastUpdatedFrame == worldVersion.FrameNumber;
        }
    }
}

================
File: ECS_Core/StructuralChangeVersion.cs.meta
================
fileFormatVersion: 2
guid: 52c2197559a494d768509813433a47d5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/SystemManager.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_Core
{
    public interface IGameSystem
    {
        void Initialize();
        void Start();
        void Update();
        void Cleanup();
        bool AutoUpdate { get; set; }
        ArchetypeManager ArchetypeManager { get; set; }
    }

    public static class SystemManager
    {
        private static Dictionary<Type, IGameSystem> systems = new();
        private static bool isInitialized;

        public static void RegisterSystem<T>(T system)
            where T : struct, IGameSystem
        {
            if (systems.ContainsKey(typeof(T)))
            {
                Debug.LogWarning($"System {typeof(T)} is already registered. Skipping.");
                return;
            }

            systems[typeof(T)] = new GameSystemWrapper<T>(system);
        }

        public static ref T GetSystem<T>()
            where T : struct, IGameSystem
        {
            if (systems.TryGetValue(typeof(T), out var wrapper))
            {
                return ref ((GameSystemWrapper<T>)wrapper).System;
            }
            throw new KeyNotFoundException($"System {typeof(T)} not registered");
        }

        public static void InitializeSystems(World world)
        {
            if (isInitialized)
            {
                Debug.LogWarning("Systems are already initialized.");
                return;
            }

            foreach (var system in systems.Values)
            {
                try
                {
                    system.ArchetypeManager = world.ArchetypeManager;
                    system.Initialize();
                }
                catch (Exception e)
                {
                    Debug.LogError($"Failed to initialize system {system.GetType()}: {e}");
                }
            }

            isInitialized = true;
        }

        public static void SystemStart()
        {
            if (!isInitialized)
            {
                Debug.LogError("Systems not initialized. Call InitializeSystems first.");
                return;
            }
            foreach (var system in systems.Values)
            {
                // Only update systems that are enabled AND marked for auto-update
                if (((ISystemState)system).Enabled)
                {
                    try
                    {
                        system.Start();
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error Starting system {system.GetType()}: {e}");
                    }
                }
            }
        }

        public static void UpdateSystems()
        {
            if (!isInitialized)
            {
                Debug.LogError("Systems not initialized. Call InitializeSystems first.");
                return;
            }

            foreach (var system in systems.Values)
            {
                // Only update systems that are enabled AND marked for auto-update
                if (((ISystemState)system).Enabled && system.AutoUpdate)
                {
                    try
                    {
                        system.Update();
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error updating system {system.GetType()}: {e}");
                    }
                }
            }
        }

        public static void EnableSystem<T>()
            where T : struct, IGameSystem
        {
            if (systems.TryGetValue(typeof(T), out var system))
            {
                ((ISystemState)system).Enabled = true;
            }
        }

        public static void DisableSystem<T>()
            where T : struct, IGameSystem
        {
            if (systems.TryGetValue(typeof(T), out var system))
            {
                ((ISystemState)system).Enabled = false;
            }
        }

        public static void Clear()
        {
            if (!isInitialized)
                return;

            foreach (var system in systems.Values)
            {
                try
                {
                    system.Cleanup();
                }
                catch (Exception e)
                {
                    Debug.LogError($"Error cleaning up system {system.GetType()}: {e}");
                }
            }

            systems.Clear();
            isInitialized = false;
        }

        private interface ISystemState
        {
            bool Enabled { get; set; }
        }

        private class GameSystemWrapper<T> : IGameSystem, ISystemState
            where T : IGameSystem
        {
            public T System;
            public bool Enabled { get; set; } = true;
            public bool AutoUpdate
            {
                get => System.AutoUpdate;
                set => System.AutoUpdate = value;
            }
            public ArchetypeManager ArchetypeManager
            {
                get => System.ArchetypeManager;
                set => System.ArchetypeManager = value;
            }

            public GameSystemWrapper(T system)
            {
                System = system;
            }

            public void Initialize() => System.Initialize();

            public void Update() => System.Update();

            public void Cleanup() => System.Cleanup();

            public void Start() => System.Start();
        }
    }
}

// Example usage:

================
File: ECS_Core/SystemManager.cs.meta
================
fileFormatVersion: 2
guid: cce3b968c17691b4bb5a1a080cdc9340
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/World.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_Core
{
    public class World
    {
        // Main cache storage - we use component type ID as the key for faster lookup

        #region Static Access
        private static World activeWorld;
        public static World Active => activeWorld;

        public static void SetActiveWorld(World world) => activeWorld = world;
        #endregion

        #region Constants
        private const int CLEANUP_THRESHOLD = 100;
        private const int FIRST_NORMAL_ENTITY_ID = 1000;
        private const int OPERATIONS_PER_FRAME = 100;
        #endregion

        #region Fields
        private readonly ArchetypeManager archetypeManager;
        private readonly Dictionary<int, Archetype> entityArchetypes = new();
        private readonly Dictionary<int, Dictionary<ComponentType, object>> pendingComponents =
            new();
        private readonly Dictionary<string, Dictionary<ComponentType, object>> templates = new();
        private readonly Dictionary<string, Archetype> archetypeCache = new();
        private readonly Queue<int> pendingDestructions = new();
        private readonly HashSet<int> markedForDestruction = new();
        private readonly Queue<(string template, Action<int> modifier)> pendingCreations = new();
        private readonly QueryCacheManager queryCacheManager;
        private readonly SingletonCache singletonCache;
        private StructuralChangeVersion StructuralVersion;
        private uint currentFrame;

        private int nextEntityId = FIRST_NORMAL_ENTITY_ID;
        private int pendingOperationCount = 0;
        private int creationBatchSize = 0;
        #endregion

        public ArchetypeManager ArchetypeManager => archetypeManager;

        public StructuralChangeVersion GetStructuralVersion() => StructuralVersion;

        public World()
        {
            archetypeManager = new ArchetypeManager(this);
            queryCacheManager = new QueryCacheManager(this, archetypeManager);
            singletonCache = new SingletonCache(this);
        }

        public void IncrementChange()
        {
            currentFrame++;
            StructuralVersion.FrameNumber = currentFrame;
        }

        private void NotifyStructuralChange()
        {
            StructuralVersion.IncrementVersion();
            queryCacheManager.MarkAllDirty();
        }

        #region Entity Creation and Components

        public int CreateEntity()
        {
            var entityId = nextEntityId++;
            pendingComponents[entityId] = new Dictionary<ComponentType, object>();
            return entityId;
        }

        public void AddComponent<T>(int entityId, T component)
            where T : struct, IComponent
        {
            if (!pendingComponents.TryGetValue(entityId, out var components))
            {
                components = new Dictionary<ComponentType, object>();
                pendingComponents[entityId] = components;
            }

            components[ComponentType.Of<T>()] = component;
            NotifyStructuralChange();
        }

        public void UpdateEntity(int entityId)
        {
            if (!pendingComponents.TryGetValue(entityId, out var components))
                return;

            // Check singleton uniqueness
            bool isSingleton = components.ContainsKey(ComponentType.Of<SingletonFlag>());
            if (isSingleton)
            {
                foreach (var componentType in components.Keys)
                {
                    if (componentType.Type == typeof(SingletonFlag))
                        continue;

                    bool singletonExists = false;
                    var query = new QueryDescription<SingletonFlag>();
                    query.ForEach(
                        this,
                        (int existingId, ref SingletonFlag _) =>
                        {
                            if (!IsMarkedForDestruction(existingId))
                            {
                                var existingArchetype = entityArchetypes[existingId];
                                if (existingArchetype.HasComponent(componentType))
                                    singletonExists = true;
                            }
                        }
                    );

                    if (singletonExists)
                        throw new InvalidOperationException(
                            $"Singleton of type {componentType.Type.Name} already exists"
                        );
                }
            }

            var types = components.Keys.ToArray();
            var archetype = archetypeManager.GetOrCreateArchetype(types);
            archetype.Add(entityId, components);
            entityArchetypes[entityId] = archetype;
            pendingComponents.Remove(entityId);

            // Add this line to invalidate caches
            queryCacheManager.MarkAllDirty();
            singletonCache.MarkDirty();
        }

        public void UpdateEntities(IEnumerable<int> entityIds)
        {
            var entitiesByArchetype =
                new Dictionary<
                    string,
                    List<(int id, Dictionary<ComponentType, object> components)>
                >();

            foreach (var entityId in entityIds)
            {
                if (!pendingComponents.TryGetValue(entityId, out var components))
                    continue;

                var typeKey = string.Join(",", components.Keys.Select(t => t.Id).OrderBy(id => id));
                if (!entitiesByArchetype.TryGetValue(typeKey, out var list))
                {
                    list = new List<(int, Dictionary<ComponentType, object>)>();
                    entitiesByArchetype[typeKey] = list;
                }
                list.Add((entityId, components));
            }

            foreach (var group in entitiesByArchetype)
            {
                Archetype archetype;
                if (!archetypeCache.TryGetValue(group.Key, out archetype))
                {
                    var types = group.Value[0].components.Keys.ToArray();
                    archetype = archetypeManager.GetOrCreateArchetype(types);
                    archetypeCache[group.Key] = archetype;
                }

                foreach (var (entityId, components) in group.Value)
                {
                    archetype.Add(entityId, components);
                    entityArchetypes[entityId] = archetype;
                    pendingComponents.Remove(entityId);
                }
            }
            queryCacheManager.MarkAllDirty();
        }
        #endregion

        #region Template System
        public void CreateTemplate(
            string templateName,
            Dictionary<ComponentType, object> components
        )
        {
            templates[templateName] = components;

            var types = components.Keys.ToArray();
            var typeKey = string.Join(",", types.Select(t => t.Id).OrderBy(id => id));
            if (!archetypeCache.ContainsKey(typeKey))
            {
                archetypeCache[typeKey] = archetypeManager.GetOrCreateArchetype(types);
            }
        }

        public int CreateEntityFromTemplate(string templateName)
        {
            if (!templates.TryGetValue(templateName, out var templateComponents))
                throw new ArgumentException($"Template {templateName} not found");

            var entityId = CreateEntity();
            var components = new Dictionary<ComponentType, object>(templateComponents);
            pendingComponents[entityId] = components;
            queryCacheManager.MarkAllDirty();
            return entityId;
        }

        public void QueueEntityCreation(string templateName, Action<int> modifyComponents = null)
        {
            pendingCreations.Enqueue((templateName, modifyComponents));
            creationBatchSize++;
        }

        public void ModifyPendingComponent<T>(int entityId, ActionRef<T> modifier)
            where T : struct, IComponent
        {
            if (!pendingComponents.TryGetValue(entityId, out var components))
                return;

            var componentType = ComponentType.Of<T>();
            if (components.TryGetValue(componentType, out var component))
            {
                var typed = (T)component;
                modifier(ref typed);
                components[componentType] = typed;
            }
        }
        #endregion

        #region Entity Management
        public void DestroyEntityDeferred(int entityId)
        {
            if (!markedForDestruction.Contains(entityId))
            {
                pendingDestructions.Enqueue(entityId);
                markedForDestruction.Add(entityId);
                NotifyStructuralChange();
            }
            singletonCache.MarkDirty();
        }

        public bool EntityExists(int entityId)
        {
            return entityArchetypes.ContainsKey(entityId)
                && !markedForDestruction.Contains(entityId);
        }

        public bool IsMarkedForDestruction(int entityId) => markedForDestruction.Contains(entityId);
        #endregion

        #region Query System
        // Add this method to access the cache
        internal QueryCache GetQueryCache(ComponentType[] types)
        {
            return queryCacheManager.GetOrCreateCache(types);
        }

        public static QueryDescription<T1> Query<T1>()
            where T1 : struct, IComponent
        {
            return new QueryDescription<T1>();
        }

        public static QueryDescription<T1, T2> Query<T1, T2>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            return new QueryDescription<T1, T2>();
        }

        public static QueryDescription<T1, T2, T3> Query<T1, T2, T3>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            return new QueryDescription<T1, T2, T3>();
        }

        public static QueryDescription<T1, T2, T3, T4> Query<T1, T2, T3, T4>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
            where T4 : struct, IComponent
        {
            return new QueryDescription<T1, T2, T3, T4>();
        }
        #endregion

        #region Singleton Access

        // Public API - TFlag is the singleton identifier, T1 is the component we want
        public void GetSingletonComponents<TFlag, T1>(out T1 component1)
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
        {
            singletonCache.GetComponents<TFlag, T1>(out component1);
        }

        // Overload for two components
        public void GetSingletonComponents<TFlag, T1, T2>(out T1 component1, out T2 component2)
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            singletonCache.GetComponents<TFlag, T1, T2>(out component1, out component2);
        }

        // Overload for three components
        public void GetSingletonComponents<TFlag, T1, T2, T3>(
            out T1 component1,
            out T2 component2,
            out T3 component3
        )
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            singletonCache.GetComponents<TFlag, T1, T2, T3>(
                out component1,
                out component2,
                out component3
            );
        }

        #endregion

        #region Update System
        public void Update()
        {
            ProcessPendingCreations();
            ProcessPendingDestructions();
        }

        private void ProcessPendingCreations()
        {
            if (creationBatchSize == 0)
                return;

            var entitiesToUpdate = new List<int>();
            var processCount = Math.Min(OPERATIONS_PER_FRAME, creationBatchSize);

            for (int i = 0; i < processCount; i++)
            {
                if (pendingCreations.Count == 0)
                    break;

                var (template, modifier) = pendingCreations.Dequeue();
                int entityId = CreateEntityFromTemplate(template);

                modifier?.Invoke(entityId);
                entitiesToUpdate.Add(entityId);
            }

            if (entitiesToUpdate.Count > 0)
            {
                UpdateEntities(entitiesToUpdate);
                creationBatchSize -= entitiesToUpdate.Count;
            }
        }

        private void ProcessPendingDestructions()
        {
            int processCount = Math.Min(OPERATIONS_PER_FRAME, pendingDestructions.Count);
            bool anyProcessed = false;

            for (int i = 0; i < processCount; i++)
            {
                if (pendingDestructions.Count == 0)
                    break;

                int entityId = pendingDestructions.Dequeue();
                markedForDestruction.Remove(entityId);

                if (entityArchetypes.TryGetValue(entityId, out var archetype))
                {
                    archetype.RemoveEntity(entityId);
                    entityArchetypes.Remove(entityId);
                    pendingOperationCount++;
                    anyProcessed = true;
                }
            }

            if (anyProcessed)
            {
                // Add this line when entities are actually destroyed
                queryCacheManager.MarkAllDirty();
            }

            if (pendingOperationCount >= CLEANUP_THRESHOLD)
            {
                archetypeManager.CleanupEmptyArchetypes();
                pendingOperationCount = 0;
                // Add this line after cleanup
                queryCacheManager.MarkAllDirty();
            }
        }

        // Add cleanup for query cache
        public void Clear()
        {
            // Existing cleanup logic...
            queryCacheManager.MarkAllDirty();
            singletonCache.Clear();
        }

        public (int creations, int destructions) GetPendingOperationCounts() =>
            (creationBatchSize, pendingDestructions.Count);
        #endregion
    }

    public struct SingletonFlag : IComponent { }
}

================
File: ECS_Core/World.cs.meta
================
fileFormatVersion: 2
guid: 7af841868c71a4655bb50385d1c61ad1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/MusicNoteCreationSystem.cs
================
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Net;
using ECS_Core;
using UnityEngine;

public struct MusicNoteCreationSystem : ECS_Core.IGameSystem
{
    public bool AutoUpdate { get; set; }
    public ArchetypeManager ArchetypeManager { get; set; }

    public void Initialize()
    {
        AutoUpdate = false;
    }

    public void Start()
    {
        //
        MusicNoteMidiData musicNoteMidiData = MidiNoteParser.ParseFromText(
            GlobalPoint.Instance.midiContent.text
        );

        Debug.Log($"Total Notes; {musicNoteMidiData.TotalNotes}");

        var entitiesToUpdate = new List<int>();

        World.Active.GetSingletonComponents<PerfectLineTagComponent, CornerComponent>(
            out CornerComponent perfectLine
        );

        Debug.Log("Perfect Line topleft: " + perfectLine.TopLeft);

        // Calculate lane width once
        float totalWidth = perfectLine.TopRight.x - perfectLine.TopLeft.x;
        float laneWidth = totalWidth / 4;
        float halfLaneWidth = laneWidth / 2f;

        for (int i = 0; i < musicNoteMidiData.TotalNotes; i++)
        {
            int noteEntity = World.Active.CreateEntityFromTemplate("MusicNote");
            World.Active.ModifyPendingComponent(
                noteEntity,
                (ref MusicNoteComponent component) =>
                {
                    component.Duration = musicNoteMidiData.Durations[i];
                    component.PostionId = musicNoteMidiData.PositionIds[i];
                    component.TimeAppear = musicNoteMidiData.TimeAppears[i];
                }
            );

            World.Active.ModifyPendingComponent(
                noteEntity,
                (ref TransformComponent component) =>
                {
                    float spawnX =
                        perfectLine.TopLeft.x
                        + (musicNoteMidiData.PositionIds[i] * laneWidth)
                        + halfLaneWidth;

                    float spawnY =
                        perfectLine.TopLeft.y
                        + (musicNoteMidiData.TimeAppears[i] * GlobalPoint.Instance.gameSpeed)
                        + component.Size.y / 2f;

                    component.Posision = new Vector2(spawnX, spawnY);
                }
            );

            if (
                musicNoteMidiData
                    .Durations[i]
                    .IsInRange(musicNoteMidiData.MinDuration, musicNoteMidiData.MinDuration + 0.01f)
            )
            {
                World.Active.AddComponent(noteEntity, new ShortNoteTagComponent());
            }
            else if (musicNoteMidiData.Durations[i] > musicNoteMidiData.MinDuration)
            {
                World.Active.AddComponent(noteEntity, new LongNoteTagComponent());
            }

            entitiesToUpdate.Add(noteEntity);
        }

        World.Active.UpdateEntities(entitiesToUpdate);

        World
            .Query<MusicNoteComponent, TransformComponent>()
            .ForEach(
                World.Active,
                (
                    int entityId,
                    ref MusicNoteComponent musicNoteComponent,
                    ref TransformComponent transformComponent
                ) =>
                {
                    Debug.Log("entityId: " + entityId);
                }
            );
    }

    public void Update()
    {
        //
    }

    public void Cleanup()
    {
        //
    }
}

================
File: Systems/MusicNoteCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: c6c60a0f2af5b40aa9ceefcab19fa1d3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent.meta
================
fileFormatVersion: 2
guid: 401cb534838cf40049f69183b5206b9c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DTO.meta
================
fileFormatVersion: 2
guid: c3e7f3ef03f524e6089d969eb175e299
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core.meta
================
fileFormatVersion: 2
guid: 6f382772a4026489083a300b3daf4d8e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: GlobalPoint.cs
================
using System;
using System.Collections.Generic;
using ECS_Core;
using UnityEngine;

public class GlobalPoint : PersistentSingleton<GlobalPoint>
{
    public PrefabSourceSO prefabSourceSO;
    public PerfectLineSettingSO perfectLineSettingSO;
    public TextAsset midiContent;
    public float gameSpeed;
    private World world;

    protected override void OnAwake()
    {
        base.OnAwake();

        try
        {
            InitializeECS();
            CreateTemplates();
            CreateSingletons();
            CreateEntity();
            RegisterSystems();
            SystemManager.InitializeSystems(world);
        }
        catch (Exception e)
        {
            Debug.LogError($"Failed to initialize game: {e}");
            // Handle initialization failure
        }
    }

    private void Start()
    {
        SystemManager.SystemStart();
    }

    private void Update()
    {
        SystemManager.UpdateSystems();
    }

    private void InitializeECS()
    {
        world = new World();
        World.SetActiveWorld(world);
    }

    private void RegisterSystems()
    {
        SystemManager.RegisterSystem(new MusicNoteCreationSystem());
    }

    private void CreateTemplates()
    {
        world.CreateTemplate(
            "MusicNote",
            new Dictionary<ComponentType, object>
            {
                { ComponentType.Of<MusicNoteComponent>(), new MusicNoteComponent() },
                { ComponentType.Of<TransformComponent>(), new TransformComponent() },
            }
        );
    }

    private void CreateEntity() { }

    private void CreateSingletons()
    {
        int perfectLineEntity = world.CreateEntity();
        world.AddComponent(perfectLineEntity, new SingletonFlag());
        world.AddComponent(perfectLineEntity, new PerfectLineTagComponent());
        world.AddComponent(
            perfectLineEntity,
            new CornerComponent
            {
                TopLeft = perfectLineSettingSO.TopLeft,
                TopRight = perfectLineSettingSO.TopRight,
                BottomLeft = perfectLineSettingSO.BottomLeft,
                BottomRight = perfectLineSettingSO.BottomRight,
            }
        );
        world.UpdateEntity(perfectLineEntity);
    }

    protected void OnDestroy()
    {
        SystemManager.Clear();
    }
}

================
File: GlobalPoint.cs.meta
================
fileFormatVersion: 2
guid: 0240696fe8e234e4d9147334f546a78e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MidiNoteParser.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

public static class MidiNoteParser
{
    public static MusicNoteMidiData ParseFromText(string content)
    {
        if (string.IsNullOrEmpty(content))
            throw new MidiParseException("MIDI content cannot be empty");

        var entries = content.Split(',', StringSplitOptions.RemoveEmptyEntries);
        if (entries.Length == 0)
            throw new MidiParseException("No valid MIDI entries found");

        // Split into note entries
        var data = new MusicNoteMidiData(entries.Length);

        for (int i = 0; i < entries.Length; i++)
        {
            try
            {
                ParseEntry(entries[i], i, ref data);
                data.TotalNotes++;
            }
            catch (Exception ex)
            {
                throw new MidiParseException($"Error parsing entry {i}: {ex.Message}");
            }
        }

        ValidateData(ref data);

        return data;
    }

    private static void ParseEntry(string entry, int index, ref MusicNoteMidiData data)
    {
        var properties = entry.Split('-');
        var requiredFields = new HashSet<string> { "id", "n", "ta", "ts", "d", "v", "pid" };
        var parsedFields = new HashSet<string>();

        foreach (var prop in properties)
        {
            var kv = prop.Split(':');
            if (kv.Length != 2)
                throw new MidiParseException($"Invalid property format: {prop}");

            if (!ParseProperty(kv[0], kv[1], index, ref data))
                throw new MidiParseException($"Failed to parse property: {kv[0]}");

            parsedFields.Add(kv[0]);
        }

        // Check for missing required fields
        requiredFields.ExceptWith(parsedFields);
        if (requiredFields.Count > 0)
            throw new MidiParseException(
                $"Missing required fields: {string.Join(", ", requiredFields)}"
            );
    }

    private static bool ParseProperty(
        string key,
        string value,
        int index,
        ref MusicNoteMidiData data
    )
    {
        try
        {
            switch (key)
            {
                case "id":
                    data.Ids[index] = int.Parse(value);
                    break;
                case "n":
                    data.NoteNumbers[index] = int.Parse(value);
                    break;
                case "ta":
                    data.TimeAppears[index] = float.Parse(value);
                    break;
                case "ts":
                    data.Timespans[index] = float.Parse(value);
                    break;
                case "d":
                    float duration = float.Parse(value);
                    data.Durations[index] = duration;
                    data.MinDuration = Mathf.Min(data.MinDuration, duration);
                    break;
                case "v":
                    data.Velocities[index] = float.Parse(value);
                    break;
                case "pid":
                    data.PositionIds[index] = int.Parse(value);
                    break;
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static void ValidateData(ref MusicNoteMidiData data)
    {
        if (data.MinDuration <= 0)
            throw new MidiParseException("Invalid minimum duration");

        if (data.TotalNotes <= 0)
            throw new MidiParseException("No valid notes parsed");
    }
}

public class MidiParseException : Exception
{
    public MidiParseException(string message)
        : base(message) { }
}

================
File: MidiNoteParser.cs.meta
================
fileFormatVersion: 2
guid: ccd8b8d0c202c4c46a3c94a768d54c37
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: PrefabSourceSO.cs
================
using UnityEngine;

[CreateAssetMenu(fileName = "Prefab Source", menuName = "Setting/PrefabSource")]
public class PrefabSourceSO : ScriptableObject
{
    public GameObject longTilePrefab;
    public GameObject shortTilePrefab;
}

================
File: PrefabSourceSO.cs.meta
================
fileFormatVersion: 2
guid: 4af6165a650c8884eab1106c52392163
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: SceneObjectSpawner.cs
================
using UnityEngine;

public class SceneObjectSpawner { }

================
File: SceneObjectSpawner.cs.meta
================
fileFormatVersion: 2
guid: fc9c6f76a2c5e3e429da077f4c6b84fb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems.meta
================
fileFormatVersion: 2
guid: 17861d9c20e3049fe97ef4d578457076
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
