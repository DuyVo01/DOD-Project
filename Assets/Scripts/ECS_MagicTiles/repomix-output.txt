This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-01T04:19:28.976Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
ECS_Principled.meta
ECS_Principled/Core.meta
ECS_Principled/Core/Archetype.cs
ECS_Principled/Core/Archetype.cs.meta
ECS_Principled/Core/ArchetypeStorage.cs
ECS_Principled/Core/ArchetypeStorage.cs.meta
ECS_Principled/Core/ArchetypeSyncer.cs
ECS_Principled/Core/ArchetypeSyncer.cs.meta
ECS_Principled/Core/ComponentType.cs
ECS_Principled/Core/ComponentType.cs.meta
ECS_Principled/Core/EntityIdHolder.cs
ECS_Principled/Core/EntityIdHolder.cs.meta
ECS_Principled/Core/EntityViewFactory.cs
ECS_Principled/Core/EntityViewFactory.cs.meta
ECS_Principled/Core/GlobalPoint.cs
ECS_Principled/Core/GlobalPoint.cs.meta
ECS_Principled/Core/IComponent.cs
ECS_Principled/Core/IComponent.cs.meta
ECS_Principled/Core/IEntityHolder.cs
ECS_Principled/Core/IEntityHolder.cs.meta
ECS_Principled/Core/IGameSystem.cs
ECS_Principled/Core/IGameSystem.cs.meta
ECS_Principled/Core/StorageManager.cs
ECS_Principled/Core/StorageManager.cs.meta
ECS_Principled/Core/SystemRegistry.cs
ECS_Principled/Core/SystemRegistry.cs.meta
ECS_Principled/Core/World.cs
ECS_Principled/Core/World.cs.meta
ECS_Principled/DataComponents.meta
ECS_Principled/DataComponents/ActiveStateComponent.cs
ECS_Principled/DataComponents/ActiveStateComponent.cs.meta
ECS_Principled/DataComponents/CornerComponent.cs
ECS_Principled/DataComponents/CornerComponent.cs.meta
ECS_Principled/DataComponents/InputStateComponent.cs
ECS_Principled/DataComponents/InputStateComponent.cs.meta
ECS_Principled/DataComponents/LongNoteTagComponent.cs
ECS_Principled/DataComponents/LongNoteTagComponent.cs.meta
ECS_Principled/DataComponents/MusicNoteComponent.cs
ECS_Principled/DataComponents/MusicNoteComponent.cs.meta
ECS_Principled/DataComponents/MusicNoteFillerComponent.cs
ECS_Principled/DataComponents/MusicNoteFillerComponent.cs.meta
ECS_Principled/DataComponents/MusicNoteInteractionComponent.cs
ECS_Principled/DataComponents/MusicNoteInteractionComponent.cs.meta
ECS_Principled/DataComponents/PerfectLineTagComponent.cs
ECS_Principled/DataComponents/PerfectLineTagComponent.cs.meta
ECS_Principled/DataComponents/ShortNoteTagComponent.cs
ECS_Principled/DataComponents/ShortNoteTagComponent.cs.meta
ECS_Principled/DataComponents/StartingNoteTagComponent.cs
ECS_Principled/DataComponents/StartingNoteTagComponent.cs.meta
ECS_Principled/DataComponents/TransformComponent.cs
ECS_Principled/DataComponents/TransformComponent.cs.meta
ECS_Principled/DTO.meta
ECS_Principled/DTO/MusicNoteMidiData.cs
ECS_Principled/DTO/MusicNoteMidiData.cs.meta
ECS_Principled/EGameState.cs
ECS_Principled/EGameState.cs.meta
ECS_Principled/EventChannels.meta
ECS_Principled/EventChannels/EntityIdChannel.asset
ECS_Principled/EventChannels/EntityIdChannel.asset.meta
ECS_Principled/EventChannels/IntEventChannel.cs
ECS_Principled/EventChannels/IntEventChannel.cs.meta
ECS_Principled/MonoScripts.meta
ECS_Principled/MonoScripts/RaycastToObjects.cs
ECS_Principled/MonoScripts/RaycastToObjects.cs.meta
ECS_Principled/repomix-output.txt
ECS_Principled/repomix-output.txt.meta
ECS_Principled/Settings.meta
ECS_Principled/Settings/GeneralGameSetting_SO.asset
ECS_Principled/Settings/GeneralGameSetting_SO.asset.meta
ECS_Principled/Settings/GeneralGameSetting.cs
ECS_Principled/Settings/GeneralGameSetting.cs.meta
ECS_Principled/Settings/MidiNoteParser.cs
ECS_Principled/Settings/MidiNoteParser.cs.meta
ECS_Principled/Settings/MusicNoteCreationSetting_SO.asset
ECS_Principled/Settings/MusicNoteCreationSetting_SO.asset.meta
ECS_Principled/Settings/MusicNoteCreationSetting.cs
ECS_Principled/Settings/MusicNoteCreationSetting.cs.meta
ECS_Principled/Syncers.meta
ECS_Principled/Syncers/MusicNoteSyncer.cs
ECS_Principled/Syncers/MusicNoteSyncer.cs.meta
ECS_Principled/Syncers/StartingNoteSyncer.cs
ECS_Principled/Syncers/StartingNoteSyncer.cs.meta
ECS_Principled/Systems.meta
ECS_Principled/Systems/GameStateSystem.cs
ECS_Principled/Systems/GameStateSystem.cs.meta
ECS_Principled/Systems/InputCollisionSystem.cs
ECS_Principled/Systems/InputCollisionSystem.cs.meta
ECS_Principled/Systems/InputSystem.cs
ECS_Principled/Systems/InputSystem.cs.meta
ECS_Principled/Systems/MovingNoteSystem.cs
ECS_Principled/Systems/MovingNoteSystem.cs.meta
ECS_Principled/Systems/MusicNoteCreationSystem.cs
ECS_Principled/Systems/MusicNoteCreationSystem.cs.meta
ECS_Principled/Systems/SingletonCreationSystem.cs
ECS_Principled/Systems/SingletonCreationSystem.cs.meta

================================================================
Repository Files
================================================================

================
File: ECS_Principled.meta
================
fileFormatVersion: 2
guid: c7a632be4233831448c1261c82cae9ee
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core.meta
================
fileFormatVersion: 2
guid: b57c2d5fbb39b489e9c51a111e5e8e4f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/Archetype.cs
================
using System;
using System.Linq;

namespace ECS_MagicTile
{
    public class Archetype
    {
        private readonly ComponentType[] types;
        private readonly int hash;
        private readonly bool isAspect;

        public bool IsAspect => isAspect;

        private Archetype(ComponentType[] types, bool isAspect = false)
        {
            // Store types in a fixed order for consistent hashing
            this.types = types.OrderBy(t => t.Id).ToArray();
            this.hash = CalculateHash(this.types);
            this.isAspect = isAspect;
        }

        // Utility methods for archetype management
        public ReadOnlySpan<ComponentType> GetTypes() => types;

        public int GetHash() => hash;

        private static int CalculateHash(ComponentType[] types)
        {
            // Simple but effective hash calculation for fixed component combinations
            int hash = 17;
            foreach (var type in types)
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        // Game-specific archetypes
        public static class Registry
        {
            // Note archetypes
            public static readonly Archetype MusicNote =
                new(
                    new[]
                    {
                        ComponentType.Registry.Transform,
                        ComponentType.Registry.MusicNote,
                        ComponentType.Registry.Corner, // Added CornerComponent
                        ComponentType.Registry.MusicNoteInteraction,
                        ComponentType.Registry.MusicNoteFiller,
                    }
                );

            // Game setup archetypes
            public static readonly Archetype PerfectLine =
                new(new[] { ComponentType.Registry.PerfectLine, ComponentType.Registry.Corner });

            public static readonly Archetype Input = new(new[] { ComponentType.Registry.Input });
            public static readonly Archetype StartingNote =
                new(
                    new[]
                    {
                        ComponentType.Registry.Transform,
                        ComponentType.Registry.activeState,
                        ComponentType.Registry.startingNote,
                    }
                );

            // Keep track of all archetypes for initialization
            private static readonly Archetype[] AllArchetypes =
            {
                MusicNote,
                PerfectLine,
                Input,
                StartingNote,
            };

            public static ReadOnlySpan<Archetype> GetAllArchetypes() => AllArchetypes;
        }
    }
}

================
File: ECS_Principled/Core/Archetype.cs.meta
================
fileFormatVersion: 2
guid: 6a700f18bf185134ebcd378e0ebfe28f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/ArchetypeStorage.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_MagicTile
{
    public class ArchetypeStorage
    {
        // Store component arrays indexed by their ComponentType
        private readonly Dictionary<ComponentType, Array> componentArrays;
        private int[] entityIds; // Tracks which entities are in this storage
        private readonly Dictionary<int, int> entityToIndex = new Dictionary<int, int>();
        private int count; // Number of active entities

        private const int DEFAULT_CAPACITY = 64; // Starting size for our arrays
        private const float GROWTH_FACTOR = 2.0f; // How much to grow when we need more space

        public ArchetypeStorage(Archetype archetype, int initialCapacity = DEFAULT_CAPACITY)
        {
            componentArrays = new Dictionary<ComponentType, Array>();

            // Create typed arrays for each component in the archetype
            foreach (var componentType in archetype.GetTypes())
            {
                // Creates an array of the proper type with our initial capacity
                componentArrays[componentType] = Array.CreateInstance(
                    componentType.Type,
                    initialCapacity
                );
            }

            entityIds = new int[initialCapacity];

            count = 0;
        }

        // Provides type-safe access to component arrays
        public T[] GetComponents<T>()
            where T : struct
        {
            var componentType = ComponentType.Registry.GetComponentType<T>();
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {typeof(T)} not found in archetype"
                );
            }
            return (T[])array;
        }

        // Adds an entity with its components to this storage
        public void Add(int entityId, ReadOnlySpan<object> components)
        {
            // Grow arrays if needed
            if (count >= entityIds.Length)
            {
                Grow();
            }

            // Add components to their respective arrays
            int componentIndex = 0;
            foreach (var array in componentArrays.Values)
            {
                Array.Copy(new[] { components[componentIndex] }, 0, array, count, 1);
                componentIndex++;
            }

            // Track the entity
            entityIds[count] = entityId;
            entityToIndex[entityId] = count;
            count++;
        }

        // Efficiently removes an entity by swapping with the last element
        public void Remove(int entityId)
        {
            // Find the entity's index
            int index = Array.IndexOf(entityIds, entityId, 0, count);
            if (index == -1)
                return;

            // If it's not the last element, swap with the last one
            int lastIndex = count - 1;
            if (index < lastIndex)
            {
                foreach (var array in componentArrays.Values)
                {
                    Array.Copy(array, lastIndex, array, index, 1);
                }
                entityIds[index] = entityIds[lastIndex];
                entityToIndex[entityIds[lastIndex]] = index;
            }

            entityToIndex.Remove(entityId);
            count--;
        }

        private void Grow()
        {
            int newCapacity = (int)(entityIds.Length * GROWTH_FACTOR);

            // Grow all component arrays
            foreach (var kvp in componentArrays.ToList())
            {
                var oldArray = kvp.Value;
                var newArray = Array.CreateInstance(kvp.Key.Type, newCapacity);
                Array.Copy(oldArray, 0, newArray, 0, count);
                componentArrays[kvp.Key] = newArray;
            }

            // Grow entity ID array
            Array.Resize(ref entityIds, newCapacity);
        }

        // And we need to add this method to ArchetypeStorage
        public Array GetComponentArrayRaw(ComponentType componentType)
        {
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {componentType.Type.Name} not found in archetype"
                );
            }
            return array;
        }

        public int GetEntityIndex(int entityId)
        {
            return entityToIndex.TryGetValue(entityId, out int index) ? index : -1;
        }

        // Properties for accessing storage information
        public int Count => count;
        public ReadOnlySpan<int> EntityIds => new ReadOnlySpan<int>(entityIds, 0, count);
    }
}

================
File: ECS_Principled/Core/ArchetypeStorage.cs.meta
================
fileFormatVersion: 2
guid: 785407d53c9c26746adb34ba3d74b58d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/ArchetypeSyncer.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public abstract class ArchetypeSyncer : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        protected ArchetypeStorage DedicatedStorage => World.GetStorage(Archetype);
        protected abstract Archetype Archetype { get; }

        public abstract EGameState GameStateToExecute { get; }

        public void SetWorld(World world)
        {
            World = world;
        }

        public virtual void Initialize() { }

        public virtual void Update(float deltaTime) { }

        public virtual void Cleanup() { }
    }
}

================
File: ECS_Principled/Core/ArchetypeSyncer.cs.meta
================
fileFormatVersion: 2
guid: 0df86895fba8144229e53825e79322a5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/ComponentType.cs
================
using System;
using System.Collections.Generic;
using ECS_MagicTile.Components;

namespace ECS_MagicTile
{
    public readonly struct ComponentType
    {
        public readonly Type Type;
        public readonly int Id;

        // Private constructor ensures all types are created through registry
        private ComponentType(Type type, int id)
        {
            Type = type;
            Id = id;
        }

        // Static registry of all component types in our game
        public static class Registry
        {
            // Core Components
            public static readonly ComponentType Transform = new(typeof(TransformComponent), 0);
            public static readonly ComponentType MusicNote = new(typeof(MusicNoteComponent), 1);

            public static readonly ComponentType PerfectLine =
                new(typeof(PerfectLineTagComponent), 3);
            public static readonly ComponentType Corner = new(typeof(CornerComponent), 4);

            public static readonly ComponentType Input = new(typeof(InputStateComponent), 5);
            public static readonly ComponentType MusicNoteInteraction =
                new(typeof(MusicNoteInteractionComponent), 6);
            public static readonly ComponentType MusicNoteFiller =
                new(typeof(MusicNoteFillerComponent), 7);

            public static readonly ComponentType activeState = new(typeof(ActiveStateComponent), 8);
            public static readonly ComponentType startingNote =
                new(typeof(StartingNoteTagComponent), 9);

            // A lookup dictionary to quickly find ComponentType by Type
            private static readonly Dictionary<Type, ComponentType> typeToComponentType =
                new Dictionary<Type, ComponentType>
                {
                    { typeof(TransformComponent), Transform },
                    { typeof(MusicNoteComponent), MusicNote },
                    { typeof(PerfectLineTagComponent), PerfectLine },
                    { typeof(CornerComponent), Corner },
                    { typeof(InputStateComponent), Input },
                    { typeof(MusicNoteInteractionComponent), MusicNoteInteraction },
                    { typeof(MusicNoteFillerComponent), MusicNoteFiller },
                    { typeof(ActiveStateComponent), activeState },
                    { typeof(StartingNoteTagComponent), startingNote },
                };

            // This is our new generic lookup method
            public static ComponentType GetComponentType<T>()
                where T : struct
            {
                var type = typeof(T);
                if (!typeToComponentType.TryGetValue(type, out var componentType))
                {
                    throw new InvalidOperationException(
                        $"Component type {type.Name} is not registered. "
                            + "Make sure to add it to the ComponentType.Registry."
                    );
                }
                return componentType;
            }

            // The existing methods remain the same
            public static ReadOnlySpan<ComponentType> GetAllTypes() => AllTypes;

            private static readonly ComponentType[] AllTypes =
            {
                Transform,
                MusicNote,
                PerfectLine,
                Corner,
            };
        }
    }
}

================
File: ECS_Principled/Core/ComponentType.cs.meta
================
fileFormatVersion: 2
guid: 07d3246996a8eeb4ba2c5e2e4d0939c9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/EntityIdHolder.cs
================
using System.Linq;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EntityIdHolder : MonoBehaviour, IEntityHolder
    {
        public int EntityId { get; private set; }

        public void SetEntityId(int id)
        {
            EntityId = id;
            // Optional: Make the GameObject name more readable without losing the ID reference
            gameObject.name = $"{id}_{gameObject.name.Split('_').LastOrDefault() ?? "entity"}";
        }
    }
}

================
File: ECS_Principled/Core/EntityIdHolder.cs.meta
================
fileFormatVersion: 2
guid: 17dde60b87c53b14884d92c6a0f07c99

================
File: ECS_Principled/Core/EntityViewFactory.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EntityViewFactory
    {
        private readonly Dictionary<int, GameObject> entityViews = new();
        private readonly GameObject prefabSource;
        private readonly Transform viewRoot;

        public EntityViewFactory(GameObject prefabSource, Transform viewRoot)
        {
            this.prefabSource = prefabSource;
            this.viewRoot = viewRoot;
        }

        public GameObject GetOrCreateView(int entityId, string nameOnCreation = "")
        {
            if (entityViews.TryGetValue(entityId, out var existing))
            {
                return existing;
            }

            var prefab = prefabSource;

            GameObject view = GameObject.Instantiate(prefab, viewRoot);
            EntityIdHolder viewEntityIdHolder = view.AddComponent<EntityIdHolder>();
            viewEntityIdHolder.SetEntityId(entityId);
            entityViews[entityId] = view;
            return view;
        }

        public GameObject GetView(int entityId)
        {
            return entityViews.TryGetValue(entityId, out var view) ? view : null;
        }
    }
}

================
File: ECS_Principled/Core/EntityViewFactory.cs.meta
================
fileFormatVersion: 2
guid: f36c2cdebdbc74a8db63bff96d758abd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/GlobalPoint.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class GlobalPoint : MonoBehaviour
    {
        [Header("Game Settings")]
        public GeneralGameSetting generalGameSetting;

        public MusicNoteCreationSetting musicNoteCreationSettings;

        public PerfectLineSettingSO perfectLineSettingSO;

        [Header("Event Channel")]
        public IntEventChannel entityIdChannel;

        private World world;

        private void Awake()
        {
            // Initialize our ECS world
            world = new World();

            SystemRegistry.Initialize(world);
            RegisterSystems();
        }

        private void RegisterSystems()
        {
            //Singleton Creation system
            SystemRegistry.AddSystem(new SingletonCreationSystem(this));

            //Creation System
            SystemRegistry.AddSystem(
                new MusicNoteCreationSystem(musicNoteCreationSettings, generalGameSetting)
            );

            //Handling Data system
            SystemRegistry.AddSystem(new MovingNoteSystem(generalGameSetting));
            SystemRegistry.AddSystem(new InputSystem());
            SystemRegistry.AddSystem(new InputCollisionSystem(generalGameSetting));

            //Syncer systems
            SystemRegistry.AddSystem(new MusicNoteSyncer(this));
            SystemRegistry.AddSystem(new StartingNoteSyncer(this));

            //Game State system
            SystemRegistry.AddSystem(new GameStateSystem(this));
        }

        private void Update()
        {
            // Update all systems with current frame's delta time
            SystemRegistry.Update(Time.deltaTime);
        }
    }
}

================
File: ECS_Principled/Core/GlobalPoint.cs.meta
================
fileFormatVersion: 2
guid: a3234adf86578d14ca74bc8cc99f7901
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/IComponent.cs
================
namespace ECS_MagicTile
{
    public interface IComponent { }
}

================
File: ECS_Principled/Core/IComponent.cs.meta
================
fileFormatVersion: 2
guid: 5bfc30fb61b4b4792b8875b3f63c5a3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/IEntityHolder.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public interface IEntityHolder
    {
        public int EntityId { get; }

        public void SetEntityId(int id);
    }
}

================
File: ECS_Principled/Core/IEntityHolder.cs.meta
================
fileFormatVersion: 2
guid: 1049762c28d04a94da5cb9e99c65ebb4

================
File: ECS_Principled/Core/IGameSystem.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    // Interface that all our game systems will implement

    public interface IGameSystem
    {
        void SetWorld(World world);
        void Initialize(); // Called when system is first created
        void Update(float deltaTime); // Called every frame
        void Cleanup();
        bool IsEnabled { get; set; } // Controls if system should be updated
        World World { get; set; }
        EGameState GameStateToExecute { get; }
    }
}

================
File: ECS_Principled/Core/IGameSystem.cs.meta
================
fileFormatVersion: 2
guid: 38d38b21b37a3cf4dbb318fce0f3efdf

================
File: ECS_Principled/Core/StorageManager.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Manages all archetype storages in our game
    public class StorageManager
    {
        // Maps archetype hashes to their storage
        private readonly Dictionary<int, ArchetypeStorage> storages;
        private readonly Dictionary<int, List<ArchetypeStorage>> aspectStorages;

        public StorageManager()
        {
            storages = new Dictionary<int, ArchetypeStorage>();
            aspectStorages = new Dictionary<int, List<ArchetypeStorage>>();

            // First, create regular storages
            foreach (var archetype in Archetype.Registry.GetAllArchetypes())
            {
                if (!IsAspectArchetype(archetype))
                {
                    storages[archetype.GetHash()] = new ArchetypeStorage(archetype);
                }

                if (IsAspectArchetype(archetype))
                {
                    // Find all archetypes that contain these components
                    var matchingStorages = FindMatchingStorages(archetype);
                    aspectStorages[archetype.GetHash()] = matchingStorages;
                }
            }
        }

        private bool IsAspectArchetype(Archetype archetype)
        {
            // You could mark aspect archetypes explicitly, or use a naming convention,
            // or determine based on component count
            return archetype.IsAspect;
        }

        private List<ArchetypeStorage> FindMatchingStorages(Archetype aspectArchetype)
        {
            var matchingStorages = new List<ArchetypeStorage>();
            var requiredComponents = aspectArchetype.GetTypes();

            foreach (var storage in storages.Values)
            {
                // Check if this storage's archetype contains all required components
                bool matches = true;
                foreach (var component in requiredComponents)
                {
                    if (!HasComponent(storage, component))
                    {
                        matches = false;
                        break;
                    }
                }

                if (matches)
                {
                    matchingStorages.Add(storage);
                }
            }

            return matchingStorages;
        }

        // Get storage for a specific archetype
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            if (!storages.TryGetValue(archetype.GetHash(), out var storage))
            {
                throw new InvalidOperationException($"No storage found for archetype {archetype}");
            }
            return storage;
        }

        public IEnumerable<ArchetypeStorage> GetStoragesForAspect(Archetype aspectArchetype)
        {
            if (aspectStorages.TryGetValue(aspectArchetype.GetHash(), out var storageList))
            {
                return storageList;
            }
            return Array.Empty<ArchetypeStorage>();
        }

        private bool HasComponent(ArchetypeStorage storage, ComponentType componentType)
        {
            try
            {
                // We try to get the component array - if it exists, the storage has this component
                Array componentArray = storage.GetComponentArrayRaw(componentType);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}

================
File: ECS_Principled/Core/StorageManager.cs.meta
================
fileFormatVersion: 2
guid: 6e34b51edd65cc54298a958d1e7db250
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/SystemRegistry.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Our central system management class
    public static class SystemRegistry
    {
        // Store systems in order of execution priority
        private static readonly List<IGameSystem> updateSystems = new();
        private static World world;
        private static bool isInitialized;
        private static EGameState currentGameState = EGameState.WaitingToStart;

        // Initialize our registry with a world reference
        public static void Initialize(World gameWorld)
        {
            // Prevent multiple initializations
            if (isInitialized)
            {
                Debug.LogWarning("SystemRegistry already initialized!");
                return;
            }

            world = gameWorld;
            isInitialized = true;
        }

        // Allow adding systems from GlobalPoint
        public static void AddSystem(IGameSystem system)
        {
            if (!isInitialized)
            {
                Debug.LogError("SystemRegistry not initialized! Call Initialize first.");
                return;
            }

            // Provide the system with world reference and initialize it
            system.SetWorld(world);
            system.Initialize();

            updateSystems.Add(system);

            Debug.Log($"Added system: {system.GetType().Name}");
        }

        public static void Update(float deltaTime)
        {
            if (!isInitialized)
                return;

            foreach (var system in updateSystems)
            {
                if (
                    system.IsEnabled
                    && (
                        system.GameStateToExecute == currentGameState
                        || system.GameStateToExecute == EGameState.All
                    )
                )
                {
                    try
                    {
                        system.Update(deltaTime);
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error in system {system.GetType().Name}: {e}");
                    }
                }
            }
        }

        public static void Cleanup()
        {
            foreach (var system in updateSystems)
            {
                system.Cleanup();
            }

            updateSystems.Clear();
            isInitialized = false;
            world = null;
        }

        public static void SetGameState(EGameState newState)
        {
            currentGameState = newState;
        }
    }
}

================
File: ECS_Principled/Core/SystemRegistry.cs.meta
================
fileFormatVersion: 2
guid: ae3ac3479b706d64f83a41cf766e7021
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/World.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    public class World
    {
        private readonly StorageManager storageManager;
        private int nextEntityId = 1000; // Starting from 1000 to leave room for special IDs

        public World()
        {
            storageManager = new StorageManager();
        }

        // Creates an entity of a specific archetype
        private int CreateEntity()
        {
            int entityId = nextEntityId++;
            return entityId;
        }

        // Gets a specific storage for systems to use
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            return storageManager.GetStorage(archetype);
        }

        // Helper method to create and set up an entity in one go
        public int CreateEntityWithComponents(Archetype archetype, ReadOnlySpan<object> components)
        {
            int entityId = CreateEntity();
            ArchetypeStorage storage = GetStorage(archetype);
            storage.Add(entityId, components);
            return entityId;
        }
    }
}

================
File: ECS_Principled/Core/World.cs.meta
================
fileFormatVersion: 2
guid: 1df84a3b9711fcb41b790ef98664b125
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents.meta
================
fileFormatVersion: 2
guid: 401cb534838cf40049f69183b5206b9c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ActiveStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ActiveStateComponent : IComponent
    {
        public bool isActive;
    }
}

================
File: ECS_Principled/DataComponents/ActiveStateComponent.cs.meta
================
fileFormatVersion: 2
guid: a3c5cd13e343b874085a9dacaa62d089

================
File: ECS_Principled/DataComponents/CornerComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct CornerComponent : IComponent
    {
        public Vector2 TopLeft;
        public Vector2 TopRight;
        public Vector2 BottomLeft;
        public Vector2 BottomRight;
    }
}

================
File: ECS_Principled/DataComponents/CornerComponent.cs.meta
================
fileFormatVersion: 2
guid: b96e4a6c6cb604761b6ec117819be5b4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/InputStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct InputStateComponent : IComponent
    {
        public bool IsActive;
        public Vector2 Position;
        public Vector2 PreviousPosition;
        public InputState State;
        public int FrameCount;
    }
}

================
File: ECS_Principled/DataComponents/InputStateComponent.cs.meta
================
fileFormatVersion: 2
guid: 97c04fe8669d4470d94eec98d4274ef1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/LongNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct LongNoteTagComponent : IComponent { }
}

================
File: ECS_Principled/DataComponents/LongNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 58353002a3593244d8bf12e61f349c98
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/MusicNoteComponent.cs
================
using ECS_MagicTile;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteComponent : IComponent
    {
        public int PostionId;
        public float TimeAppear;
        public float Duration;
        public MusicNoteType musicNoteType;
    }
}

================
File: ECS_Principled/DataComponents/MusicNoteComponent.cs.meta
================
fileFormatVersion: 2
guid: e13eda0f52da940ceaec30f721998b78
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/MusicNoteFillerComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteFillerComponent : IComponent
    {
        public bool IsVisible;
        public float FillPercent;
    }
}

================
File: ECS_Principled/DataComponents/MusicNoteFillerComponent.cs.meta
================
fileFormatVersion: 2
guid: d7e3fc83bb7c04b7b9b06366cc8a2202
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/MusicNoteInteractionComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteInteractionComponent : IComponent
    {
        public MusicNoteInteractiveState State;
    }
}

================
File: ECS_Principled/DataComponents/MusicNoteInteractionComponent.cs.meta
================
fileFormatVersion: 2
guid: e6da2d26198754d3382d07b0e55fa2f1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/PerfectLineTagComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct PerfectLineTagComponent : IComponent
    {
        public float PerfectLineWidth;
    }
}

================
File: ECS_Principled/DataComponents/PerfectLineTagComponent.cs.meta
================
fileFormatVersion: 2
guid: e18089c9ed33d49f8b76960358f6a4d2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ShortNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ShortNoteTagComponent : IComponent { }
}

================
File: ECS_Principled/DataComponents/ShortNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 83c9ef9fdf039c843b9556bfba72a05a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/StartingNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct StartingNoteTagComponent : IComponent
    {
        public int initalLane;
    }
}

================
File: ECS_Principled/DataComponents/StartingNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 60788d363c63c884e898300f27bf2be1

================
File: ECS_Principled/DataComponents/TransformComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct TransformComponent : IComponent
    {
        public Vector2 Posision;
        public Vector2 Size;
    }
}

================
File: ECS_Principled/DataComponents/TransformComponent.cs.meta
================
fileFormatVersion: 2
guid: ff2e94255bc1f499a986a60df04d62ec
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DTO.meta
================
fileFormatVersion: 2
guid: c3e7f3ef03f524e6089d969eb175e299
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DTO/MusicNoteMidiData.cs
================
using UnityEngine;

public struct MusicNoteMidiData : IDataComponent
{
    // Core data arrays
    public int[] Ids;
    public int[] NoteNumbers;
    public int[] PositionIds;
    public float[] TimeAppears;
    public float[] Timespans;
    public float[] Durations;
    public float[] Velocities;

    // Metadata
    public int TotalNotes;
    public float MinDuration;

    public MusicNoteMidiData(int capacity)
    {
        // Preallocate arrays with specified capacity
        Ids = new int[capacity];
        NoteNumbers = new int[capacity];
        TimeAppears = new float[capacity];
        Timespans = new float[capacity];
        Durations = new float[capacity];
        Velocities = new float[capacity];
        PositionIds = new int[capacity];

        TotalNotes = 0;
        MinDuration = float.MaxValue;
    }
}

================
File: ECS_Principled/DTO/MusicNoteMidiData.cs.meta
================
fileFormatVersion: 2
guid: 0772d691d2fae418b83ddb22ddc64cc6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EGameState.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public enum EGameState
    {
        WaitingToStart,
        Ingame,
        Outro,
        All,
    }
}

================
File: ECS_Principled/EGameState.cs.meta
================
fileFormatVersion: 2
guid: ea96b7999d1692748b0c374877fef0d4

================
File: ECS_Principled/EventChannels.meta
================
fileFormatVersion: 2
guid: a808c7b858a7cf1459c4ba6cf1d5efe8
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/EntityIdChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 84c124985c8ec984998e8fd8a7792f33, type: 3}
  m_Name: EntityIdChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: ECS_Principled/EventChannels/EntityIdChannel.asset.meta
================
fileFormatVersion: 2
guid: 44439b2ecef163c4e8e6b70a713339a8
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/IntEventChannel.cs
================
using UnityEngine;

namespace EventChannel
{
    [CreateAssetMenu(fileName = "IntEventChannel", menuName = "Event Channels/Int event channel")]
    public class IntEventChannel : EventChannelSO<int> { }
}

================
File: ECS_Principled/EventChannels/IntEventChannel.cs.meta
================
fileFormatVersion: 2
guid: 84c124985c8ec984998e8fd8a7792f33

================
File: ECS_Principled/MonoScripts.meta
================
fileFormatVersion: 2
guid: eca84261f4209ea438546467839df383
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/RaycastToObjects.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class RaycastToObjects : MonoBehaviour
    {
        [SerializeField]
        private LayerMask targetLayer;

        [SerializeField]
        private IntEventChannel startNoteEntityIdChannel;

        // Update is called once per frame
        void Update()
        {
            if (Input.GetMouseButtonDown(0))
            {
                FireRaycast();
            }
        }

        private void FireRaycast()
        {
            Vector2 mousePosition = Camera.main.ScreenToWorldPoint(Input.mousePosition);
            RaycastHit2D hit = Physics2D.Raycast(
                mousePosition,
                Vector2.zero,
                Mathf.Infinity,
                targetLayer
            );

            if (hit.collider != null)
            {
                if (hit.collider.tag == "StartNote")
                {
                    startNoteEntityIdChannel?.RaiseEvent(
                        hit.collider.GetComponent<IEntityHolder>().EntityId
                    );
                }
            }
            else
            {
                Debug.Log("No object hit.");
            }
        }
    }
}

================
File: ECS_Principled/MonoScripts/RaycastToObjects.cs.meta
================
fileFormatVersion: 2
guid: 2b6518ec189777e4cbad7fdd60b44c76

================
File: ECS_Principled/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-31T11:35:19.296Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
Core.meta
Core/Archetype.cs
Core/Archetype.cs.meta
Core/ArchetypeStorage.cs
Core/ArchetypeStorage.cs.meta
Core/ArchetypeSyncer.cs
Core/ArchetypeSyncer.cs.meta
Core/ComponentType.cs
Core/ComponentType.cs.meta
Core/EntityViewFactory.cs
Core/EntityViewFactory.cs.meta
Core/GlobalPoint.cs
Core/GlobalPoint.cs.meta
Core/IComponent.cs
Core/IComponent.cs.meta
Core/IGameSystem.cs
Core/IGameSystem.cs.meta
Core/StorageManager.cs
Core/StorageManager.cs.meta
Core/SystemRegistry.cs
Core/SystemRegistry.cs.meta
Core/World.cs
Core/World.cs.meta
DataComponents.meta
DataComponents/ActiveStateComponent.cs
DataComponents/ActiveStateComponent.cs.meta
DataComponents/CornerComponent.cs
DataComponents/CornerComponent.cs.meta
DataComponents/InputStateComponent.cs
DataComponents/InputStateComponent.cs.meta
DataComponents/LongNoteTagComponent.cs
DataComponents/LongNoteTagComponent.cs.meta
DataComponents/MusicNoteComponent.cs
DataComponents/MusicNoteComponent.cs.meta
DataComponents/MusicNoteFillerComponent.cs
DataComponents/MusicNoteFillerComponent.cs.meta
DataComponents/MusicNoteInteractionComponent.cs
DataComponents/MusicNoteInteractionComponent.cs.meta
DataComponents/PerfectLineTagComponent.cs
DataComponents/PerfectLineTagComponent.cs.meta
DataComponents/ShortNoteTagComponent.cs
DataComponents/ShortNoteTagComponent.cs.meta
DataComponents/StartingNoteTagComponent.cs
DataComponents/StartingNoteTagComponent.cs.meta
DataComponents/TransformComponent.cs
DataComponents/TransformComponent.cs.meta
DTO.meta
DTO/MusicNoteMidiData.cs
DTO/MusicNoteMidiData.cs.meta
EGameState.cs
EGameState.cs.meta
MonoScripts.meta
MonoScripts/RaycastToObjects.cs
MonoScripts/RaycastToObjects.cs.meta
Settings.meta
Settings/GeneralGameSetting_SO.asset
Settings/GeneralGameSetting_SO.asset.meta
Settings/GeneralGameSetting.cs
Settings/GeneralGameSetting.cs.meta
Settings/MidiNoteParser.cs
Settings/MidiNoteParser.cs.meta
Settings/MusicNoteCreationSetting_SO.asset
Settings/MusicNoteCreationSetting_SO.asset.meta
Settings/MusicNoteCreationSetting.cs
Settings/MusicNoteCreationSetting.cs.meta
Settings/StartingNoteSyncer.cs
Settings/StartingNoteSyncer.cs.meta
Syncers.meta
Syncers/MusicNoteSyncer.cs
Syncers/MusicNoteSyncer.cs.meta
Systems.meta
Systems/InputCollisionSystem.cs
Systems/InputCollisionSystem.cs.meta
Systems/InputSystem.cs
Systems/InputSystem.cs.meta
Systems/MovingNoteSystem.cs
Systems/MovingNoteSystem.cs.meta
Systems/MusicNoteCreationSystem.cs
Systems/MusicNoteCreationSystem.cs.meta
Systems/SingletonCreationSystem.cs
Systems/SingletonCreationSystem.cs.meta

================================================================
Repository Files
================================================================

================
File: Core.meta
================
fileFormatVersion: 2
guid: b57c2d5fbb39b489e9c51a111e5e8e4f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/Archetype.cs
================
using System;
using System.Linq;

namespace ECS_MagicTile
{
    public class Archetype
    {
        private readonly ComponentType[] types;
        private readonly int hash;
        private readonly bool isAspect;

        public bool IsAspect => isAspect;

        private Archetype(ComponentType[] types, bool isAspect = false)
        {
            // Store types in a fixed order for consistent hashing
            this.types = types.OrderBy(t => t.Id).ToArray();
            this.hash = CalculateHash(this.types);
            this.isAspect = isAspect;
        }

        // Utility methods for archetype management
        public ReadOnlySpan<ComponentType> GetTypes() => types;

        public int GetHash() => hash;

        private static int CalculateHash(ComponentType[] types)
        {
            // Simple but effective hash calculation for fixed component combinations
            int hash = 17;
            foreach (var type in types)
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        // Game-specific archetypes
        public static class Registry
        {
            // Note archetypes
            public static readonly Archetype MusicNote =
                new(
                    new[]
                    {
                        ComponentType.Registry.Transform,
                        ComponentType.Registry.MusicNote,
                        ComponentType.Registry.Corner, // Added CornerComponent
                        ComponentType.Registry.MusicNoteInteraction,
                        ComponentType.Registry.MusicNoteFiller,
                    }
                );

            // Game setup archetypes
            public static readonly Archetype PerfectLine =
                new(new[] { ComponentType.Registry.PerfectLine, ComponentType.Registry.Corner });

            public static readonly Archetype Input = new(new[] { ComponentType.Registry.Input });
            public static readonly Archetype StartingNote =
                new(
                    new[]
                    {
                        ComponentType.Registry.Transform,
                        ComponentType.Registry.activeState,
                        ComponentType.Registry.startingNote,
                    }
                );

            // Keep track of all archetypes for initialization
            private static readonly Archetype[] AllArchetypes =
            {
                MusicNote,
                PerfectLine,
                Input,
                StartingNote,
            };

            public static ReadOnlySpan<Archetype> GetAllArchetypes() => AllArchetypes;
        }
    }
}

================
File: Core/Archetype.cs.meta
================
fileFormatVersion: 2
guid: 6a700f18bf185134ebcd378e0ebfe28f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/ArchetypeStorage.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_MagicTile
{
    public class ArchetypeStorage
    {
        // Store component arrays indexed by their ComponentType
        private readonly Dictionary<ComponentType, Array> componentArrays;
        private int[] entityIds; // Tracks which entities are in this storage
        private int count; // Number of active entities

        private const int DEFAULT_CAPACITY = 64; // Starting size for our arrays
        private const float GROWTH_FACTOR = 2.0f; // How much to grow when we need more space

        public ArchetypeStorage(Archetype archetype, int initialCapacity = DEFAULT_CAPACITY)
        {
            componentArrays = new Dictionary<ComponentType, Array>();

            // Create typed arrays for each component in the archetype
            foreach (var componentType in archetype.GetTypes())
            {
                // Creates an array of the proper type with our initial capacity
                componentArrays[componentType] = Array.CreateInstance(
                    componentType.Type,
                    initialCapacity
                );
            }

            entityIds = new int[initialCapacity];
            count = 0;
        }

        // Provides type-safe access to component arrays
        public T[] GetComponents<T>()
            where T : struct
        {
            var componentType = ComponentType.Registry.GetComponentType<T>();
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {typeof(T)} not found in archetype"
                );
            }
            return (T[])array;
        }

        // Adds an entity with its components to this storage
        public void Add(int entityId, ReadOnlySpan<object> components)
        {
            // Grow arrays if needed
            if (count >= entityIds.Length)
            {
                Grow();
            }

            // Add components to their respective arrays
            int componentIndex = 0;
            foreach (var array in componentArrays.Values)
            {
                Array.Copy(new[] { components[componentIndex] }, 0, array, count, 1);
                componentIndex++;
            }

            // Track the entity
            entityIds[count] = entityId;
            count++;
        }

        // Efficiently removes an entity by swapping with the last element
        public void Remove(int entityId)
        {
            // Find the entity's index
            int index = Array.IndexOf(entityIds, entityId, 0, count);
            if (index == -1)
                return;

            // If it's not the last element, swap with the last one
            int lastIndex = count - 1;
            if (index < lastIndex)
            {
                foreach (var array in componentArrays.Values)
                {
                    Array.Copy(array, lastIndex, array, index, 1);
                }
                entityIds[index] = entityIds[lastIndex];
            }

            count--;
        }

        private void Grow()
        {
            int newCapacity = (int)(entityIds.Length * GROWTH_FACTOR);

            // Grow all component arrays
            foreach (var kvp in componentArrays.ToList())
            {
                var oldArray = kvp.Value;
                var newArray = Array.CreateInstance(kvp.Key.Type, newCapacity);
                Array.Copy(oldArray, 0, newArray, 0, count);
                componentArrays[kvp.Key] = newArray;
            }

            // Grow entity ID array
            Array.Resize(ref entityIds, newCapacity);
        }

        // And we need to add this method to ArchetypeStorage
        public Array GetComponentArrayRaw(ComponentType componentType)
        {
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {componentType.Type.Name} not found in archetype"
                );
            }
            return array;
        }

        // Properties for accessing storage information
        public int Count => count;
        public ReadOnlySpan<int> EntityIds => new ReadOnlySpan<int>(entityIds, 0, count);
    }
}

================
File: Core/ArchetypeStorage.cs.meta
================
fileFormatVersion: 2
guid: 785407d53c9c26746adb34ba3d74b58d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/ArchetypeSyncer.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public abstract class ArchetypeSyncer : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        protected ArchetypeStorage DedicatedStorage => World.GetStorage(Archetype);
        protected abstract Archetype Archetype { get; }

        public abstract EGameState GameStateToExecute { get; }

        public void SetWorld(World world)
        {
            World = world;
        }

        public virtual void Initialize() { }

        public virtual void Update(float deltaTime) { }

        public virtual void Cleanup() { }
    }
}

================
File: Core/ArchetypeSyncer.cs.meta
================
fileFormatVersion: 2
guid: 0df86895fba8144229e53825e79322a5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/ComponentType.cs
================
using System;
using System.Collections.Generic;
using ECS_MagicTile.Components;

namespace ECS_MagicTile
{
    public readonly struct ComponentType
    {
        public readonly Type Type;
        public readonly int Id;

        // Private constructor ensures all types are created through registry
        private ComponentType(Type type, int id)
        {
            Type = type;
            Id = id;
        }

        // Static registry of all component types in our game
        public static class Registry
        {
            // Core Components
            public static readonly ComponentType Transform = new(typeof(TransformComponent), 0);
            public static readonly ComponentType MusicNote = new(typeof(MusicNoteComponent), 1);

            public static readonly ComponentType PerfectLine =
                new(typeof(PerfectLineTagComponent), 3);
            public static readonly ComponentType Corner = new(typeof(CornerComponent), 4);

            public static readonly ComponentType Input = new(typeof(InputStateComponent), 5);
            public static readonly ComponentType MusicNoteInteraction =
                new(typeof(MusicNoteInteractionComponent), 6);
            public static readonly ComponentType MusicNoteFiller =
                new(typeof(MusicNoteFillerComponent), 7);

            public static readonly ComponentType activeState = new(typeof(ActiveStateComponent), 8);
            public static readonly ComponentType startingNote =
                new(typeof(StartingNoteTagComponent), 9);

            // A lookup dictionary to quickly find ComponentType by Type
            private static readonly Dictionary<Type, ComponentType> typeToComponentType =
                new Dictionary<Type, ComponentType>
                {
                    { typeof(TransformComponent), Transform },
                    { typeof(MusicNoteComponent), MusicNote },
                    { typeof(PerfectLineTagComponent), PerfectLine },
                    { typeof(CornerComponent), Corner },
                    { typeof(InputStateComponent), Input },
                    { typeof(MusicNoteInteractionComponent), MusicNoteInteraction },
                    { typeof(MusicNoteFillerComponent), MusicNoteFiller },
                    { typeof(ActiveStateComponent), activeState },
                    { typeof(StartingNoteTagComponent), startingNote },
                };

            // This is our new generic lookup method
            public static ComponentType GetComponentType<T>()
                where T : struct
            {
                var type = typeof(T);
                if (!typeToComponentType.TryGetValue(type, out var componentType))
                {
                    throw new InvalidOperationException(
                        $"Component type {type.Name} is not registered. "
                            + "Make sure to add it to the ComponentType.Registry."
                    );
                }
                return componentType;
            }

            // The existing methods remain the same
            public static ReadOnlySpan<ComponentType> GetAllTypes() => AllTypes;

            private static readonly ComponentType[] AllTypes =
            {
                Transform,
                MusicNote,
                PerfectLine,
                Corner,
            };
        }
    }
}

================
File: Core/ComponentType.cs.meta
================
fileFormatVersion: 2
guid: 07d3246996a8eeb4ba2c5e2e4d0939c9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/EntityViewFactory.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EntityViewFactory
{
    private readonly Dictionary<int, GameObject> entityViews = new();
    private readonly GameObject prefabSource;
    private readonly Transform viewRoot;

    public EntityViewFactory(GameObject prefabSource, Transform viewRoot)
    {
        this.prefabSource = prefabSource;
        this.viewRoot = viewRoot;
    }

    public GameObject GetOrCreateView(int entityId, string nameOnCreation = "")
    {
        if (entityViews.TryGetValue(entityId, out var existing))
        {
            return existing;
        }

        var prefab = prefabSource;

        var view = GameObject.Instantiate(prefab, viewRoot);
        view.name = $"{entityId}_{nameOnCreation}";
        entityViews[entityId] = view;
        return view;
    }

    public GameObject GetView(int entityId)
    {
        return entityViews.TryGetValue(entityId, out var view) ? view : null;
    }
}

================
File: Core/EntityViewFactory.cs.meta
================
fileFormatVersion: 2
guid: f36c2cdebdbc74a8db63bff96d758abd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/GlobalPoint.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class GlobalPoint : MonoBehaviour
    {
        [Header("Game Settings")]
        public GeneralGameSetting generalGameSetting;

        public MusicNoteCreationSetting musicNoteCreationSettings;

        public PerfectLineSettingSO perfectLineSettingSO;

        private World world;

        private void Awake()
        {
            // Initialize our ECS world
            world = new World();

            CreateSingletonComponent();

            SystemRegistry.Initialize(world);
            RegisterSystems();
        }

        private void RegisterSystems()
        {
            //Singleton Creation system
            SystemRegistry.AddSystem(new SingletonCreationSystem(this));

            //Creation System
            SystemRegistry.AddSystem(
                new MusicNoteCreationSystem(musicNoteCreationSettings, generalGameSetting)
            );

            //Handling Data system
            SystemRegistry.AddSystem(new MovingNoteSystem(generalGameSetting));
            SystemRegistry.AddSystem(new InputSystem());
            SystemRegistry.AddSystem(new InputCollisionSystem(generalGameSetting));

            //Syncer systems
            SystemRegistry.AddSystem(new MusicNoteSyncer(this));
            SystemRegistry.AddSystem(new StartingNoteSyncer(this));
        }

        private void CreateSingletonComponent()
        {
            //The starting note singleton
        }

        private void Update()
        {
            // Update all systems with current frame's delta time
            SystemRegistry.Update(Time.deltaTime);
        }
    }
}

================
File: Core/GlobalPoint.cs.meta
================
fileFormatVersion: 2
guid: a3234adf86578d14ca74bc8cc99f7901
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/IComponent.cs
================
namespace ECS_MagicTile
{
    public interface IComponent { }
}

================
File: Core/IComponent.cs.meta
================
fileFormatVersion: 2
guid: 5bfc30fb61b4b4792b8875b3f63c5a3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/IGameSystem.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    // Interface that all our game systems will implement

    public interface IGameSystem
    {
        void SetWorld(World world);
        void Initialize(); // Called when system is first created
        void Update(float deltaTime); // Called every frame
        void Cleanup();
        bool IsEnabled { get; set; } // Controls if system should be updated
        World World { get; set; }
        EGameState GameStateToExecute { get; }
    }
}

================
File: Core/IGameSystem.cs.meta
================
fileFormatVersion: 2
guid: 38d38b21b37a3cf4dbb318fce0f3efdf

================
File: Core/StorageManager.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Manages all archetype storages in our game
    public class StorageManager
    {
        // Maps archetype hashes to their storage
        private readonly Dictionary<int, ArchetypeStorage> storages;
        private readonly Dictionary<int, List<ArchetypeStorage>> aspectStorages;

        public StorageManager()
        {
            storages = new Dictionary<int, ArchetypeStorage>();
            aspectStorages = new Dictionary<int, List<ArchetypeStorage>>();

            // First, create regular storages
            foreach (var archetype in Archetype.Registry.GetAllArchetypes())
            {
                if (!IsAspectArchetype(archetype))
                {
                    storages[archetype.GetHash()] = new ArchetypeStorage(archetype);
                }

                if (IsAspectArchetype(archetype))
                {
                    // Find all archetypes that contain these components
                    var matchingStorages = FindMatchingStorages(archetype);
                    aspectStorages[archetype.GetHash()] = matchingStorages;
                }
            }
        }

        private bool IsAspectArchetype(Archetype archetype)
        {
            // You could mark aspect archetypes explicitly, or use a naming convention,
            // or determine based on component count
            return archetype.IsAspect;
        }

        private List<ArchetypeStorage> FindMatchingStorages(Archetype aspectArchetype)
        {
            var matchingStorages = new List<ArchetypeStorage>();
            var requiredComponents = aspectArchetype.GetTypes();

            foreach (var storage in storages.Values)
            {
                // Check if this storage's archetype contains all required components
                bool matches = true;
                foreach (var component in requiredComponents)
                {
                    if (!HasComponent(storage, component))
                    {
                        matches = false;
                        break;
                    }
                }

                if (matches)
                {
                    matchingStorages.Add(storage);
                }
            }

            return matchingStorages;
        }

        // Get storage for a specific archetype
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            if (!storages.TryGetValue(archetype.GetHash(), out var storage))
            {
                throw new InvalidOperationException($"No storage found for archetype {archetype}");
            }
            return storage;
        }

        public IEnumerable<ArchetypeStorage> GetStoragesForAspect(Archetype aspectArchetype)
        {
            if (aspectStorages.TryGetValue(aspectArchetype.GetHash(), out var storageList))
            {
                return storageList;
            }
            return Array.Empty<ArchetypeStorage>();
        }

        private bool HasComponent(ArchetypeStorage storage, ComponentType componentType)
        {
            try
            {
                // We try to get the component array - if it exists, the storage has this component
                Array componentArray = storage.GetComponentArrayRaw(componentType);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}

================
File: Core/StorageManager.cs.meta
================
fileFormatVersion: 2
guid: 6e34b51edd65cc54298a958d1e7db250
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/SystemRegistry.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Our central system management class
    public static class SystemRegistry
    {
        // Store systems in order of execution priority
        private static readonly List<IGameSystem> updateSystems = new();
        private static World world;
        private static bool isInitialized;
        private static EGameState currentGameState = EGameState.Ingame;

        // Initialize our registry with a world reference
        public static void Initialize(World gameWorld)
        {
            // Prevent multiple initializations
            if (isInitialized)
            {
                Debug.LogWarning("SystemRegistry already initialized!");
                return;
            }

            world = gameWorld;
            isInitialized = true;
        }

        // Allow adding systems from GlobalPoint
        public static void AddSystem(IGameSystem system)
        {
            if (!isInitialized)
            {
                Debug.LogError("SystemRegistry not initialized! Call Initialize first.");
                return;
            }

            // Provide the system with world reference and initialize it
            system.SetWorld(world);
            system.Initialize();

            updateSystems.Add(system);

            Debug.Log($"Added system: {system.GetType().Name}");
        }

        public static void Update(float deltaTime)
        {
            if (!isInitialized)
                return;

            foreach (var system in updateSystems)
            {
                if (
                    system.IsEnabled
                    && (
                        system.GameStateToExecute == currentGameState
                        || system.GameStateToExecute == EGameState.All
                    )
                )
                {
                    try
                    {
                        system.Update(deltaTime);
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error in system {system.GetType().Name}: {e}");
                    }
                }
            }
        }

        public static void Cleanup()
        {
            foreach (var system in updateSystems)
            {
                system.Cleanup();
            }

            updateSystems.Clear();
            isInitialized = false;
            world = null;
        }

        public static void SetGameState(EGameState newState)
        {
            currentGameState = newState;
        }
    }
}

================
File: Core/SystemRegistry.cs.meta
================
fileFormatVersion: 2
guid: ae3ac3479b706d64f83a41cf766e7021
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/World.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    public class World
    {
        private readonly StorageManager storageManager;
        private int nextEntityId = 1000; // Starting from 1000 to leave room for special IDs

        public World()
        {
            storageManager = new StorageManager();
        }

        // Creates an entity of a specific archetype
        private int CreateEntity()
        {
            int entityId = nextEntityId++;
            return entityId;
        }

        // Gets a specific storage for systems to use
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            return storageManager.GetStorage(archetype);
        }

        // Helper method to create and set up an entity in one go
        public int CreateEntityWithComponents(Archetype archetype, ReadOnlySpan<object> components)
        {
            int entityId = CreateEntity();
            ArchetypeStorage storage = GetStorage(archetype);
            storage.Add(entityId, components);
            return entityId;
        }
    }
}

================
File: Core/World.cs.meta
================
fileFormatVersion: 2
guid: 1df84a3b9711fcb41b790ef98664b125
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents.meta
================
fileFormatVersion: 2
guid: 401cb534838cf40049f69183b5206b9c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/ActiveStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ActiveStateComponent : IComponent
    {
        public bool isActive;
    }
}

================
File: DataComponents/ActiveStateComponent.cs.meta
================
fileFormatVersion: 2
guid: a3c5cd13e343b874085a9dacaa62d089

================
File: DataComponents/CornerComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct CornerComponent : IComponent
    {
        public Vector2 TopLeft;
        public Vector2 TopRight;
        public Vector2 BottomLeft;
        public Vector2 BottomRight;
    }
}

================
File: DataComponents/CornerComponent.cs.meta
================
fileFormatVersion: 2
guid: b96e4a6c6cb604761b6ec117819be5b4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/InputStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct InputStateComponent : IComponent
    {
        public bool IsActive;
        public Vector2 Position;
        public Vector2 PreviousPosition;
        public InputState State;
        public int FrameCount;
    }
}

================
File: DataComponents/InputStateComponent.cs.meta
================
fileFormatVersion: 2
guid: 97c04fe8669d4470d94eec98d4274ef1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/LongNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct LongNoteTagComponent : IComponent { }
}

================
File: DataComponents/LongNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 58353002a3593244d8bf12e61f349c98
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/MusicNoteComponent.cs
================
using ECS_MagicTile;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteComponent : IComponent
    {
        public int PostionId;
        public float TimeAppear;
        public float Duration;
        public MusicNoteType musicNoteType;
    }
}

================
File: DataComponents/MusicNoteComponent.cs.meta
================
fileFormatVersion: 2
guid: e13eda0f52da940ceaec30f721998b78
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/MusicNoteFillerComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteFillerComponent : IComponent
    {
        public bool IsVisible;
        public float FillPercent;
    }
}

================
File: DataComponents/MusicNoteFillerComponent.cs.meta
================
fileFormatVersion: 2
guid: d7e3fc83bb7c04b7b9b06366cc8a2202
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/MusicNoteInteractionComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteInteractionComponent : IComponent
    {
        public MusicNoteInteractiveState State;
    }
}

================
File: DataComponents/MusicNoteInteractionComponent.cs.meta
================
fileFormatVersion: 2
guid: e6da2d26198754d3382d07b0e55fa2f1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/PerfectLineTagComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct PerfectLineTagComponent : IComponent
    {
        public float PerfectLineWidth;
    }
}

================
File: DataComponents/PerfectLineTagComponent.cs.meta
================
fileFormatVersion: 2
guid: e18089c9ed33d49f8b76960358f6a4d2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/ShortNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ShortNoteTagComponent : IComponent { }
}

================
File: DataComponents/ShortNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 83c9ef9fdf039c843b9556bfba72a05a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/StartingNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct StartingNoteTagComponent : IComponent
    {
        public int initalLane;
    }
}

================
File: DataComponents/StartingNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 60788d363c63c884e898300f27bf2be1

================
File: DataComponents/TransformComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct TransformComponent : IComponent
    {
        public Vector2 Posision;
        public Vector2 Size;
    }
}

================
File: DataComponents/TransformComponent.cs.meta
================
fileFormatVersion: 2
guid: ff2e94255bc1f499a986a60df04d62ec
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DTO.meta
================
fileFormatVersion: 2
guid: c3e7f3ef03f524e6089d969eb175e299
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DTO/MusicNoteMidiData.cs
================
using UnityEngine;

public struct MusicNoteMidiData : IDataComponent
{
    // Core data arrays
    public int[] Ids;
    public int[] NoteNumbers;
    public int[] PositionIds;
    public float[] TimeAppears;
    public float[] Timespans;
    public float[] Durations;
    public float[] Velocities;

    // Metadata
    public int TotalNotes;
    public float MinDuration;

    public MusicNoteMidiData(int capacity)
    {
        // Preallocate arrays with specified capacity
        Ids = new int[capacity];
        NoteNumbers = new int[capacity];
        TimeAppears = new float[capacity];
        Timespans = new float[capacity];
        Durations = new float[capacity];
        Velocities = new float[capacity];
        PositionIds = new int[capacity];

        TotalNotes = 0;
        MinDuration = float.MaxValue;
    }
}

================
File: DTO/MusicNoteMidiData.cs.meta
================
fileFormatVersion: 2
guid: 0772d691d2fae418b83ddb22ddc64cc6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EGameState.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public enum EGameState
    {
        WaitingToStart,
        Ingame,
        Outro,
        All,
    }
}

================
File: EGameState.cs.meta
================
fileFormatVersion: 2
guid: ea96b7999d1692748b0c374877fef0d4

================
File: MonoScripts.meta
================
fileFormatVersion: 2
guid: eca84261f4209ea438546467839df383
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/RaycastToObjects.cs
================
using UnityEngine;

public class RaycastToObjects : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

================
File: MonoScripts/RaycastToObjects.cs.meta
================
fileFormatVersion: 2
guid: 2b6518ec189777e4cbad7fdd60b44c76

================
File: Settings.meta
================
fileFormatVersion: 2
guid: 27da12294979945e1b5cbf9800389eb4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/GeneralGameSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 24a2a689475a5aa4997e54b10cc3c33c, type: 3}
  m_Name: GeneralGameSetting_SO
  m_EditorClassIdentifier: 
  GameSpeed: 8

================
File: Settings/GeneralGameSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: cc747aeaca6f5864099880016a577e56
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/GeneralGameSetting.cs
================
using UnityEngine;

[CreateAssetMenu(fileName = "GeneralGameSetting_SO", menuName = "Settings/GeneralGameSetting")]
public class GeneralGameSetting : ScriptableObject
{
    public float GameSpeed;
}

================
File: Settings/GeneralGameSetting.cs.meta
================
fileFormatVersion: 2
guid: 24a2a689475a5aa4997e54b10cc3c33c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/MidiNoteParser.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

public static class MidiNoteParser
{
    public static MusicNoteMidiData ParseFromText(string content)
    {
        if (string.IsNullOrEmpty(content))
            throw new MidiParseException("MIDI content cannot be empty");

        var entries = content.Split(',', StringSplitOptions.RemoveEmptyEntries);
        if (entries.Length == 0)
            throw new MidiParseException("No valid MIDI entries found");

        // Split into note entries
        var data = new MusicNoteMidiData(entries.Length);

        for (int i = 0; i < entries.Length; i++)
        {
            try
            {
                ParseEntry(entries[i], i, ref data);
                data.TotalNotes++;
            }
            catch (Exception ex)
            {
                throw new MidiParseException($"Error parsing entry {i}: {ex.Message}");
            }
        }

        ValidateData(ref data);

        return data;
    }

    private static void ParseEntry(string entry, int index, ref MusicNoteMidiData data)
    {
        var properties = entry.Split('-');
        var requiredFields = new HashSet<string> { "id", "n", "ta", "ts", "d", "v", "pid" };
        var parsedFields = new HashSet<string>();

        foreach (var prop in properties)
        {
            var kv = prop.Split(':');
            if (kv.Length != 2)
                throw new MidiParseException($"Invalid property format: {prop}");

            if (!ParseProperty(kv[0], kv[1], index, ref data))
                throw new MidiParseException($"Failed to parse property: {kv[0]}");

            parsedFields.Add(kv[0]);
        }

        // Check for missing required fields
        requiredFields.ExceptWith(parsedFields);
        if (requiredFields.Count > 0)
            throw new MidiParseException(
                $"Missing required fields: {string.Join(", ", requiredFields)}"
            );
    }

    private static bool ParseProperty(
        string key,
        string value,
        int index,
        ref MusicNoteMidiData data
    )
    {
        try
        {
            switch (key)
            {
                case "id":
                    data.Ids[index] = int.Parse(value);
                    break;
                case "n":
                    data.NoteNumbers[index] = int.Parse(value);
                    break;
                case "ta":
                    data.TimeAppears[index] = float.Parse(value);
                    break;
                case "ts":
                    data.Timespans[index] = float.Parse(value);
                    break;
                case "d":
                    float duration = float.Parse(value);
                    data.Durations[index] = duration;
                    data.MinDuration = Mathf.Min(data.MinDuration, duration);
                    break;
                case "v":
                    data.Velocities[index] = float.Parse(value);
                    break;
                case "pid":
                    data.PositionIds[index] = int.Parse(value);
                    break;
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static void ValidateData(ref MusicNoteMidiData data)
    {
        if (data.MinDuration <= 0)
            throw new MidiParseException("Invalid minimum duration");

        if (data.TotalNotes <= 0)
            throw new MidiParseException("No valid notes parsed");
    }
}

public class MidiParseException : Exception
{
    public MidiParseException(string message)
        : base(message) { }
}

================
File: Settings/MidiNoteParser.cs.meta
================
fileFormatVersion: 2
guid: ccd8b8d0c202c4c46a3c94a768d54c37
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/MusicNoteCreationSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a5af8e59dd796d941989a811a2c8754b, type: 3}
  m_Name: MusicNoteCreationSetting_SO
  m_EditorClassIdentifier: 
  MidiContent: {fileID: 4900000, guid: 5651cca0434e843a4af2569038996f88, type: 3}
  ShortNoteScaleYFactor: 1.4
  LongNoteScaleYFactor: 2.5
  startingNoteLane: 0
  LongTilePrefab: {fileID: 8137537297466452066, guid: 12f1ab7db8533406285c2148378e45d8, type: 3}
  ShortTilePrefab: {fileID: 8137537297466452066, guid: 8c1c272d019a341fa8cc13b90b199606, type: 3}
  startingNotePrefab: {fileID: 8137537297466452066, guid: 8c1c272d019a341fa8cc13b90b199606, type: 3}

================
File: Settings/MusicNoteCreationSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: 5d1ed20f8d24fbd4f95a64d2f692fb66
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/MusicNoteCreationSetting.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(
        fileName = "MusicNoteCreationSetting_SO",
        menuName = "Settings/MusicNoteCreationSetting"
    )]
    public class MusicNoteCreationSetting : ScriptableObject
    {
        [Header("Song Data")]
        public TextAsset MidiContent;

        [Header("Note Configuration")]
        public float ShortNoteScaleYFactor;
        public float LongNoteScaleYFactor;
        public float startingNoteLane;

        [Header("Prefabs")]
        public GameObject LongTilePrefab;
        public GameObject ShortTilePrefab;
        public GameObject startingNotePrefab;
    }
}

================
File: Settings/MusicNoteCreationSetting.cs.meta
================
fileFormatVersion: 2
guid: a5af8e59dd796d941989a811a2c8754b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/StartingNoteSyncer.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class StartingNoteSyncer : ArchetypeSyncer
    {
        protected override Archetype Archetype => Archetype.Registry.StartingNote;

        public override EGameState GameStateToExecute => EGameState.Ingame;

        private readonly EntityViewFactory startingNoteFactory;

        public StartingNoteSyncer(GlobalPoint globalPoint)
        {
            startingNoteFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.startingNotePrefab,
                globalPoint.transform
            );
        }

        public override void Initialize()
        {
            base.Initialize();
            IsEnabled = true;

            TransformComponent startingNoteTransform =
                DedicatedStorage.GetComponents<TransformComponent>()[0];

            int entityId_ = DedicatedStorage.EntityIds[0];

            GameObject startingNoteViewObject = startingNoteFactory.GetOrCreateView(
                entityId_,
                "StartingNote"
            );

            startingNoteViewObject.transform.position = startingNoteTransform.Posision;
            startingNoteViewObject.transform.localScale = startingNoteTransform.Size;
        }
    }
}

================
File: Settings/StartingNoteSyncer.cs.meta
================
fileFormatVersion: 2
guid: c69681375b44edd44bf95aec281d01af

================
File: Syncers.meta
================
fileFormatVersion: 2
guid: 200d0ba3dc7c04ac6920253abe6c74a4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers/MusicNoteSyncer.cs
================
using System;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteSyncer : ArchetypeSyncer
    {
        protected override Archetype Archetype => Archetype.Registry.MusicNote;

        public override EGameState GameStateToExecute { get; } = EGameState.Ingame;

        private readonly EntityViewFactory shortNoteViewFactory;
        private readonly EntityViewFactory longNoteViewFactory;

        public MusicNoteSyncer(GlobalPoint globalPoint)
        {
            shortNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.ShortTilePrefab,
                globalPoint.transform
            );
            longNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.LongTilePrefab,
                globalPoint.transform
            );
        }

        public override void Initialize()
        {
            IsEnabled = true;
        }

        public override void Update(float deltaTime)
        {
            MusicNoteComponent[] notes = DedicatedStorage.GetComponents<MusicNoteComponent>();

            MusicNoteInteractionComponent[] interactions =
                DedicatedStorage.GetComponents<MusicNoteInteractionComponent>();

            MusicNoteFillerComponent[] fillers =
                DedicatedStorage.GetComponents<MusicNoteFillerComponent>();

            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];
                GameObject view;

                // Get or create appropriate view based on note type
                if (notes[i].musicNoteType == MusicNoteType.LongNote)
                {
                    view = longNoteViewFactory.GetOrCreateView(entityId, "longNote");
                }
                else
                {
                    view = shortNoteViewFactory.GetOrCreateView(entityId, "shortNote");
                }

                // Basic transform sync
                SyncEntityToView(entityId, view);

                // State sync
                SyncNoteState(view, notes[i], interactions[i], fillers[i]);
            }
        }

        protected void SyncEntityToView(int entityId, GameObject view)
        {
            TransformComponent[] transforms = DedicatedStorage.GetComponents<TransformComponent>();
            int index = Array.IndexOf(DedicatedStorage.EntityIds.ToArray(), entityId);

            if (index != -1)
            {
                view.transform.position = transforms[index].Posision;
                view.transform.localScale = transforms[index].Size;
                // Sync other visual properties specific to MusicNote
            }
        }

        private static void SyncNoteState(
            GameObject view,
            MusicNoteComponent note,
            MusicNoteInteractionComponent interaction,
            MusicNoteFillerComponent filler
        )
        {
            // Get required components from view
            var noteRenderer = view.GetComponent<SpriteRenderer>();
            var fillerObject = view.transform.Find("Filler")?.gameObject;
            var fillerRenderer = fillerObject?.GetComponent<SpriteRenderer>();

            // Update visual state based on interaction state
            switch (interaction.State)
            {
                case MusicNoteInteractiveState.Normal:
                    noteRenderer.color = Color.white; // Default state
                    break;
                case MusicNoteInteractiveState.Pressed:
                case MusicNoteInteractiveState.Hold:
                    noteRenderer.color = Color.yellow; // Active state
                    break;
                case MusicNoteInteractiveState.Completed:
                    noteRenderer.color = new Color(1, 1, 1, 0.5f); // Fade out completed notes
                    break;
            }

            // Handle long note filler
            if (
                note.musicNoteType == MusicNoteType.LongNote
                && fillerObject != null
                && fillerRenderer != null
            )
            {
                fillerObject.SetActive(filler.IsVisible);
                if (filler.IsVisible)
                {
                    // Update filler visualization
                    UpdateNoteFiller(fillerObject, fillerRenderer, filler.FillPercent);
                }
            }
        }

        private static void UpdateNoteFiller(
            GameObject fillerObj,
            SpriteRenderer fillerRenderer,
            float fillPercent
        )
        {
            // Assuming filler uses a scale-based filling mechanism
            Vector3 scale = fillerObj.transform.localScale;
            scale.y = fillPercent;

            SpriteUtility.ScaleFromPivot(fillerRenderer, scale, SpriteUtility.PivotPointXY.Bottom);

            // Optional: Color gradient based on fill percentage
            fillerRenderer.color = Color.Lerp(Color.yellow, Color.green, fillPercent);
        }
    }
}

================
File: Syncers/MusicNoteSyncer.cs.meta
================
fileFormatVersion: 2
guid: 541f4a77356ee45a381eacb214f2b6e2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems.meta
================
fileFormatVersion: 2
guid: c822eec9dba9f4d4b88020ce8c3090ef
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/InputCollisionSystem.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class InputCollisionSystem : IGameSystem
    {
        private const string LOG_PREFIX = "[Input Collision] ";
        private const int MAX_INPUTS = 2;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        private GeneralGameSetting generalGameSetting;

        public InputCollisionSystem(GeneralGameSetting generalGameSetting)
        {
            this.generalGameSetting = generalGameSetting;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize() { }

        public void Update(float deltaTime)
        {
            ArchetypeStorage inputStorage = World.GetStorage(Archetype.Registry.Input);
            ArchetypeStorage noteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            var inputStates = inputStorage.GetComponents<InputStateComponent>();
            var transforms = noteStorage.GetComponents<TransformComponent>();
            var corners = noteStorage.GetComponents<CornerComponent>();
            var interactions = noteStorage.GetComponents<MusicNoteInteractionComponent>();
            var fillers = noteStorage.GetComponents<MusicNoteFillerComponent>();
            var notes = noteStorage.GetComponents<MusicNoteComponent>();

            for (int inputIdx = 0; inputIdx < MAX_INPUTS; inputIdx++)
            {
                if (!inputStates[inputIdx].IsActive)
                    continue;

                for (int noteIdx = 0; noteIdx < noteStorage.Count; noteIdx++)
                {
                    ProcessNoteCollision(
                        noteStorage.EntityIds[noteIdx],
                        inputStates[inputIdx],
                        ref transforms[noteIdx],
                        ref corners[noteIdx],
                        ref interactions[noteIdx],
                        ref fillers[noteIdx],
                        notes[noteIdx]
                    );
                }
            }
        }

        private void ProcessNoteCollision(
            int entityId,
            InputStateComponent input,
            ref TransformComponent transform,
            ref CornerComponent corners,
            ref MusicNoteInteractionComponent interaction,
            ref MusicNoteFillerComponent filler,
            MusicNoteComponent note
        )
        {
            // Skip completed notes
            if (interaction.State == MusicNoteInteractiveState.Completed)
                return;

            bool isInsideNote = IsPointInNote(
                input.Position,
                corners.TopLeft,
                corners.TopRight,
                corners.BottomLeft,
                corners.BottomRight
            );

            if (!isInsideNote)
                return;

            ProcessNoteInteraction(
                entityId,
                input,
                ref interaction,
                ref transform,
                ref corners,
                ref filler,
                note
            );
        }

        private void ProcessNoteInteraction(
            int entityId,
            InputStateComponent input,
            ref MusicNoteInteractionComponent interaction,
            ref TransformComponent transform,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler,
            MusicNoteComponent note
        )
        {
            switch (input.State)
            {
                case InputState.JustPressed:
                    if (interaction.State == MusicNoteInteractiveState.Normal)
                    {
                        if (note.musicNoteType == MusicNoteType.ShortNote)
                        {
                            CompleteNote(ref interaction);
                        }
                        else
                        {
                            StartLongNote(input, ref interaction, ref corners, ref filler);
                        }
                    }
                    break;

                case InputState.Held:
                    if (note.musicNoteType == MusicNoteType.LongNote)
                    {
                        if (interaction.State == MusicNoteInteractiveState.Pressed)
                        {
                            interaction.State = MusicNoteInteractiveState.Hold;
                        }
                        else if (interaction.State == MusicNoteInteractiveState.Hold)
                        {
                            UpdateLongNoteFill(ref interaction, ref corners, ref filler);
                        }
                    }
                    break;

                case InputState.JustReleased:
                    if (
                        note.musicNoteType == MusicNoteType.LongNote
                        && (
                            interaction.State == MusicNoteInteractiveState.Pressed
                            || interaction.State == MusicNoteInteractiveState.Hold
                        )
                    )
                    {
                        CompleteNote(ref interaction);
                    }
                    break;
            }
        }

        private void CompleteNote(ref MusicNoteInteractionComponent interaction)
        {
            interaction.State = MusicNoteInteractiveState.Completed;
            Debug.Log($"{LOG_PREFIX} Note completed");
        }

        private void StartLongNote(
            InputStateComponent input,
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler
        )
        {
            interaction.State = MusicNoteInteractiveState.Pressed;
            filler.IsVisible = true;

            float sizeOfNote = corners.TopLeft.y - corners.BottomLeft.y;
            float fromTouchPositionToLowerOfNote = input.Position.y - corners.BottomLeft.y;
            float touchPercent = fromTouchPositionToLowerOfNote / sizeOfNote;
            filler.FillPercent = touchPercent + 0.1f;

            Debug.Log($"{LOG_PREFIX} Long note pressed");
        }

        private void UpdateLongNoteFill(
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler
        )
        {
            float noteLength = corners.TopLeft.y - corners.BottomLeft.y;
            float gameSpeed = generalGameSetting.GameSpeed;
            float fillSpeed = gameSpeed / noteLength;

            float nextFillPercent = filler.FillPercent + (fillSpeed * Time.deltaTime);
            nextFillPercent = Mathf.Min(nextFillPercent, 1f);

            filler.FillPercent = nextFillPercent;

            if (nextFillPercent >= 1f)
            {
                CompleteNote(ref interaction);
            }
        }

        private static bool IsPointInNote(
            Vector2 point,
            Vector2 topLeft,
            Vector2 topRight,
            Vector2 bottomLeft,
            Vector2 bottomRight
        )
        {
            int wn = 0; // Winding number

            Vector2[] vertices = { topLeft, topRight, bottomRight, bottomLeft };

            for (int i = 0; i < vertices.Length; i++)
            {
                Vector2 current = vertices[i];
                Vector2 next = vertices[(i + 1) % vertices.Length];

                if (current.y <= point.y)
                {
                    if (next.y > point.y && IsLeftOf(current, next, point) > 0)
                        wn++;
                }
                else
                {
                    if (next.y <= point.y && IsLeftOf(current, next, point) < 0)
                        wn--;
                }
            }

            return wn != 0;
        }

        private static float IsLeftOf(Vector2 a, Vector2 b, Vector2 point)
        {
            return (b.x - a.x) * (point.y - a.y) - (point.x - a.x) * (b.y - a.y);
        }

        public void Cleanup() { }
    }
}

================
File: Systems/InputCollisionSystem.cs.meta
================
fileFormatVersion: 2
guid: a0d38e0610e6340709395f4e4d69e409
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/InputSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class InputSystem : IGameSystem
    {
        private const int MAX_INPUTS = 2;
        private const string LOG_PREFIX = "[Input System] ";
        private bool wasMousePressed;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            // Create input entities
            for (int i = 0; i < MAX_INPUTS; i++)
            {
                var inputComponent = new InputStateComponent
                {
                    IsActive = false,
                    Position = Vector2.zero,
                    PreviousPosition = Vector2.zero,
                    State = InputState.None,
                    FrameCount = 0,
                };

                World.CreateEntityWithComponents(
                    Archetype.Registry.Input,
                    new object[] { inputComponent }
                );
            }
        }

        public void Update(float deltaTime)
        {
            ArchetypeStorage inputStorage = World.GetStorage(Archetype.Registry.Input);
            var inputStates = inputStorage.GetComponents<InputStateComponent>();

            // Update previous states
            UpdatePreviousStates(inputStates);

            // Process new input
            if (Input.touchCount > 0)
            {
                ProcessTouchInput(inputStates);
            }
            else
            {
                ProcessMouseInput(inputStates);
            }
        }

        private void UpdatePreviousStates(InputStateComponent[] inputStates)
        {
            for (int i = 0; i < MAX_INPUTS; i++)
            {
                if (inputStates[i].State == InputState.JustReleased)
                {
                    inputStates[i].State = InputState.None;
                    inputStates[i].FrameCount = 0;
                    inputStates[i].IsActive = false;
                }
                else if (inputStates[i].State == InputState.JustPressed)
                {
                    inputStates[i].State = InputState.Held;
                }
            }
        }

        private void ProcessMouseInput(InputStateComponent[] inputStates)
        {
            bool isCurrentlyPressed = Input.GetMouseButton(0);
            Vector2 worldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);

            ref var currentState = ref inputStates[0];
            InputState newState = DetermineNewInputState(isCurrentlyPressed, wasMousePressed);

            // Only update if state changed or position changed
            if (newState != currentState.State || worldPos != currentState.Position)
            {
                UpdateInputState(ref currentState, worldPos, newState);
            }

            wasMousePressed = isCurrentlyPressed;
        }

        private void ProcessTouchInput(InputStateComponent[] inputStates)
        {
            int touchCount = Mathf.Min(Input.touchCount, MAX_INPUTS);

            // Reset unused input slots
            for (int i = touchCount; i < MAX_INPUTS; i++)
            {
                if (inputStates[i].IsActive)
                {
                    inputStates[i].State = InputState.None;
                    inputStates[i].IsActive = false;
                }
            }

            // Process active touches
            for (int i = 0; i < touchCount; i++)
            {
                Touch touch = Input.GetTouch(i);
                Vector2 worldPos = Camera.main.ScreenToWorldPoint(touch.position);

                InputState newState = touch.phase switch
                {
                    TouchPhase.Began => InputState.JustPressed,
                    TouchPhase.Moved => InputState.Held,
                    TouchPhase.Stationary => InputState.Held,
                    TouchPhase.Ended => InputState.JustReleased,
                    TouchPhase.Canceled => InputState.JustReleased,
                    _ => InputState.None,
                };

                UpdateInputState(ref inputStates[i], worldPos, newState);
            }
        }

        private void UpdateInputState(
            ref InputStateComponent state,
            Vector2 position,
            InputState newState
        )
        {
            state.PreviousPosition = state.Position;
            state.Position = position;
            state.State = newState;
            state.IsActive = newState != InputState.None;

            if (newState != state.State)
            {
                state.FrameCount = 0;
            }
            state.FrameCount++;
        }

        private InputState DetermineNewInputState(bool isPressed, bool wasPressed)
        {
            if (isPressed && !wasPressed)
                return InputState.JustPressed;
            if (!isPressed && wasPressed)
                return InputState.JustReleased;
            if (isPressed)
                return InputState.Held;
            return InputState.None;
        }

        public void Cleanup()
        {
            // Nothing to cleanup for now
        }
    }
}

================
File: Systems/InputSystem.cs.meta
================
fileFormatVersion: 2
guid: 3a7c2b94a0f5a416c8d8401ea289c387
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/MovingNoteSystem.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MovingNoteSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        private readonly GeneralGameSetting generalGameSetting;

        public MovingNoteSystem(GeneralGameSetting generalGameSetting)
        {
            this.generalGameSetting = generalGameSetting;
        }

        public void Cleanup() { }

        public void Initialize() { }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            ArchetypeStorage musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            TransformComponent[] transforms = musicNoteStorage.GetComponents<TransformComponent>();
            CornerComponent[] corners = musicNoteStorage.GetComponents<CornerComponent>();

            float gameSpeed = generalGameSetting.GameSpeed;

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                // Update position
                Vector2 newPos = transforms[i].Posision;
                newPos.y -= gameSpeed * Time.deltaTime;
                transforms[i].Posision = newPos;

                // Update corners based on new position and size
                Vector2 halfSize = transforms[i].Size * 0.5f;
                corners[i].TopLeft = new Vector2(newPos.x - halfSize.x, newPos.y + halfSize.y);
                corners[i].TopRight = new Vector2(newPos.x + halfSize.x, newPos.y + halfSize.y);
                corners[i].BottomLeft = new Vector2(newPos.x - halfSize.x, newPos.y - halfSize.y);
                corners[i].BottomRight = new Vector2(newPos.x + halfSize.x, newPos.y - halfSize.y);
            }
        }
    }
}

================
File: Systems/MovingNoteSystem.cs.meta
================
fileFormatVersion: 2
guid: 23e31434417084f63bbc9efc34471f1f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/MusicNoteCreationSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteCreationSystem : IGameSystem
    {
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;
        private readonly GeneralGameSetting generalGameSetting;
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.WaitingToStart;

        public MusicNoteCreationSystem(
            MusicNoteCreationSetting musicNoteCreationSetting,
            GeneralGameSetting generalGameSetting
        )
        {
            this.musicNoteCreationSetting = musicNoteCreationSetting;
            this.generalGameSetting = generalGameSetting;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            MusicNoteMidiData musicNoteMidiData = MidiNoteParser.ParseFromText(
                musicNoteCreationSetting.MidiContent.text
            );

            ArchetypeStorage perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            ref CornerComponent perfectLineCorners =
                ref perfectLineStorage.GetComponents<CornerComponent>()[0];

            // Calculate lane width once
            float totalWidth = perfectLineCorners.TopRight.x - perfectLineCorners.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            for (int i = 0; i < musicNoteMidiData.TotalNotes; i++)
            {
                MusicNoteType musicNoteType = MusicNoteType.ShortNote;
                if (musicNoteMidiData.Durations[i] > musicNoteMidiData.MinDuration)
                {
                    musicNoteType = MusicNoteType.LongNote;
                }

                object[] components = new object[]
                {
                    new TransformComponent { },
                    new MusicNoteComponent
                    {
                        Duration = musicNoteMidiData.Durations[i],
                        PostionId = musicNoteMidiData.PositionIds[i],
                        TimeAppear = musicNoteMidiData.TimeAppears[i],
                        musicNoteType = musicNoteType,
                    },
                    new CornerComponent { },
                    new MusicNoteInteractionComponent { },
                    new MusicNoteFillerComponent { },
                };

                World.CreateEntityWithComponents(Archetype.Registry.MusicNote, components);
            }

            ArchetypeStorage musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            TransformComponent[] transforms = musicNoteStorage.GetComponents<TransformComponent>();
            MusicNoteComponent[] musicNotes = musicNoteStorage.GetComponents<MusicNoteComponent>();

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                float spawnX =
                    perfectLineCorners.TopLeft.x
                    + (musicNoteMidiData.PositionIds[i] * laneWidth)
                    + halfLaneWidth;

                float spawnY =
                    perfectLineCorners.TopLeft.y
                    + (musicNoteMidiData.TimeAppears[i] * generalGameSetting.GameSpeed)
                    + transforms[i].Size.y / 2f;

                transforms[i].Posision = new Vector2(spawnX, spawnY);

                float scaleX = PerfectLine.PerfectLineWidth / 4;

                float scaleY;

                if (musicNotes[i].musicNoteType == MusicNoteType.ShortNote)
                {
                    scaleY = MagicTileHelper.CalculateScaleY(
                        musicNoteCreationSetting.ShortNoteScaleYFactor,
                        scaleX
                    );
                }
                else
                {
                    scaleY = MagicTileHelper.CalculateScaleY(
                        musicNoteCreationSetting.LongNoteScaleYFactor,
                        scaleX,
                        musicNotes[i].Duration
                    );
                }

                transforms[i].Size = new Vector2(scaleX, scaleY);
            }
        }

        public void Update(float deltaTime)
        {
            //
        }

        public void Cleanup()
        {
            //
        }
    }
}

================
File: Systems/MusicNoteCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: 27223b00486847b4b86f21b0b74f2e53
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/SingletonCreationSystem.cs
================
using ECS_MagicTile.Components;
using UnityEditor.Tilemaps;
using UnityEngine;

namespace ECS_MagicTile
{
    public class SingletonCreationSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.WaitingToStart;

        private readonly PerfectLineSettingSO perfectLineSettingSO;
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;

        public SingletonCreationSystem(GlobalPoint globalPoint)
        {
            this.perfectLineSettingSO = globalPoint.perfectLineSettingSO;
            this.musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
        }

        public void Cleanup()
        {
            //
        }

        public void Initialize()
        {
            CreatePerfectLine();
            CreateStartingNote();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            //
        }

        private void CreatePerfectLine()
        {
            //The perfect line singleton
            var components = new object[] { new PerfectLineTagComponent(), new CornerComponent() };
            World.CreateEntityWithComponents(Archetype.Registry.PerfectLine, components);

            ArchetypeStorage perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            ref CornerComponent perfectLineCorner =
                ref perfectLineStorage.GetComponents<CornerComponent>()[0];

            PerfectLine.PerfectLineWidth = perfectLineSettingSO.PerfectLineWidth();
            perfectLineCorner.TopLeft = perfectLineSettingSO.TopLeft;
            perfectLineCorner.TopRight = perfectLineSettingSO.TopRight;
            perfectLineCorner.BottomLeft = perfectLineSettingSO.BottomLeft;
            perfectLineCorner.BottomRight = perfectLineSettingSO.BottomRight;
        }

        private void CreateStartingNote()
        {
            var components = new object[]
            {
                new TransformComponent(),
                new ActiveStateComponent(),
                new StartingNoteTagComponent(),
            };
            World.CreateEntityWithComponents(Archetype.Registry.StartingNote, components);

            ArchetypeStorage storage = World.GetStorage(Archetype.Registry.StartingNote);
            ArchetypeStorage perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            ref ActiveStateComponent activeState =
                ref storage.GetComponents<ActiveStateComponent>()[0];
            ref TransformComponent transform = ref storage.GetComponents<TransformComponent>()[0];

            ref CornerComponent perfectLineCorners =
                ref perfectLineStorage.GetComponents<CornerComponent>()[0];

            // Calculate lane width
            float totalWidth = perfectLineCorners.TopRight.x - perfectLineCorners.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            activeState.isActive = true;

            // Calculate spawn position
            float spawnX = perfectLineCorners.TopLeft.x + (0 * laneWidth) + halfLaneWidth;
            float spawnY = perfectLineCorners.TopLeft.y;

            transform.Posision = new Vector2(spawnX, spawnY);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            float scaleX = PerfectLine.PerfectLineWidth / 4;

            float scaleY = MagicTileHelper.CalculateScaleY(
                musicNoteCreationSetting.ShortNoteScaleYFactor,
                scaleX
            );

            transform.Size = new Vector2(scaleX, scaleY);
        }
    }
}

================
File: Systems/SingletonCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: 0363a30a155e7de4492faa5045403325

================
File: ECS_Principled/repomix-output.txt.meta
================
fileFormatVersion: 2
guid: ebd497a7bf3655d4e9f41c3a4aa6e9e8
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings.meta
================
fileFormatVersion: 2
guid: 27da12294979945e1b5cbf9800389eb4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/GeneralGameSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 24a2a689475a5aa4997e54b10cc3c33c, type: 3}
  m_Name: GeneralGameSetting_SO
  m_EditorClassIdentifier: 
  GameSpeed: 8

================
File: ECS_Principled/Settings/GeneralGameSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: cc747aeaca6f5864099880016a577e56
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/GeneralGameSetting.cs
================
using UnityEngine;

[CreateAssetMenu(fileName = "GeneralGameSetting_SO", menuName = "Settings/GeneralGameSetting")]
public class GeneralGameSetting : ScriptableObject
{
    public float GameSpeed;
}

================
File: ECS_Principled/Settings/GeneralGameSetting.cs.meta
================
fileFormatVersion: 2
guid: 24a2a689475a5aa4997e54b10cc3c33c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/MidiNoteParser.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

public static class MidiNoteParser
{
    public static MusicNoteMidiData ParseFromText(string content)
    {
        if (string.IsNullOrEmpty(content))
            throw new MidiParseException("MIDI content cannot be empty");

        var entries = content.Split(',', StringSplitOptions.RemoveEmptyEntries);
        if (entries.Length == 0)
            throw new MidiParseException("No valid MIDI entries found");

        // Split into note entries
        var data = new MusicNoteMidiData(entries.Length);

        for (int i = 0; i < entries.Length; i++)
        {
            try
            {
                ParseEntry(entries[i], i, ref data);
                data.TotalNotes++;
            }
            catch (Exception ex)
            {
                throw new MidiParseException($"Error parsing entry {i}: {ex.Message}");
            }
        }

        ValidateData(ref data);

        return data;
    }

    private static void ParseEntry(string entry, int index, ref MusicNoteMidiData data)
    {
        var properties = entry.Split('-');
        var requiredFields = new HashSet<string> { "id", "n", "ta", "ts", "d", "v", "pid" };
        var parsedFields = new HashSet<string>();

        foreach (var prop in properties)
        {
            var kv = prop.Split(':');
            if (kv.Length != 2)
                throw new MidiParseException($"Invalid property format: {prop}");

            if (!ParseProperty(kv[0], kv[1], index, ref data))
                throw new MidiParseException($"Failed to parse property: {kv[0]}");

            parsedFields.Add(kv[0]);
        }

        // Check for missing required fields
        requiredFields.ExceptWith(parsedFields);
        if (requiredFields.Count > 0)
            throw new MidiParseException(
                $"Missing required fields: {string.Join(", ", requiredFields)}"
            );
    }

    private static bool ParseProperty(
        string key,
        string value,
        int index,
        ref MusicNoteMidiData data
    )
    {
        try
        {
            switch (key)
            {
                case "id":
                    data.Ids[index] = int.Parse(value);
                    break;
                case "n":
                    data.NoteNumbers[index] = int.Parse(value);
                    break;
                case "ta":
                    data.TimeAppears[index] = float.Parse(value);
                    break;
                case "ts":
                    data.Timespans[index] = float.Parse(value);
                    break;
                case "d":
                    float duration = float.Parse(value);
                    data.Durations[index] = duration;
                    data.MinDuration = Mathf.Min(data.MinDuration, duration);
                    break;
                case "v":
                    data.Velocities[index] = float.Parse(value);
                    break;
                case "pid":
                    data.PositionIds[index] = int.Parse(value);
                    break;
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static void ValidateData(ref MusicNoteMidiData data)
    {
        if (data.MinDuration <= 0)
            throw new MidiParseException("Invalid minimum duration");

        if (data.TotalNotes <= 0)
            throw new MidiParseException("No valid notes parsed");
    }
}

public class MidiParseException : Exception
{
    public MidiParseException(string message)
        : base(message) { }
}

================
File: ECS_Principled/Settings/MidiNoteParser.cs.meta
================
fileFormatVersion: 2
guid: ccd8b8d0c202c4c46a3c94a768d54c37
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/MusicNoteCreationSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a5af8e59dd796d941989a811a2c8754b, type: 3}
  m_Name: MusicNoteCreationSetting_SO
  m_EditorClassIdentifier: 
  MidiContent: {fileID: 4900000, guid: 5651cca0434e843a4af2569038996f88, type: 3}
  ShortNoteScaleYFactor: 1.4
  LongNoteScaleYFactor: 2.5
  startingNoteLane: 0
  LongTilePrefab: {fileID: 8137537297466452066, guid: 12f1ab7db8533406285c2148378e45d8, type: 3}
  ShortTilePrefab: {fileID: 8137537297466452066, guid: 8c1c272d019a341fa8cc13b90b199606, type: 3}
  startingNotePrefab: {fileID: 8137537297466452066, guid: 3ab92a42b30f7d440901bcd50afe0d58, type: 3}

================
File: ECS_Principled/Settings/MusicNoteCreationSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: 5d1ed20f8d24fbd4f95a64d2f692fb66
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/MusicNoteCreationSetting.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(
        fileName = "MusicNoteCreationSetting_SO",
        menuName = "Settings/MusicNoteCreationSetting"
    )]
    public class MusicNoteCreationSetting : ScriptableObject
    {
        [Header("Song Data")]
        public TextAsset MidiContent;

        [Header("Note Configuration")]
        public float ShortNoteScaleYFactor;
        public float LongNoteScaleYFactor;
        public float startingNoteLane;

        [Header("Prefabs")]
        public GameObject LongTilePrefab;
        public GameObject ShortTilePrefab;
        public GameObject startingNotePrefab;
    }
}

================
File: ECS_Principled/Settings/MusicNoteCreationSetting.cs.meta
================
fileFormatVersion: 2
guid: a5af8e59dd796d941989a811a2c8754b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers.meta
================
fileFormatVersion: 2
guid: 200d0ba3dc7c04ac6920253abe6c74a4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/MusicNoteSyncer.cs
================
using System;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteSyncer : ArchetypeSyncer
    {
        protected override Archetype Archetype => Archetype.Registry.MusicNote;

        public override EGameState GameStateToExecute { get; } = EGameState.Ingame;

        private readonly EntityViewFactory shortNoteViewFactory;
        private readonly EntityViewFactory longNoteViewFactory;

        // Cache component arrays to avoid getting them each frame
        private TransformComponent[] transforms;
        private MusicNoteComponent[] notes;
        private MusicNoteInteractionComponent[] interactions;
        private MusicNoteFillerComponent[] fillers;

        // Cache frequently accessed components
        private readonly Dictionary<int, SpriteRenderer> noteRenderers = new();
        private readonly Dictionary<int, (GameObject obj, SpriteRenderer renderer)> fillerCache =
            new();

        public MusicNoteSyncer(GlobalPoint globalPoint)
        {
            shortNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.ShortTilePrefab,
                globalPoint.transform
            );
            longNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.LongTilePrefab,
                globalPoint.transform
            );
        }

        public override void Initialize()
        {
            IsEnabled = true;

            // Initialize component array references
            transforms = DedicatedStorage.GetComponents<TransformComponent>();
            notes = DedicatedStorage.GetComponents<MusicNoteComponent>();
            interactions = DedicatedStorage.GetComponents<MusicNoteInteractionComponent>();
            fillers = DedicatedStorage.GetComponents<MusicNoteFillerComponent>();
        }

        public override void Update(float deltaTime)
        {
            // Process notes in batches for better cache utilization
            const int BATCH_SIZE = 64;
            int totalNotes = DedicatedStorage.Count;

            for (int batchStart = 0; batchStart < totalNotes; batchStart += BATCH_SIZE)
            {
                int batchEnd = Math.Min(batchStart + BATCH_SIZE, totalNotes);
                ProcessNoteBatch(batchStart, batchEnd);
            }
        }

        private void ProcessNoteBatch(int start, int end)
        {
            for (int i = start; i < end; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];

                // Get or create view based on note type
                GameObject view = GetOrCreateNoteView(entityId, notes[i].musicNoteType);

                view.transform.position = transforms[i].Posision;
                view.transform.localScale = transforms[i].Size;

                SyncNoteState(entityId, view, notes[i], interactions[i], fillers[i]);
            }
        }

        private GameObject GetOrCreateNoteView(int entityId, MusicNoteType noteType)
        {
            return noteType == MusicNoteType.LongNote
                ? longNoteViewFactory.GetOrCreateView(entityId, "longNote")
                : shortNoteViewFactory.GetOrCreateView(entityId, "shortNote");
        }

        private void SyncNoteState(
            int entityId,
            GameObject view,
            MusicNoteComponent note,
            MusicNoteInteractionComponent interaction,
            MusicNoteFillerComponent filler
        )
        {
            // Get cached renderer or cache it
            if (!noteRenderers.TryGetValue(entityId, out var noteRenderer))
            {
                noteRenderer = view.GetComponent<SpriteRenderer>();
                noteRenderers[entityId] = noteRenderer;
            }

            // Update note color based on state
            UpdateNoteColor(noteRenderer, interaction.State);

            // Handle long note filler
            if (note.musicNoteType == MusicNoteType.LongNote)
            {
                SyncNoteFiller(entityId, view, filler);
            }
        }

        private static void UpdateNoteColor(
            SpriteRenderer renderer,
            MusicNoteInteractiveState state
        )
        {
            renderer.color = state switch
            {
                MusicNoteInteractiveState.Normal => Color.white,
                MusicNoteInteractiveState.Pressed or MusicNoteInteractiveState.Hold => Color.yellow,
                MusicNoteInteractiveState.Completed => new Color(1, 1, 1, 0.5f),
                _ => Color.white,
            };
        }

        private void SyncNoteFiller(int entityId, GameObject view, MusicNoteFillerComponent filler)
        {
            if (!fillerCache.TryGetValue(entityId, out var fillerComponents))
            {
                var fillerObj = view.transform.Find("Filler")?.gameObject;
                if (fillerObj != null)
                {
                    fillerComponents = (fillerObj, fillerObj.GetComponent<SpriteRenderer>());
                    fillerCache[entityId] = fillerComponents;
                }
            }

            if (fillerComponents.obj != null)
            {
                fillerComponents.obj.SetActive(filler.IsVisible);
                if (filler.IsVisible)
                {
                    UpdateFillerVisuals(
                        fillerComponents.obj,
                        fillerComponents.renderer,
                        filler.FillPercent
                    );
                }
            }
        }

        private static void UpdateFillerVisuals(
            GameObject fillerObj,
            SpriteRenderer renderer,
            float fillPercent
        )
        {
            Vector3 scale = fillerObj.transform.localScale;
            scale.y = fillPercent;
            SpriteUtility.ScaleFromPivot(renderer, scale, SpriteUtility.PivotPointXY.Bottom);
            renderer.color = Color.Lerp(Color.yellow, Color.green, fillPercent);
        }
    }
}

================
File: ECS_Principled/Syncers/MusicNoteSyncer.cs.meta
================
fileFormatVersion: 2
guid: 541f4a77356ee45a381eacb214f2b6e2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/StartingNoteSyncer.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class StartingNoteSyncer : ArchetypeSyncer
    {
        protected override Archetype Archetype => Archetype.Registry.StartingNote;

        public override EGameState GameStateToExecute => EGameState.Ingame;

        private readonly EntityViewFactory startingNoteFactory;

        private GameObject startingNoteViewObject;

        public StartingNoteSyncer(GlobalPoint globalPoint)
        {
            startingNoteFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.startingNotePrefab,
                globalPoint.transform
            );
        }

        public override void Initialize()
        {
            base.Initialize();
            IsEnabled = true;

            TransformComponent startingNoteTransform =
                DedicatedStorage.GetComponents<TransformComponent>()[0];

            int entityId_ = DedicatedStorage.EntityIds[0];

            startingNoteViewObject = startingNoteFactory.GetOrCreateView(entityId_, "StartingNote");

            startingNoteViewObject.transform.position = startingNoteTransform.Posision;
            startingNoteViewObject.transform.localScale = startingNoteTransform.Size;
        }

        public override void Update(float deltaTime)
        {
            ActiveStateComponent activeStateComponent =
                DedicatedStorage.GetComponents<ActiveStateComponent>()[0];
            startingNoteViewObject.SetActive(activeStateComponent.isActive);
        }
    }
}

================
File: ECS_Principled/Syncers/StartingNoteSyncer.cs.meta
================
fileFormatVersion: 2
guid: c69681375b44edd44bf95aec281d01af

================
File: ECS_Principled/Systems.meta
================
fileFormatVersion: 2
guid: c822eec9dba9f4d4b88020ce8c3090ef
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/GameStateSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class GameStateSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.All;

        private readonly IntEventChannel startNoteEntityIdChannel;

        public GameStateSystem(GlobalPoint globalPoint)
        {
            startNoteEntityIdChannel = globalPoint.entityIdChannel;
        }

        public void Cleanup()
        {
            //
        }

        public void Initialize()
        {
            startNoteEntityIdChannel.Subscribe(OnStartNoteInteraction);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            //
        }

        private void OnStartNoteInteraction(int startNoteId)
        {
            ArchetypeStorage storage = World.GetStorage(Archetype.Registry.StartingNote);
            storage.GetComponents<ActiveStateComponent>()[0].isActive = false;
            SystemRegistry.SetGameState(EGameState.Ingame);
        }
    }
}

================
File: ECS_Principled/Systems/GameStateSystem.cs.meta
================
fileFormatVersion: 2
guid: 01ad329a4e8ba17448b524ad53b02f01

================
File: ECS_Principled/Systems/InputCollisionSystem.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class InputCollisionSystem : IGameSystem
    {
        private const string LOG_PREFIX = "[Input Collision] ";
        private const int MAX_INPUTS = 2;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        private GeneralGameSetting generalGameSetting;

        public InputCollisionSystem(GeneralGameSetting generalGameSetting)
        {
            this.generalGameSetting = generalGameSetting;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize() { }

        public void Update(float deltaTime)
        {
            ArchetypeStorage inputStorage = World.GetStorage(Archetype.Registry.Input);
            ArchetypeStorage noteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            var inputStates = inputStorage.GetComponents<InputStateComponent>();
            var transforms = noteStorage.GetComponents<TransformComponent>();
            var corners = noteStorage.GetComponents<CornerComponent>();
            var interactions = noteStorage.GetComponents<MusicNoteInteractionComponent>();
            var fillers = noteStorage.GetComponents<MusicNoteFillerComponent>();
            var notes = noteStorage.GetComponents<MusicNoteComponent>();

            for (int inputIdx = 0; inputIdx < MAX_INPUTS; inputIdx++)
            {
                if (!inputStates[inputIdx].IsActive)
                    continue;

                for (int noteIdx = 0; noteIdx < noteStorage.Count; noteIdx++)
                {
                    ProcessNoteCollision(
                        noteStorage.EntityIds[noteIdx],
                        inputStates[inputIdx],
                        ref transforms[noteIdx],
                        ref corners[noteIdx],
                        ref interactions[noteIdx],
                        ref fillers[noteIdx],
                        notes[noteIdx]
                    );
                }
            }
        }

        private void ProcessNoteCollision(
            int entityId,
            InputStateComponent input,
            ref TransformComponent transform,
            ref CornerComponent corners,
            ref MusicNoteInteractionComponent interaction,
            ref MusicNoteFillerComponent filler,
            MusicNoteComponent note
        )
        {
            // Skip completed notes
            if (interaction.State == MusicNoteInteractiveState.Completed)
                return;

            bool isInsideNote = IsPointInNote(
                input.Position,
                corners.TopLeft,
                corners.TopRight,
                corners.BottomLeft,
                corners.BottomRight
            );

            if (!isInsideNote)
                return;

            ProcessNoteInteraction(
                entityId,
                input,
                ref interaction,
                ref transform,
                ref corners,
                ref filler,
                note
            );
        }

        private void ProcessNoteInteraction(
            int entityId,
            InputStateComponent input,
            ref MusicNoteInteractionComponent interaction,
            ref TransformComponent transform,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler,
            MusicNoteComponent note
        )
        {
            switch (input.State)
            {
                case InputState.JustPressed:
                    if (interaction.State == MusicNoteInteractiveState.Normal)
                    {
                        if (note.musicNoteType == MusicNoteType.ShortNote)
                        {
                            CompleteNote(ref interaction);
                        }
                        else
                        {
                            StartLongNote(input, ref interaction, ref corners, ref filler);
                        }
                    }
                    break;

                case InputState.Held:
                    if (note.musicNoteType == MusicNoteType.LongNote)
                    {
                        if (interaction.State == MusicNoteInteractiveState.Pressed)
                        {
                            interaction.State = MusicNoteInteractiveState.Hold;
                        }
                        else if (interaction.State == MusicNoteInteractiveState.Hold)
                        {
                            UpdateLongNoteFill(ref interaction, ref corners, ref filler);
                        }
                    }
                    break;

                case InputState.JustReleased:
                    if (
                        note.musicNoteType == MusicNoteType.LongNote
                        && (
                            interaction.State == MusicNoteInteractiveState.Pressed
                            || interaction.State == MusicNoteInteractiveState.Hold
                        )
                    )
                    {
                        CompleteNote(ref interaction);
                    }
                    break;
            }
        }

        private void CompleteNote(ref MusicNoteInteractionComponent interaction)
        {
            interaction.State = MusicNoteInteractiveState.Completed;
            Debug.Log($"{LOG_PREFIX} Note completed");
        }

        private void StartLongNote(
            InputStateComponent input,
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler
        )
        {
            interaction.State = MusicNoteInteractiveState.Pressed;
            filler.IsVisible = true;

            float sizeOfNote = corners.TopLeft.y - corners.BottomLeft.y;
            float fromTouchPositionToLowerOfNote = input.Position.y - corners.BottomLeft.y;
            float touchPercent = fromTouchPositionToLowerOfNote / sizeOfNote;
            filler.FillPercent = touchPercent + 0.1f;

            Debug.Log($"{LOG_PREFIX} Long note pressed");
        }

        private void UpdateLongNoteFill(
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler
        )
        {
            float noteLength = corners.TopLeft.y - corners.BottomLeft.y;
            float gameSpeed = generalGameSetting.GameSpeed;
            float fillSpeed = gameSpeed / noteLength;

            float nextFillPercent = filler.FillPercent + (fillSpeed * Time.deltaTime);
            nextFillPercent = Mathf.Min(nextFillPercent, 1f);

            filler.FillPercent = nextFillPercent;

            if (nextFillPercent >= 1f)
            {
                CompleteNote(ref interaction);
            }
        }

        private static bool IsPointInNote(
            Vector2 point,
            Vector2 topLeft,
            Vector2 topRight,
            Vector2 bottomLeft,
            Vector2 bottomRight
        )
        {
            int wn = 0; // Winding number

            Vector2[] vertices = { topLeft, topRight, bottomRight, bottomLeft };

            for (int i = 0; i < vertices.Length; i++)
            {
                Vector2 current = vertices[i];
                Vector2 next = vertices[(i + 1) % vertices.Length];

                if (current.y <= point.y)
                {
                    if (next.y > point.y && IsLeftOf(current, next, point) > 0)
                        wn++;
                }
                else
                {
                    if (next.y <= point.y && IsLeftOf(current, next, point) < 0)
                        wn--;
                }
            }

            return wn != 0;
        }

        private static float IsLeftOf(Vector2 a, Vector2 b, Vector2 point)
        {
            return (b.x - a.x) * (point.y - a.y) - (point.x - a.x) * (b.y - a.y);
        }

        public void Cleanup() { }
    }
}

================
File: ECS_Principled/Systems/InputCollisionSystem.cs.meta
================
fileFormatVersion: 2
guid: a0d38e0610e6340709395f4e4d69e409
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/InputSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class InputSystem : IGameSystem
    {
        private const int MAX_INPUTS = 2;
        private const string LOG_PREFIX = "[Input System] ";
        private bool wasMousePressed;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            // Create input entities
            for (int i = 0; i < MAX_INPUTS; i++)
            {
                var inputComponent = new InputStateComponent
                {
                    IsActive = false,
                    Position = Vector2.zero,
                    PreviousPosition = Vector2.zero,
                    State = InputState.None,
                    FrameCount = 0,
                };

                World.CreateEntityWithComponents(
                    Archetype.Registry.Input,
                    new object[] { inputComponent }
                );
            }
        }

        public void Update(float deltaTime)
        {
            ArchetypeStorage inputStorage = World.GetStorage(Archetype.Registry.Input);
            var inputStates = inputStorage.GetComponents<InputStateComponent>();

            // Update previous states
            UpdatePreviousStates(inputStates);

            // Process new input
            if (Input.touchCount > 0)
            {
                ProcessTouchInput(inputStates);
            }
            else
            {
                ProcessMouseInput(inputStates);
            }
        }

        private void UpdatePreviousStates(InputStateComponent[] inputStates)
        {
            for (int i = 0; i < MAX_INPUTS; i++)
            {
                if (inputStates[i].State == InputState.JustReleased)
                {
                    inputStates[i].State = InputState.None;
                    inputStates[i].FrameCount = 0;
                    inputStates[i].IsActive = false;
                }
                else if (inputStates[i].State == InputState.JustPressed)
                {
                    inputStates[i].State = InputState.Held;
                }
            }
        }

        private void ProcessMouseInput(InputStateComponent[] inputStates)
        {
            bool isCurrentlyPressed = Input.GetMouseButton(0);
            Vector2 worldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);

            ref var currentState = ref inputStates[0];
            InputState newState = DetermineNewInputState(isCurrentlyPressed, wasMousePressed);

            // Only update if state changed or position changed
            if (newState != currentState.State || worldPos != currentState.Position)
            {
                UpdateInputState(ref currentState, worldPos, newState);
            }

            wasMousePressed = isCurrentlyPressed;
        }

        private void ProcessTouchInput(InputStateComponent[] inputStates)
        {
            int touchCount = Mathf.Min(Input.touchCount, MAX_INPUTS);

            // Reset unused input slots
            for (int i = touchCount; i < MAX_INPUTS; i++)
            {
                if (inputStates[i].IsActive)
                {
                    inputStates[i].State = InputState.None;
                    inputStates[i].IsActive = false;
                }
            }

            // Process active touches
            for (int i = 0; i < touchCount; i++)
            {
                Touch touch = Input.GetTouch(i);
                Vector2 worldPos = Camera.main.ScreenToWorldPoint(touch.position);

                InputState newState = touch.phase switch
                {
                    TouchPhase.Began => InputState.JustPressed,
                    TouchPhase.Moved => InputState.Held,
                    TouchPhase.Stationary => InputState.Held,
                    TouchPhase.Ended => InputState.JustReleased,
                    TouchPhase.Canceled => InputState.JustReleased,
                    _ => InputState.None,
                };

                UpdateInputState(ref inputStates[i], worldPos, newState);
            }
        }

        private void UpdateInputState(
            ref InputStateComponent state,
            Vector2 position,
            InputState newState
        )
        {
            state.PreviousPosition = state.Position;
            state.Position = position;
            state.State = newState;
            state.IsActive = newState != InputState.None;

            if (newState != state.State)
            {
                state.FrameCount = 0;
            }
            state.FrameCount++;
        }

        private InputState DetermineNewInputState(bool isPressed, bool wasPressed)
        {
            if (isPressed && !wasPressed)
                return InputState.JustPressed;
            if (!isPressed && wasPressed)
                return InputState.JustReleased;
            if (isPressed)
                return InputState.Held;
            return InputState.None;
        }

        public void Cleanup()
        {
            // Nothing to cleanup for now
        }
    }
}

================
File: ECS_Principled/Systems/InputSystem.cs.meta
================
fileFormatVersion: 2
guid: 3a7c2b94a0f5a416c8d8401ea289c387
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/MovingNoteSystem.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MovingNoteSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        private readonly GeneralGameSetting generalGameSetting;

        public MovingNoteSystem(GeneralGameSetting generalGameSetting)
        {
            this.generalGameSetting = generalGameSetting;
        }

        public void Cleanup() { }

        public void Initialize() { }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            ArchetypeStorage musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            TransformComponent[] transforms = musicNoteStorage.GetComponents<TransformComponent>();
            CornerComponent[] corners = musicNoteStorage.GetComponents<CornerComponent>();

            float gameSpeed = generalGameSetting.GameSpeed;

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                // Update position
                Vector2 newPos = transforms[i].Posision;
                newPos.y -= gameSpeed * Time.deltaTime;
                transforms[i].Posision = newPos;

                // Update corners based on new position and size
                Vector2 halfSize = transforms[i].Size * 0.5f;
                corners[i].TopLeft = new Vector2(newPos.x - halfSize.x, newPos.y + halfSize.y);
                corners[i].TopRight = new Vector2(newPos.x + halfSize.x, newPos.y + halfSize.y);
                corners[i].BottomLeft = new Vector2(newPos.x - halfSize.x, newPos.y - halfSize.y);
                corners[i].BottomRight = new Vector2(newPos.x + halfSize.x, newPos.y - halfSize.y);
            }
        }
    }
}

================
File: ECS_Principled/Systems/MovingNoteSystem.cs.meta
================
fileFormatVersion: 2
guid: 23e31434417084f63bbc9efc34471f1f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/MusicNoteCreationSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteCreationSystem : IGameSystem
    {
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;
        private readonly GeneralGameSetting generalGameSetting;
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.WaitingToStart;

        public MusicNoteCreationSystem(
            MusicNoteCreationSetting musicNoteCreationSetting,
            GeneralGameSetting generalGameSetting
        )
        {
            this.musicNoteCreationSetting = musicNoteCreationSetting;
            this.generalGameSetting = generalGameSetting;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            MusicNoteMidiData musicNoteMidiData = MidiNoteParser.ParseFromText(
                musicNoteCreationSetting.MidiContent.text
            );

            ArchetypeStorage perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            ref CornerComponent perfectLineCorners =
                ref perfectLineStorage.GetComponents<CornerComponent>()[0];

            // Calculate lane width once
            float totalWidth = perfectLineCorners.TopRight.x - perfectLineCorners.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            for (int i = 0; i < musicNoteMidiData.TotalNotes; i++)
            {
                MusicNoteType musicNoteType = MusicNoteType.ShortNote;
                if (musicNoteMidiData.Durations[i] > musicNoteMidiData.MinDuration)
                {
                    musicNoteType = MusicNoteType.LongNote;
                }

                object[] components = new object[]
                {
                    new TransformComponent { },
                    new MusicNoteComponent
                    {
                        Duration = musicNoteMidiData.Durations[i],
                        PostionId = musicNoteMidiData.PositionIds[i],
                        TimeAppear = musicNoteMidiData.TimeAppears[i],
                        musicNoteType = musicNoteType,
                    },
                    new CornerComponent { },
                    new MusicNoteInteractionComponent { },
                    new MusicNoteFillerComponent { },
                };

                World.CreateEntityWithComponents(Archetype.Registry.MusicNote, components);
            }

            ArchetypeStorage musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            TransformComponent[] transforms = musicNoteStorage.GetComponents<TransformComponent>();
            MusicNoteComponent[] musicNotes = musicNoteStorage.GetComponents<MusicNoteComponent>();

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                float spawnX =
                    perfectLineCorners.TopLeft.x
                    + (musicNoteMidiData.PositionIds[i] * laneWidth)
                    + halfLaneWidth;

                float spawnY =
                    perfectLineCorners.TopLeft.y
                    + (musicNoteMidiData.TimeAppears[i] * generalGameSetting.GameSpeed)
                    + transforms[i].Size.y / 2f;

                transforms[i].Posision = new Vector2(spawnX, spawnY);

                float scaleX = PerfectLine.PerfectLineWidth / 4;

                float scaleY;

                if (musicNotes[i].musicNoteType == MusicNoteType.ShortNote)
                {
                    scaleY = MagicTileHelper.CalculateScaleY(
                        musicNoteCreationSetting.ShortNoteScaleYFactor,
                        scaleX
                    );
                }
                else
                {
                    scaleY = MagicTileHelper.CalculateScaleY(
                        musicNoteCreationSetting.LongNoteScaleYFactor,
                        scaleX,
                        musicNotes[i].Duration
                    );
                }

                transforms[i].Size = new Vector2(scaleX, scaleY);
            }
        }

        public void Update(float deltaTime)
        {
            //
        }

        public void Cleanup()
        {
            //
        }
    }
}

================
File: ECS_Principled/Systems/MusicNoteCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: 27223b00486847b4b86f21b0b74f2e53
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/SingletonCreationSystem.cs
================
using ECS_MagicTile.Components;
using UnityEditor.Tilemaps;
using UnityEngine;

namespace ECS_MagicTile
{
    public class SingletonCreationSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.WaitingToStart;

        private readonly PerfectLineSettingSO perfectLineSettingSO;
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;

        public SingletonCreationSystem(GlobalPoint globalPoint)
        {
            this.perfectLineSettingSO = globalPoint.perfectLineSettingSO;
            this.musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
        }

        public void Cleanup()
        {
            //
        }

        public void Initialize()
        {
            CreatePerfectLine();
            CreateStartingNote();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            //
        }

        private void CreatePerfectLine()
        {
            //The perfect line singleton
            var components = new object[] { new PerfectLineTagComponent(), new CornerComponent() };
            World.CreateEntityWithComponents(Archetype.Registry.PerfectLine, components);

            ArchetypeStorage perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            ref CornerComponent perfectLineCorner =
                ref perfectLineStorage.GetComponents<CornerComponent>()[0];

            PerfectLine.PerfectLineWidth = perfectLineSettingSO.PerfectLineWidth();
            perfectLineCorner.TopLeft = perfectLineSettingSO.TopLeft;
            perfectLineCorner.TopRight = perfectLineSettingSO.TopRight;
            perfectLineCorner.BottomLeft = perfectLineSettingSO.BottomLeft;
            perfectLineCorner.BottomRight = perfectLineSettingSO.BottomRight;
        }

        private void CreateStartingNote()
        {
            var components = new object[]
            {
                new TransformComponent(),
                new ActiveStateComponent(),
                new StartingNoteTagComponent(),
            };
            World.CreateEntityWithComponents(Archetype.Registry.StartingNote, components);

            ArchetypeStorage storage = World.GetStorage(Archetype.Registry.StartingNote);
            ArchetypeStorage perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            ref ActiveStateComponent activeState =
                ref storage.GetComponents<ActiveStateComponent>()[0];
            ref TransformComponent transform = ref storage.GetComponents<TransformComponent>()[0];

            ref CornerComponent perfectLineCorners =
                ref perfectLineStorage.GetComponents<CornerComponent>()[0];

            // Calculate lane width
            float totalWidth = perfectLineCorners.TopRight.x - perfectLineCorners.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            activeState.isActive = true;

            // Calculate spawn position
            float spawnX = perfectLineCorners.TopLeft.x + (0 * laneWidth) + halfLaneWidth;
            float spawnY = perfectLineCorners.TopLeft.y;

            transform.Posision = new Vector2(spawnX, spawnY);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            float scaleX = PerfectLine.PerfectLineWidth / 4;

            float scaleY = MagicTileHelper.CalculateScaleY(
                musicNoteCreationSetting.ShortNoteScaleYFactor,
                scaleX
            );

            transform.Size = new Vector2(scaleX, scaleY);
        }
    }
}

================
File: ECS_Principled/Systems/SingletonCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: 0363a30a155e7de4492faa5045403325
