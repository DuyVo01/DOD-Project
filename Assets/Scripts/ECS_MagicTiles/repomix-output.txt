This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-26T16:05:27.821Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
ECS_Principled.meta
ECS_Principled/Core.meta
ECS_Principled/Core/Archetype.cs
ECS_Principled/Core/Archetype.cs.meta
ECS_Principled/Core/ArchetypeStorage.cs
ECS_Principled/Core/ArchetypeStorage.cs.meta
ECS_Principled/Core/ArchetypeSyncer.cs
ECS_Principled/Core/ArchetypeSyncer.cs.meta
ECS_Principled/Core/BaseSyncTool.cs
ECS_Principled/Core/BaseSyncTool.cs.meta
ECS_Principled/Core/ComponentType.cs
ECS_Principled/Core/ComponentType.cs.meta
ECS_Principled/Core/EntityIdHolder.cs
ECS_Principled/Core/EntityIdHolder.cs.meta
ECS_Principled/Core/EntityViewFactory.cs
ECS_Principled/Core/EntityViewFactory.cs.meta
ECS_Principled/Core/GlobalPoint.cs
ECS_Principled/Core/GlobalPoint.cs.meta
ECS_Principled/Core/IComponent.cs
ECS_Principled/Core/IComponent.cs.meta
ECS_Principled/Core/IEntityHolder.cs
ECS_Principled/Core/IEntityHolder.cs.meta
ECS_Principled/Core/IGameSystem.cs
ECS_Principled/Core/IGameSystem.cs.meta
ECS_Principled/Core/StorageManager.cs
ECS_Principled/Core/StorageManager.cs.meta
ECS_Principled/Core/SystemRegistry.cs
ECS_Principled/Core/SystemRegistry.cs.meta
ECS_Principled/Core/World.cs
ECS_Principled/Core/World.cs.meta
ECS_Principled/DataComponents.meta
ECS_Principled/DataComponents/ActiveStateComponent.cs
ECS_Principled/DataComponents/ActiveStateComponent.cs.meta
ECS_Principled/DataComponents/CornerComponent.cs
ECS_Principled/DataComponents/CornerComponent.cs.meta
ECS_Principled/DataComponents/GraphicComponent.cs
ECS_Principled/DataComponents/GraphicComponent.cs.meta
ECS_Principled/DataComponents/InputStateComponent.cs
ECS_Principled/DataComponents/InputStateComponent.cs.meta
ECS_Principled/DataComponents/LongNoteTagComponent.cs
ECS_Principled/DataComponents/LongNoteTagComponent.cs.meta
ECS_Principled/DataComponents/MusicNoteComponent.cs
ECS_Principled/DataComponents/MusicNoteComponent.cs.meta
ECS_Principled/DataComponents/MusicNoteFillerComponent.cs
ECS_Principled/DataComponents/MusicNoteFillerComponent.cs.meta
ECS_Principled/DataComponents/MusicNoteInteractionComponent.cs
ECS_Principled/DataComponents/MusicNoteInteractionComponent.cs.meta
ECS_Principled/DataComponents/PerfectLineTagComponent.cs
ECS_Principled/DataComponents/PerfectLineTagComponent.cs.meta
ECS_Principled/DataComponents/ProgressComponent.cs
ECS_Principled/DataComponents/ProgressComponent.cs.meta
ECS_Principled/DataComponents/ScoreComponent.cs
ECS_Principled/DataComponents/ScoreComponent.cs.meta
ECS_Principled/DataComponents/ScoreEffectComponent.cs
ECS_Principled/DataComponents/ScoreEffectComponent.cs.meta
ECS_Principled/DataComponents/ScoreStateComponent.cs
ECS_Principled/DataComponents/ScoreStateComponent.cs.meta
ECS_Principled/DataComponents/ShortNoteTagComponent.cs
ECS_Principled/DataComponents/ShortNoteTagComponent.cs.meta
ECS_Principled/DataComponents/StartingNoteTagComponent.cs
ECS_Principled/DataComponents/StartingNoteTagComponent.cs.meta
ECS_Principled/DataComponents/TransformComponent.cs
ECS_Principled/DataComponents/TransformComponent.cs.meta
ECS_Principled/DataComponents/WorldStateComponent.cs
ECS_Principled/DataComponents/WorldStateComponent.cs.meta
ECS_Principled/DTO.meta
ECS_Principled/DTO/MusicNoteMidiData.cs
ECS_Principled/DTO/MusicNoteMidiData.cs.meta
ECS_Principled/EGameState.cs
ECS_Principled/EGameState.cs.meta
ECS_Principled/EventChannels.meta
ECS_Principled/EventChannels/OnGameStartChannel.asset
ECS_Principled/EventChannels/OnGameStartChannel.asset.meta
ECS_Principled/EventChannels/OnOrientationChangeChannel.asset
ECS_Principled/EventChannels/OnOrientationChangeChannel.asset.meta
ECS_Principled/EventChannels/OnSongStartChannel.asset
ECS_Principled/EventChannels/OnSongStartChannel.asset.meta
ECS_Principled/EventChannels/SO_ScoreSignalEffectChannel.asset
ECS_Principled/EventChannels/SO_ScoreSignalEffectChannel.asset.meta
ECS_Principled/EventChannels/SOScripts.meta
ECS_Principled/EventChannels/SOScripts/BoolEventChannel.cs
ECS_Principled/EventChannels/SOScripts/BoolEventChannel.cs.meta
ECS_Principled/EventChannels/SOScripts/IntEventChannel.cs
ECS_Principled/EventChannels/SOScripts/IntEventChannel.cs.meta
ECS_Principled/Functions.meta
ECS_Principled/Functions/PreciseNoteCalculator.cs
ECS_Principled/Functions/PreciseNoteCalculator.cs.meta
ECS_Principled/MonoScripts.meta
ECS_Principled/MonoScripts/AudioManager.cs
ECS_Principled/MonoScripts/AudioManager.cs.meta
ECS_Principled/MonoScripts/BurstMovement.cs
ECS_Principled/MonoScripts/BurstMovement.cs.meta
ECS_Principled/MonoScripts/BurstMovementUIController.cs
ECS_Principled/MonoScripts/BurstMovementUIController.cs.meta
ECS_Principled/MonoScripts/CrownTween.cs
ECS_Principled/MonoScripts/CrownTween.cs.meta
ECS_Principled/MonoScripts/EffectOnProgress.cs
ECS_Principled/MonoScripts/EffectOnProgress.cs.meta
ECS_Principled/MonoScripts/ProgressEffectController.cs
ECS_Principled/MonoScripts/ProgressEffectController.cs.meta
ECS_Principled/MonoScripts/RaycastToObjects.cs
ECS_Principled/MonoScripts/RaycastToObjects.cs.meta
ECS_Principled/MonoScripts/ScoreEffectController.cs
ECS_Principled/MonoScripts/ScoreEffectController.cs.meta
ECS_Principled/MonoScripts/ScreenManager.cs
ECS_Principled/MonoScripts/ScreenManager.cs.meta
ECS_Principled/MonoScripts/StarTween.cs
ECS_Principled/MonoScripts/StarTween.cs.meta
ECS_Principled/MonoScripts/VerticalLineSetup.cs
ECS_Principled/MonoScripts/VerticalLineSetup.cs.meta
ECS_Principled/repomix-output.txt
ECS_Principled/repomix-output.txt.meta
ECS_Principled/Settings.meta
ECS_Principled/Settings/GeneralGameSetting_SO.asset
ECS_Principled/Settings/GeneralGameSetting_SO.asset.meta
ECS_Principled/Settings/LaneLineSettings_SO.asset
ECS_Principled/Settings/LaneLineSettings_SO.asset.meta
ECS_Principled/Settings/MusicNoteCreationSetting_SO.asset
ECS_Principled/Settings/MusicNoteCreationSetting_SO.asset.meta
ECS_Principled/Settings/PerfectLineSetting_SO.asset
ECS_Principled/Settings/PerfectLineSetting_SO.asset.meta
ECS_Principled/Settings/ScoreEffectSettings_SO.asset
ECS_Principled/Settings/ScoreEffectSettings_SO.asset.meta
ECS_Principled/Settings/SO_SCripts.meta
ECS_Principled/Settings/SO_SCripts/GeneralGameSetting.cs
ECS_Principled/Settings/SO_SCripts/GeneralGameSetting.cs.meta
ECS_Principled/Settings/SO_SCripts/LaneLineSettings.cs
ECS_Principled/Settings/SO_SCripts/LaneLineSettings.cs.meta
ECS_Principled/Settings/SO_SCripts/MidiNoteParser.cs
ECS_Principled/Settings/SO_SCripts/MidiNoteParser.cs.meta
ECS_Principled/Settings/SO_SCripts/MusicNoteCreationSetting.cs
ECS_Principled/Settings/SO_SCripts/MusicNoteCreationSetting.cs.meta
ECS_Principled/Settings/SO_SCripts/PerfectLineSetting.cs
ECS_Principled/Settings/SO_SCripts/PerfectLineSetting.cs.meta
ECS_Principled/Settings/SO_SCripts/ScoreEffectSettings.cs
ECS_Principled/Settings/SO_SCripts/ScoreEffectSettings.cs.meta
ECS_Principled/Syncers.meta
ECS_Principled/Syncers/GameScoreSyncTool.cs
ECS_Principled/Syncers/GameScoreSyncTool.cs.meta
ECS_Principled/Syncers/LaneLineSyncTool.cs
ECS_Principled/Syncers/LaneLineSyncTool.cs.meta
ECS_Principled/Syncers/MusicNoteSyncer.cs
ECS_Principled/Syncers/MusicNoteSyncer.cs.meta
ECS_Principled/Syncers/MusicNoteViewSyncTool.cs
ECS_Principled/Syncers/MusicNoteViewSyncTool.cs.meta
ECS_Principled/Syncers/PerfectLineSyncTool.cs
ECS_Principled/Syncers/PerfectLineSyncTool.cs.meta
ECS_Principled/Syncers/ProgressSyncer.cs
ECS_Principled/Syncers/ProgressSyncer.cs.meta
ECS_Principled/Syncers/ProgressSyncTool.cs
ECS_Principled/Syncers/ProgressSyncTool.cs.meta
ECS_Principled/Syncers/ScoreUISyncer.cs
ECS_Principled/Syncers/ScoreUISyncer.cs.meta
ECS_Principled/Syncers/StartingNoteSyncer.cs
ECS_Principled/Syncers/StartingNoteSyncer.cs.meta
ECS_Principled/Syncers/StartingNoteSyncTool.cs
ECS_Principled/Syncers/StartingNoteSyncTool.cs.meta
ECS_Principled/Systems.meta
ECS_Principled/Systems/GameStateSystem.cs
ECS_Principled/Systems/GameStateSystem.cs.meta
ECS_Principled/Systems/InputCollisionSystem.cs
ECS_Principled/Systems/InputCollisionSystem.cs.meta
ECS_Principled/Systems/InputSystem.cs
ECS_Principled/Systems/InputSystem.cs.meta
ECS_Principled/Systems/LaneLineSystem.cs
ECS_Principled/Systems/LaneLineSystem.cs.meta
ECS_Principled/Systems/MovingNoteSystem.cs
ECS_Principled/Systems/MovingNoteSystem.cs.meta
ECS_Principled/Systems/MusicNoteCreationSystem.cs
ECS_Principled/Systems/MusicNoteCreationSystem.cs.meta
ECS_Principled/Systems/PerfectLineSystem.cs
ECS_Principled/Systems/PerfectLineSystem.cs.meta
ECS_Principled/Systems/ProgressSystem.cs
ECS_Principled/Systems/ProgressSystem.cs.meta
ECS_Principled/Systems/ScoringSystem.cs
ECS_Principled/Systems/ScoringSystem.cs.meta
ECS_Principled/Systems/SingletonCreationSystem.cs
ECS_Principled/Systems/SingletonCreationSystem.cs.meta
ECS_Principled/Systems/StartingNoteSystem.cs
ECS_Principled/Systems/StartingNoteSystem.cs.meta
ECS_Principled/Systems/TraceNoteToTriggerSongSystem.cs
ECS_Principled/Systems/TraceNoteToTriggerSongSystem.cs.meta

================================================================
Repository Files
================================================================

================
File: ECS_Principled.meta
================
fileFormatVersion: 2
guid: c7a632be4233831448c1261c82cae9ee
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core.meta
================
fileFormatVersion: 2
guid: b57c2d5fbb39b489e9c51a111e5e8e4f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/Archetype.cs
================
using System;
using System.Linq;

namespace ECS_MagicTile
{
    public class Archetype
    {
        private readonly ComponentType[] types;
        private readonly int hash;
        private readonly bool isAspect;

        public bool IsAspect => isAspect;

        private Archetype(ComponentType[] types, bool isAspect = false)
        {
            // Store types in a fixed order for consistent hashing
            this.types = types.OrderBy(t => t.Id).ToArray();
            this.hash = CalculateHash(this.types);
            this.isAspect = isAspect;
        }

        // Utility methods for archetype management
        public ReadOnlySpan<ComponentType> GetTypes() => types;

        public int GetHash() => hash;

        private static int CalculateHash(ComponentType[] types)
        {
            // Simple but effective hash calculation for fixed component combinations
            int hash = 17;
            foreach (var type in types)
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        // Game-specific archetypes
        public static class Registry
        {
            // Note archetypes
            public static readonly Archetype MusicNote =
                new(
                    new[]
                    {
                        ComponentType.Registry.Transform,
                        ComponentType.Registry.MusicNote,
                        ComponentType.Registry.Corner, // Added CornerComponent
                        ComponentType.Registry.MusicNoteInteraction,
                        ComponentType.Registry.MusicNoteFiller,
                        ComponentType.Registry.NoteScoreState,
                    }
                );

            // Game setup archetypes
            public static readonly Archetype PerfectLine =
                new(
                    new[]
                    {
                        ComponentType.Registry.Transform,
                        ComponentType.Registry.PerfectLine,
                        ComponentType.Registry.Corner,
                    }
                );

            public static readonly Archetype Input = new(new[] { ComponentType.Registry.Input });
            public static readonly Archetype StartingNote =
                new(
                    new[]
                    {
                        ComponentType.Registry.Transform,
                        ComponentType.Registry.ActiveState,
                        ComponentType.Registry.StartingNote,
                    }
                );

            public static readonly Archetype GameScore =
                new(
                    new[]
                    {
                        ComponentType
                            .Registry
                            .GameScore // New score component
                        ,
                    }
                );

            public static readonly Archetype SongProgress =
                new(new[] { ComponentType.Registry.Progress });

            public static readonly Archetype LaneLines =
                new(new[] { ComponentType.Registry.Transform });

            public static readonly Archetype WorldState =
                new(new[] { ComponentType.Registry.WorldState });

            // Keep track of all archetypes for initialization
            private static readonly Archetype[] AllArchetypes =
            {
                MusicNote,
                PerfectLine,
                Input,
                StartingNote,
                GameScore,
                SongProgress,
                LaneLines,
                WorldState,
            };

            public static ReadOnlySpan<Archetype> GetAllArchetypes() => AllArchetypes;
        }
    }
}

================
File: ECS_Principled/Core/Archetype.cs.meta
================
fileFormatVersion: 2
guid: 6a700f18bf185134ebcd378e0ebfe28f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/ArchetypeStorage.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_MagicTile
{
    public class ArchetypeStorage
    {
        // Store component arrays indexed by their ComponentType
        private readonly Dictionary<ComponentType, Array> componentArrays;
        private int[] entityIds; // Tracks which entities are in this storage
        private readonly Dictionary<int, int> entityToIndex = new Dictionary<int, int>();
        private int count; // Number of active entities

        private const int DEFAULT_CAPACITY = 64; // Starting size for our arrays
        private const float GROWTH_FACTOR = 2.0f; // How much to grow when we need more space

        public ArchetypeStorage(Archetype archetype, int initialCapacity = DEFAULT_CAPACITY)
        {
            componentArrays = new Dictionary<ComponentType, Array>();

            // Create typed arrays for each component in the archetype
            foreach (var componentType in archetype.GetTypes())
            {
                // Creates an array of the proper type with our initial capacity
                componentArrays[componentType] = Array.CreateInstance(
                    componentType.Type,
                    initialCapacity
                );
            }

            entityIds = new int[initialCapacity];

            count = 0;
        }

        // Provides type-safe access to component arrays
        public T[] GetComponents<T>()
            where T : struct
        {
            var componentType = ComponentType.Registry.GetComponentType<T>();
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {typeof(T)} not found in archetype"
                );
            }
            return (T[])array;
        }

        // Adds an entity with its components to this storage
        public void Add(int entityId, ReadOnlySpan<object> components)
        {
            // Grow arrays if needed
            if (count >= entityIds.Length)
            {
                Grow();
            }

            // Add components to their respective arrays
            int componentIndex = 0;
            foreach (var array in componentArrays.Values)
            {
                Array.Copy(new[] { components[componentIndex] }, 0, array, count, 1);
                componentIndex++;
            }

            // Track the entity
            entityIds[count] = entityId;
            entityToIndex[entityId] = count;
            count++;
        }

        // Efficiently removes an entity by swapping with the last element
        public void Remove(int entityId)
        {
            // Find the entity's index
            int index = Array.IndexOf(entityIds, entityId, 0, count);
            if (index == -1)
                return;

            // If it's not the last element, swap with the last one
            int lastIndex = count - 1;
            if (index < lastIndex)
            {
                foreach (var array in componentArrays.Values)
                {
                    Array.Copy(array, lastIndex, array, index, 1);
                }
                entityIds[index] = entityIds[lastIndex];
                entityToIndex[entityIds[lastIndex]] = index;
            }

            entityToIndex.Remove(entityId);
            count--;
        }

        private void Grow()
        {
            int newCapacity = (int)(entityIds.Length * GROWTH_FACTOR);

            // Grow all component arrays
            foreach (var kvp in componentArrays.ToList())
            {
                var oldArray = kvp.Value;
                var newArray = Array.CreateInstance(kvp.Key.Type, newCapacity);
                Array.Copy(oldArray, 0, newArray, 0, count);
                componentArrays[kvp.Key] = newArray;
            }

            // Grow entity ID array
            Array.Resize(ref entityIds, newCapacity);
        }

        // And we need to add this method to ArchetypeStorage
        public Array GetComponentArrayRaw(ComponentType componentType)
        {
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {componentType.Type.Name} not found in archetype"
                );
            }
            return array;
        }

        public int GetEntityIndex(int entityId)
        {
            return entityToIndex.TryGetValue(entityId, out int index) ? index : -1;
        }

        // Properties for accessing storage information
        public int Count => count;
        public ReadOnlySpan<int> EntityIds => new ReadOnlySpan<int>(entityIds, 0, count);
    }
}

================
File: ECS_Principled/Core/ArchetypeStorage.cs.meta
================
fileFormatVersion: 2
guid: 785407d53c9c26746adb34ba3d74b58d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/ArchetypeSyncer.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public abstract class ArchetypeSyncer : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        protected ArchetypeStorage DedicatedStorage => World.GetStorage(Archetype);
        protected abstract Archetype Archetype { get; }

        public abstract EGameState GameStateToExecute { get; }

        public void SetWorld(World world)
        {
            World = world;
        }

        public virtual void Initialize() { }

        public virtual void Update(float deltaTime) { }

        public virtual void Cleanup() { }
    }
}

================
File: ECS_Principled/Core/ArchetypeSyncer.cs.meta
================
fileFormatVersion: 2
guid: 0df86895fba8144229e53825e79322a5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/BaseSyncTool.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public abstract class BaseSyncTool
    {
        protected World World;
        protected abstract Archetype Archetype { get; }
        protected ArchetypeStorage DedicatedStorage;

        public bool IsInitialized { get; set; }

        public BaseSyncTool(GlobalPoint globalPoint)
        {
            this.World = globalPoint.World;

            DedicatedStorage = World.GetStorage(Archetype);

            IsInitialized = false;
        }

        public virtual void InitializeTool()
        {
            if (IsInitialized)
                return;
            IsInitialized = true;
        }
    }
}

================
File: ECS_Principled/Core/BaseSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 5e44dbdf22074481cb483b4d3d14412b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/ComponentType.cs
================
using System;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using NUnit.Framework.Constraints;

namespace ECS_MagicTile
{
    public readonly struct ComponentType
    {
        public readonly Type Type;
        public readonly int Id;

        // Private constructor ensures all types are created through registry
        private ComponentType(Type type, int id)
        {
            Type = type;
            Id = id;
        }

        // Static registry of all component types in our game
        public static class Registry
        {
            // Core Components
            public static readonly ComponentType Transform = new(typeof(TransformComponent), 0);
            public static readonly ComponentType MusicNote = new(typeof(MusicNoteComponent), 1);

            public static readonly ComponentType PerfectLine =
                new(typeof(PerfectLineTagComponent), 3);
            public static readonly ComponentType Corner = new(typeof(CornerComponent), 4);

            public static readonly ComponentType Input = new(typeof(InputStateComponent), 5);
            public static readonly ComponentType MusicNoteInteraction =
                new(typeof(MusicNoteInteractionComponent), 6);
            public static readonly ComponentType MusicNoteFiller =
                new(typeof(MusicNoteFillerComponent), 7);

            public static readonly ComponentType ActiveState = new(typeof(ActiveStateComponent), 8);
            public static readonly ComponentType StartingNote =
                new(typeof(StartingNoteTagComponent), 9);
            public static readonly ComponentType GameScore = new(typeof(ScoreComponent), 10);
            public static readonly ComponentType NoteScoreState =
                new(typeof(ScoreStateComponent), 11);

            public static readonly ComponentType TransformGroup =
                new(typeof(TransformComponentGroup), 12);

            public static readonly ComponentType Progress = new(typeof(ProgressComponent), 14);
            public static readonly ComponentType WorldState = new(typeof(WorldStateComponent), 15);

            // A lookup dictionary to quickly find ComponentType by Type
            private static readonly Dictionary<Type, ComponentType> typeToComponentType =
                new Dictionary<Type, ComponentType>
                {
                    { typeof(TransformComponent), Transform },
                    { typeof(MusicNoteComponent), MusicNote },
                    { typeof(PerfectLineTagComponent), PerfectLine },
                    { typeof(CornerComponent), Corner },
                    { typeof(InputStateComponent), Input },
                    { typeof(MusicNoteInteractionComponent), MusicNoteInteraction },
                    { typeof(MusicNoteFillerComponent), MusicNoteFiller },
                    { typeof(ActiveStateComponent), ActiveState },
                    { typeof(StartingNoteTagComponent), StartingNote },
                    { typeof(ScoreComponent), GameScore },
                    { typeof(ScoreStateComponent), NoteScoreState },
                    { typeof(TransformComponentGroup), TransformGroup },
                    { typeof(ProgressComponent), Progress },
                    { typeof(WorldStateComponent), WorldState },
                };

            // This is our new generic lookup method
            public static ComponentType GetComponentType<T>()
                where T : struct
            {
                var type = typeof(T);
                if (!typeToComponentType.TryGetValue(type, out var componentType))
                {
                    throw new InvalidOperationException(
                        $"Component type {type.Name} is not registered. "
                            + "Make sure to add it to the ComponentType.Registry."
                    );
                }
                return componentType;
            }

            // The existing methods remain the same
            public static ReadOnlySpan<ComponentType> GetAllTypes() => AllTypes;

            private static readonly ComponentType[] AllTypes =
            {
                Transform,
                MusicNote,
                PerfectLine,
                Corner,
            };
        }
    }
}

================
File: ECS_Principled/Core/ComponentType.cs.meta
================
fileFormatVersion: 2
guid: 07d3246996a8eeb4ba2c5e2e4d0939c9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/EntityIdHolder.cs
================
using System.Linq;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EntityIdHolder : MonoBehaviour, IEntityHolder
    {
        public int EntityId { get; private set; }

        public void SetEntityId(int id)
        {
            EntityId = id;
            // Optional: Make the GameObject name more readable without losing the ID reference
            gameObject.name = $"{id}_{gameObject.name.Split('_').LastOrDefault() ?? "entity"}";
        }
    }
}

================
File: ECS_Principled/Core/EntityIdHolder.cs.meta
================
fileFormatVersion: 2
guid: 17dde60b87c53b14884d92c6a0f07c99
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/EntityViewFactory.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EntityViewFactory
    {
        private readonly Dictionary<int, GameObject> entityViews = new();
        private readonly GameObject prefabSource;
        private readonly Transform viewRoot;

        public EntityViewFactory() { }

        public EntityViewFactory(GameObject prefabSource, Transform viewRoot)
        {
            this.prefabSource = prefabSource;
            this.viewRoot = viewRoot;
        }

        public GameObject GetOrCreateView(int entityId, string nameOnCreation = "")
        {
            if (entityViews.TryGetValue(entityId, out var existing))
            {
                return existing;
            }

            var prefab = prefabSource;

            GameObject view = GameObject.Instantiate(prefab, viewRoot);
            EntityIdHolder viewEntityIdHolder = view.AddComponent<EntityIdHolder>();
            viewEntityIdHolder.SetEntityId(entityId);
            entityViews[entityId] = view;
            return view;
        }

        public GameObject GetView(int entityId)
        {
            return entityViews.TryGetValue(entityId, out var view) ? view : null;
        }
    }
}

================
File: ECS_Principled/Core/EntityViewFactory.cs.meta
================
fileFormatVersion: 2
guid: f36c2cdebdbc74a8db63bff96d758abd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/GlobalPoint.cs
================
using System.Diagnostics;
using EventChannel;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class GlobalPoint : MonoBehaviour
    {
        [Header("Game Settings")]
        public GeneralGameSetting generalGameSetting;

        public MusicNoteCreationSetting musicNoteCreationSettings;

        public PerfectLineSetting perfectLineSetting;
        public LaneLineSettings laneLineSettings;

        [Header("Event Channel")]
        public IntEventChannel OnGameStartChannel;
        public BoolEventChannel OnScoreHitChannel;
        public BoolEventChannel OnOrientationChangedChannel;
        public EmptyEventChannel OnSongStartChannel;

        [Header("UI references")]
        public Text scoreText;
        public Slider progressSlider;

        [Header("Object references")]
        public GameObject perfectLineObject;
        public Camera mainCamera;

        private World world;

        public World World
        {
            get => world;
        }

        public MusicNoteViewSyncTool musicNoteViewSyncTool { get; private set; }
        public PerfectLineSyncTool perfectLineSyncTool { get; private set; }
        public StartingNoteSyncTool startingNoteSyncTool { get; private set; }
        public GameScoreSyncTool gameScoreSyncTool { get; private set; }
        public ProgressSyncTool progressSyncTool { get; private set; }
        public LaneLineSyncTool laneLineSyncTool { get; private set; }

        private void Awake()
        {
            // Initialize our ECS world
            world = new World();

            SystemRegistry.Initialize(world);
            InitializeSyncTools();
            RegisterSystems();
        }

        private void InitializeSyncTools()
        {
            musicNoteViewSyncTool = new MusicNoteViewSyncTool(this);
            perfectLineSyncTool = new PerfectLineSyncTool(this);
            startingNoteSyncTool = new StartingNoteSyncTool(this);
            gameScoreSyncTool = new GameScoreSyncTool(this);
            progressSyncTool = new ProgressSyncTool(this);
            laneLineSyncTool = new LaneLineSyncTool(this);
        }

        private void RegisterSystems()
        {
            //Singleton Creation system
            SystemRegistry.AddSystem(new SingletonCreationSystem(this));

            //Creation System
            SystemRegistry.AddSystem(new PerfectLineSystem(this));
            SystemRegistry.AddSystem(new MusicNoteCreationSystem(this));
            SystemRegistry.AddSystem(new StartingNoteSystem(this));

            //Handling Data system
            SystemRegistry.AddSystem(new MovingNoteSystem(this));
            SystemRegistry.AddSystem(new TraceNoteToTriggerSongSystem(this));
            SystemRegistry.AddSystem(new InputSystem());
            SystemRegistry.AddSystem(new InputCollisionSystem(this));
            SystemRegistry.AddSystem(new ScoringSystem(this));
            SystemRegistry.AddSystem(new ProgressSystem(this));
            SystemRegistry.AddSystem(new LaneLineSystem(this));

            //Game State system
            SystemRegistry.AddSystem(new GameStateSystem(this));
        }

        private void Update()
        {
            // Update all systems with current frame's delta time
            SystemRegistry.Update(Time.deltaTime);
        }
    }
}

================
File: ECS_Principled/Core/GlobalPoint.cs.meta
================
fileFormatVersion: 2
guid: a3234adf86578d14ca74bc8cc99f7901
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/IComponent.cs
================
namespace ECS_MagicTile
{
    public interface IComponent { }
}

================
File: ECS_Principled/Core/IComponent.cs.meta
================
fileFormatVersion: 2
guid: 5bfc30fb61b4b4792b8875b3f63c5a3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/IEntityHolder.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public interface IEntityHolder
    {
        public int EntityId { get; }

        public void SetEntityId(int id);
    }
}

================
File: ECS_Principled/Core/IEntityHolder.cs.meta
================
fileFormatVersion: 2
guid: 1049762c28d04a94da5cb9e99c65ebb4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/IGameSystem.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    // Interface that all our game systems will implement

    public interface IGameSystem
    {
        void SetWorld(World world);
        void Initialize(); // Called when system is first created
        void Update(float deltaTime); // Called every frame
        void Cleanup();
        bool IsEnabled { get; set; } // Controls if system should be updated
        World World { get; set; }
        EGameState GameStateToExecute { get; }
    }
}

================
File: ECS_Principled/Core/IGameSystem.cs.meta
================
fileFormatVersion: 2
guid: 38d38b21b37a3cf4dbb318fce0f3efdf
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/StorageManager.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Manages all archetype storages in our game
    public class StorageManager
    {
        // Maps archetype hashes to their storage
        private readonly Dictionary<int, ArchetypeStorage> storages;
        private readonly Dictionary<int, List<ArchetypeStorage>> aspectStorages;

        public StorageManager()
        {
            storages = new Dictionary<int, ArchetypeStorage>();
            aspectStorages = new Dictionary<int, List<ArchetypeStorage>>();

            // First, create regular storages
            foreach (var archetype in Archetype.Registry.GetAllArchetypes())
            {
                if (!IsAspectArchetype(archetype))
                {
                    storages[archetype.GetHash()] = new ArchetypeStorage(archetype);
                }

                if (IsAspectArchetype(archetype))
                {
                    // Find all archetypes that contain these components
                    var matchingStorages = FindMatchingStorages(archetype);
                    aspectStorages[archetype.GetHash()] = matchingStorages;
                }
            }
        }

        private bool IsAspectArchetype(Archetype archetype)
        {
            // You could mark aspect archetypes explicitly, or use a naming convention,
            // or determine based on component count
            return archetype.IsAspect;
        }

        private List<ArchetypeStorage> FindMatchingStorages(Archetype aspectArchetype)
        {
            var matchingStorages = new List<ArchetypeStorage>();
            var requiredComponents = aspectArchetype.GetTypes();

            foreach (var storage in storages.Values)
            {
                // Check if this storage's archetype contains all required components
                bool matches = true;
                foreach (var component in requiredComponents)
                {
                    if (!HasComponent(storage, component))
                    {
                        matches = false;
                        break;
                    }
                }

                if (matches)
                {
                    matchingStorages.Add(storage);
                }
            }

            return matchingStorages;
        }

        // Get storage for a specific archetype
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            if (!storages.TryGetValue(archetype.GetHash(), out var storage))
            {
                throw new InvalidOperationException($"No storage found for archetype {archetype}");
            }
            return storage;
        }

        public IEnumerable<ArchetypeStorage> GetStoragesForAspect(Archetype aspectArchetype)
        {
            if (aspectStorages.TryGetValue(aspectArchetype.GetHash(), out var storageList))
            {
                return storageList;
            }
            return Array.Empty<ArchetypeStorage>();
        }

        private bool HasComponent(ArchetypeStorage storage, ComponentType componentType)
        {
            try
            {
                // We try to get the component array - if it exists, the storage has this component
                Array componentArray = storage.GetComponentArrayRaw(componentType);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}

================
File: ECS_Principled/Core/StorageManager.cs.meta
================
fileFormatVersion: 2
guid: 6e34b51edd65cc54298a958d1e7db250
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/SystemRegistry.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Our central system management class
    public static class SystemRegistry
    {
        // Store systems in order of execution priority
        private static readonly List<IGameSystem> updateSystems = new();
        private static World world;
        private static bool isInitialized;
        private static EGameState currentGameState = EGameState.WaitingToStart;

        // Initialize our registry with a world reference
        public static void Initialize(World gameWorld)
        {
            // Prevent multiple initializations
            if (isInitialized)
            {
                Debug.LogWarning("SystemRegistry already initialized!");
                return;
            }

            world = gameWorld;
            isInitialized = true;
        }

        // Allow adding systems from GlobalPoint
        public static void AddSystem(IGameSystem system)
        {
            if (!isInitialized)
            {
                Debug.LogError("SystemRegistry not initialized! Call Initialize first.");
                return;
            }

            // Provide the system with world reference and initialize it
            system.SetWorld(world);
            system.Initialize();

            updateSystems.Add(system);

            Debug.Log($"Added system: {system.GetType().Name}");
        }

        public static void Update(float deltaTime)
        {
            if (!isInitialized)
                return;

            foreach (var system in updateSystems)
            {
                if (
                    system.IsEnabled
                    && (
                        system.GameStateToExecute == currentGameState
                        || system.GameStateToExecute == EGameState.All
                    )
                )
                {
                    try
                    {
                        system.Update(deltaTime);
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error in system {system.GetType().Name}: {e}");
                    }
                }
            }
        }

        public static void Cleanup()
        {
            foreach (var system in updateSystems)
            {
                system.Cleanup();
            }

            updateSystems.Clear();
            isInitialized = false;
            world = null;
        }

        public static void SetGameState(EGameState newState)
        {
            currentGameState = newState;
        }
    }
}

================
File: ECS_Principled/Core/SystemRegistry.cs.meta
================
fileFormatVersion: 2
guid: ae3ac3479b706d64f83a41cf766e7021
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/World.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    public class World
    {
        private readonly StorageManager storageManager;
        private int nextEntityId = 1000; // Starting from 1000 to leave room for special IDs

        public World()
        {
            storageManager = new StorageManager();
        }

        // Creates an entity of a specific archetype
        private int CreateEntity()
        {
            int entityId = nextEntityId++;
            return entityId;
        }

        // Gets a specific storage for systems to use
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            return storageManager.GetStorage(archetype);
        }

        // Helper method to create and set up an entity in one go
        public int CreateEntityWithComponents(Archetype archetype, ReadOnlySpan<object> components)
        {
            int entityId = CreateEntity();
            ArchetypeStorage storage = GetStorage(archetype);
            storage.Add(entityId, components);
            return entityId;
        }
    }
}

================
File: ECS_Principled/Core/World.cs.meta
================
fileFormatVersion: 2
guid: 1df84a3b9711fcb41b790ef98664b125
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents.meta
================
fileFormatVersion: 2
guid: 401cb534838cf40049f69183b5206b9c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ActiveStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ActiveStateComponent : IComponent
    {
        public bool isActive;
    }
}

================
File: ECS_Principled/DataComponents/ActiveStateComponent.cs.meta
================
fileFormatVersion: 2
guid: a3c5cd13e343b874085a9dacaa62d089
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/CornerComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct CornerComponent : IComponent
    {
        public Vector2 TopLeft;
        public Vector2 TopRight;
        public Vector2 BottomLeft;
        public Vector2 BottomRight;
    }
}

================
File: ECS_Principled/DataComponents/CornerComponent.cs.meta
================
fileFormatVersion: 2
guid: b96e4a6c6cb604761b6ec117819be5b4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/GraphicComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct GraphicComponent : IComponent
    {
        public float Alpha;
    }
}

================
File: ECS_Principled/DataComponents/GraphicComponent.cs.meta
================
fileFormatVersion: 2
guid: 82ef7ef712a2447df8b498a1935315b2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/InputStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct InputStateComponent : IComponent
    {
        public bool IsActive;
        public Vector2 Position;
        public Vector2 PreviousPosition;
        public InputState State;
        public int FrameCount;
    }
}

================
File: ECS_Principled/DataComponents/InputStateComponent.cs.meta
================
fileFormatVersion: 2
guid: 97c04fe8669d4470d94eec98d4274ef1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/LongNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct LongNoteTagComponent : IComponent { }
}

================
File: ECS_Principled/DataComponents/LongNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 58353002a3593244d8bf12e61f349c98
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/MusicNoteComponent.cs
================
using ECS_MagicTile;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteComponent : IComponent
    {
        public int PostionId;
        public float TimeAppear;
        public float Duration;
        public MusicNoteType musicNoteType;
        public MusicNotePositionState musicNotePositionState;
    }
}

================
File: ECS_Principled/DataComponents/MusicNoteComponent.cs.meta
================
fileFormatVersion: 2
guid: e13eda0f52da940ceaec30f721998b78
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/MusicNoteFillerComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteFillerComponent : IComponent
    {
        public bool IsVisible;
        public float FillPercent;
    }
}

================
File: ECS_Principled/DataComponents/MusicNoteFillerComponent.cs.meta
================
fileFormatVersion: 2
guid: d7e3fc83bb7c04b7b9b06366cc8a2202
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/MusicNoteInteractionComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteInteractionComponent : IComponent
    {
        public MusicNoteInteractiveState State;
    }
}

================
File: ECS_Principled/DataComponents/MusicNoteInteractionComponent.cs.meta
================
fileFormatVersion: 2
guid: e6da2d26198754d3382d07b0e55fa2f1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/PerfectLineTagComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct PerfectLineTagComponent : IComponent
    {
        public float PerfectLineWidth;
    }
}

================
File: ECS_Principled/DataComponents/PerfectLineTagComponent.cs.meta
================
fileFormatVersion: 2
guid: e18089c9ed33d49f8b76960358f6a4d2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ProgressComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public struct ProgressComponent : IComponent
    {
        public float MaxProgressRawValue;
        public float CurrentProgressRawValue;
        public float currentProgressPercent;
    }
}

================
File: ECS_Principled/DataComponents/ProgressComponent.cs.meta
================
fileFormatVersion: 2
guid: 10aad573b13074bc9be17ec7cf91ad53
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ScoreComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ScoreComponent : IComponent
    {
        public int TotalScore;
    }
}

================
File: ECS_Principled/DataComponents/ScoreComponent.cs.meta
================
fileFormatVersion: 2
guid: fa68460c39b07454594ff59898fdcbbe
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ScoreEffectComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct TransformComponentGroup : IComponent
    {
        public TransformComponent[] satelliteEffects;
    }
}

================
File: ECS_Principled/DataComponents/ScoreEffectComponent.cs.meta
================
fileFormatVersion: 2
guid: 363408fdc911f4ec2b3d751d95811afb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ScoreStateComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile
{
    public struct ScoreStateComponent : IComponent
    {
        public bool HasBeenScored;
    }
}

================
File: ECS_Principled/DataComponents/ScoreStateComponent.cs.meta
================
fileFormatVersion: 2
guid: f7658e090bcd30d46b50748601faa672
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ShortNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ShortNoteTagComponent : IComponent { }
}

================
File: ECS_Principled/DataComponents/ShortNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 83c9ef9fdf039c843b9556bfba72a05a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/StartingNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct StartingNoteTagComponent : IComponent
    {
        public int initalLane;
    }
}

================
File: ECS_Principled/DataComponents/StartingNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 60788d363c63c884e898300f27bf2be1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/TransformComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct TransformComponent : IComponent
    {
        public Vector2 Position;
        public Vector2 Size;
        public Vector2 rotation;
    }
}

================
File: ECS_Principled/DataComponents/TransformComponent.cs.meta
================
fileFormatVersion: 2
guid: ff2e94255bc1f499a986a60df04d62ec
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/WorldStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct WorldStateComponent : IComponent
    {
        public float FirstNotePositionToTriggerSong;
    }
}

================
File: ECS_Principled/DataComponents/WorldStateComponent.cs.meta
================
fileFormatVersion: 2
guid: a5162f3c9a136cc41823dccde90295d3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DTO.meta
================
fileFormatVersion: 2
guid: c3e7f3ef03f524e6089d969eb175e299
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DTO/MusicNoteMidiData.cs
================
using UnityEngine;

public struct MusicNoteMidiData : IDataComponent
{
    // Core data arrays
    public int[] Ids;
    public int[] NoteNumbers;
    public int[] PositionIds;
    public float[] TimeAppears;
    public float[] Timespans;
    public float[] Durations;
    public float[] Velocities;

    // Metadata
    public int TotalNotes;
    public float MinDuration;

    public MusicNoteMidiData(int capacity)
    {
        // Preallocate arrays with specified capacity
        Ids = new int[capacity];
        NoteNumbers = new int[capacity];
        TimeAppears = new float[capacity];
        Timespans = new float[capacity];
        Durations = new float[capacity];
        Velocities = new float[capacity];
        PositionIds = new int[capacity];

        TotalNotes = 0;
        MinDuration = float.MaxValue;
    }
}

================
File: ECS_Principled/DTO/MusicNoteMidiData.cs.meta
================
fileFormatVersion: 2
guid: 0772d691d2fae418b83ddb22ddc64cc6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EGameState.cs
================
namespace ECS_MagicTile
{
    public enum EGameState
    {
        WaitingToStart,
        Ingame,
        Outro,
        All,
    }
}

================
File: ECS_Principled/EGameState.cs.meta
================
fileFormatVersion: 2
guid: ea96b7999d1692748b0c374877fef0d4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels.meta
================
fileFormatVersion: 2
guid: a808c7b858a7cf1459c4ba6cf1d5efe8
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/OnGameStartChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 84c124985c8ec984998e8fd8a7792f33, type: 3}
  m_Name: OnGameStartChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: ECS_Principled/EventChannels/OnGameStartChannel.asset.meta
================
fileFormatVersion: 2
guid: 44439b2ecef163c4e8e6b70a713339a8
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/OnOrientationChangeChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 20ec6d5789c44934380628f5b1389ae7, type: 3}
  m_Name: OnOrientationChangeChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: ECS_Principled/EventChannels/OnOrientationChangeChannel.asset.meta
================
fileFormatVersion: 2
guid: 2ceeecf601ad944f699e78a3f56a522e
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/OnSongStartChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a25d70a25c32e5b4b99a7e2929ad8cea, type: 3}
  m_Name: OnSongStartChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: ECS_Principled/EventChannels/OnSongStartChannel.asset.meta
================
fileFormatVersion: 2
guid: e44f33d26247cc141ae0b8696485f784
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/SO_ScoreSignalEffectChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 20ec6d5789c44934380628f5b1389ae7, type: 3}
  m_Name: SO_ScoreSignalEffectChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: ECS_Principled/EventChannels/SO_ScoreSignalEffectChannel.asset.meta
================
fileFormatVersion: 2
guid: ea0ef8d03bdeb4c4784bc02c8a47c318
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/SOScripts.meta
================
fileFormatVersion: 2
guid: 7b8aa6ae181e147d8af51b60d816fe7a
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/SOScripts/BoolEventChannel.cs
================
using UnityEngine;

namespace EventChannel
{
    [CreateAssetMenu(
        fileName = "sO_BoolEventChannel",
        menuName = "Event Channels/BoolEventChannel"
    )]
    public class BoolEventChannel : EventChannelSO<bool> { }
}

================
File: ECS_Principled/EventChannels/SOScripts/BoolEventChannel.cs.meta
================
fileFormatVersion: 2
guid: 20ec6d5789c44934380628f5b1389ae7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/SOScripts/IntEventChannel.cs
================
using UnityEngine;

namespace EventChannel
{
    [CreateAssetMenu(fileName = "IntEventChannel", menuName = "Event Channels/Int event channel")]
    public class IntEventChannel : EventChannelSO<int> { }
}

================
File: ECS_Principled/EventChannels/SOScripts/IntEventChannel.cs.meta
================
fileFormatVersion: 2
guid: 84c124985c8ec984998e8fd8a7792f33
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Functions.meta
================
fileFormatVersion: 2
guid: 640c8ae1ec4198a4e9afbf063ad8727d
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Functions/PreciseNoteCalculator.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    public static class PreciseNoteCalculator
    {
        /// <summary>
        /// Calculates the total song duration, in seconds, by summing the last
        /// note's appear time and duration.
        /// </summary>
        /// <param name="musicNoteMidiData">The parsed MIDI data to calculate the total duration from.</param>
        /// <returns>The total song duration, in seconds.</returns>
        ///
        public static float CalculateTotalSongDuration(MusicNoteMidiData musicNoteMidiData)
        {
            return musicNoteMidiData.TimeAppears[musicNoteMidiData.TotalNotes - 1]
                + musicNoteMidiData.Durations[musicNoteMidiData.TotalNotes - 1];
        }

        /// <summary>
        /// Finds the smallest note duration in the given MIDI data.
        /// </summary>
        /// <param name="musicNoteMidiData">The parsed MIDI data to find the smallest note duration from.</param>
        /// <param name="decimalPlaces">The number of decimal places to round the smallest duration to.</param>
        /// <returns>The smallest note duration, rounded to the specified number of decimal places.</returns>
        public static float FindSmallestNoteDuration(
            MusicNoteMidiData musicNoteMidiData,
            int decimalPlaces = 2
        )
        {
            if (musicNoteMidiData.TotalNotes == 0)
                return 0f;

            float smallestDuration = musicNoteMidiData.Durations[0];
            for (int i = 1; i < musicNoteMidiData.TotalNotes; i++)
            {
                smallestDuration = Mathf.Min(smallestDuration, musicNoteMidiData.Durations[i]);
            }

            return (float)Math.Round(smallestDuration, decimalPlaces);
        }

        /// <summary>
        /// Calculates the size of each note based on its duration compared to the smallest note duration.
        /// </summary>
        /// <param name="musicNoteMidiData">The parsed MIDI data to calculate the note sizes from.</param>
        /// <param name="baseSize">The base size of each note, to be scaled according to its duration.</param>
        /// <returns>An array of note sizes, where each size is relative to the smallest note duration.</returns>
        ///
        public static float[] CalculateNoteSizes(
            MusicNoteMidiData musicNoteMidiData,
            float baseSize = 2f
        )
        {
            float smallestDuration = FindSmallestNoteDuration(musicNoteMidiData, 2);
            float[] noteSizes = new float[musicNoteMidiData.TotalNotes];

            for (int i = 0; i < musicNoteMidiData.TotalNotes; i++)
            {
                noteSizes[i] = baseSize * (musicNoteMidiData.Durations[i] / smallestDuration);
            }

            return noteSizes;
        }

        public static float[] CalculateInitialPositions(
            MusicNoteMidiData midiData,
            float perfectLineY,
            float[] noteSizes,
            float baseSize = 2f
        )
        {
            float[] positions = new float[noteSizes.Length];
            if (noteSizes.Length == 0)
                return positions;

            // Position first note - add half its size to center point
            positions[0] = perfectLineY + (noteSizes[0] * 0.5f);
            float smallestDuration = FindSmallestNoteDuration(midiData, 2);

            // Position subsequent notes with proper gaps
            for (int i = 1; i < noteSizes.Length; i++)
            {
                // Start from previous note's center
                float pos = positions[i - 1];

                // Add half size of previous note (to get to its top)
                pos += noteSizes[i - 1] * 0.5f;

                // Calculate and add remaining gap space
                float remainingGap = midiData.Timespans[i] - midiData.Durations[i - 1];
                if (remainingGap > 0)
                {
                    // Convert time gap to space using velocity
                    float gapSpace = baseSize * (remainingGap / smallestDuration);
                    pos += gapSpace;
                }

                // Add half size of current note (to get to its center)
                pos += noteSizes[i] * 0.5f;

                positions[i] = pos;
            }

            return positions;
        }

        // Calculate road length from last note position and size
        public static float CalculateRoadLength(float[] noteSizes, MusicNoteMidiData midiData)
        {
            float totalLength = noteSizes[0]; // First note's size

            // Add subsequent notes' sizes and their gaps
            for (int i = 1; i < noteSizes.Length; i++)
            {
                // Add remaining gap space
                float remainingGap = midiData.Timespans[i] - midiData.Durations[i - 1];
                if (remainingGap > 0)
                {
                    // Estimate gap space relative to note sizes
                    float gapScale = remainingGap / midiData.Durations[i];
                    totalLength += noteSizes[i] * gapScale;
                }

                // Add current note's size
                totalLength += noteSizes[i];
            }

            return totalLength;
        }

        // Calculate velocity based on road length and total time
        public static float CalculateRequiredVelocity(float totalTime, float roadLength)
        {
            if (totalTime <= 0f)
                return 0f;
            return roadLength / totalTime;
        }
    }
}

================
File: ECS_Principled/Functions/PreciseNoteCalculator.cs.meta
================
fileFormatVersion: 2
guid: 0e15eb8261a3ad94583181063bec9b20
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts.meta
================
fileFormatVersion: 2
guid: eca84261f4209ea438546467839df383
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/AudioManager.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class AudioManager : MonoBehaviour
    {
        [SerializeField]
        private EmptyEventChannel onSongStartChannel;

        [SerializeField]
        private AudioClip audioClip;

        private AudioSource audioSource;

        void Start()
        {
            audioSource = GetComponent<AudioSource>();
            audioSource.clip = audioClip;
        }

        void OnEnable()
        {
            onSongStartChannel.Subscribe(OnGameStart);
        }

        private void OnGameStart(EmptyData data)
        {
            audioSource.PlayWithFadeIn(this, .8f);
        }
    }
}

================
File: ECS_Principled/MonoScripts/AudioManager.cs.meta
================
fileFormatVersion: 2
guid: 1a6eec2221ddc4ba2aadd917abe77374
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/BurstMovement.cs
================
using UnityEngine;

/// <summary>
/// Implements a customizable burst movement behavior where an object accelerates to a maximum speed,
/// maintains that speed for a configurable distance, then smoothly decelerates to a stop.
/// The movement uses exponential functions to create natural-feeling acceleration and deceleration.
/// </summary>
/// <remarks>
/// The movement is divided into two phases:
/// 1. Burst Phase: Object accelerates from initial speed to max speed using a smooth exponential curve
/// 2. Deceleration Phase: Object gradually slows down to a stop using natural exponential decay
///
/// Mathematical formulas used:
/// - Acceleration: speed = maxSpeed * (initialPercent + (1-initialPercent) * (1-e^(-aF * x)))
/// - Deceleration: speed = maxSpeed * e^(-dF * x)
/// Where:
/// - aF = acceleration factor
/// - dF = deceleration factor
/// - x = progress (0 to 1) in current phase
/// </remarks>
public class BurstMovement : MonoBehaviour
{
    [Header("Movement Properties")]
    [SerializeField]
    private Vector3 direction = Vector3.forward;

    [SerializeField]
    private float maxDistance = 10f;

    [Header("Speed Properties")]
    [SerializeField]
    private float maxSpeed = 10f;

    [SerializeField, Range(0.5f, 5f)]
    private float accelerationFactor = 2f;

    [SerializeField, Range(0.5f, 5f)]
    private float decelerationFactor = 1.5f;

    [Header("Burst Configuration")]
    [SerializeField, Range(0f, 100f)]
    private float burstEndPercentage = 50f;

    [SerializeField, Range(0f, 1f)]
    private float initialSpeedPercent = 0.1f;

    private Vector3 startPosition;
    private float currentSpeed;
    private bool hasStarted;

    /// <summary>
    /// Initializes the movement component by storing the starting position and normalizing the direction vector.
    /// </summary>
    private void Start()
    {
        startPosition = transform.position;
        direction = direction.normalized;
        hasStarted = true;

        Debug.Log(
            $"=== Initial Parameters ===\n"
                + $"Max Speed: {maxSpeed}\n"
                + $"Max Distance: {maxDistance}\n"
                + $"Acceleration Factor: {accelerationFactor}\n"
                + $"Deceleration Factor: {decelerationFactor}\n"
                + $"Direction: {direction}"
        );
    }

    /// <summary>
    /// Updates the object's position each frame based on the current movement phase and calculated speed.
    /// Handles progression through acceleration and deceleration phases until reaching the target distance.
    /// </summary>
    private void Update()
    {
        if (!hasStarted)
            return;

        float distanceTraveled = Vector3.Distance(transform.position, startPosition);
        float distancePercentage = (distanceTraveled / maxDistance) * 100f;

        if (distancePercentage >= 100f)
        {
            hasStarted = false;
            return;
        }

        currentSpeed = CalculateSpeed(distancePercentage);
        transform.position += direction * (currentSpeed * Time.deltaTime);
    }

    /// <summary>
    /// Calculates the current speed based on the percentage of total distance traveled.
    /// Uses different mathematical formulas for acceleration and deceleration phases.
    /// </summary>
    /// <param name="distancePercentage">Current distance traveled as a percentage (0-100) of total distance</param>
    /// <returns>The calculated speed for the current frame</returns>
    /// <remarks>
    /// During acceleration (0% to burstEndPercentage):
    /// - Starts at initialSpeedPercent of maxSpeed
    /// - Smoothly accelerates to maxSpeed using exponential approach
    ///
    /// During deceleration (burstEndPercentage to 100%):
    /// - Starts at maxSpeed
    /// - Exponentially decays to zero
    /// </remarks>
    private float CalculateSpeed(float distancePercentage)
    {
        // Acceleration phase
        if (distancePercentage <= burstEndPercentage)
        {
            float accelerationProgress = distancePercentage / burstEndPercentage;
            return maxSpeed
                * (
                    initialSpeedPercent
                    + (1f - initialSpeedPercent)
                        * (1f - Mathf.Exp(-accelerationFactor * accelerationProgress))
                );
        }
        // Deceleration phase
        else
        {
            float decelerationProgress =
                (distancePercentage - burstEndPercentage) / (100f - burstEndPercentage);
            return maxSpeed * Mathf.Exp(-decelerationFactor * decelerationProgress);
        }
    }

    /// <summary>
    /// Draws debug visualization in the Scene view to help understand the movement path and progress.
    /// </summary>
    private void OnDrawGizmos()
    {
        if (!Application.isPlaying)
            return;

        // Draw the full path
        Gizmos.color = Color.yellow;
        Gizmos.DrawLine(startPosition, startPosition + direction * maxDistance);

        // Draw burst end point
        Vector3 burstEndPoint =
            startPosition + direction * (maxDistance * burstEndPercentage / 100f);
        Gizmos.color = Color.blue;
        Gizmos.DrawWireSphere(burstEndPoint, 0.3f);

        // Draw current position
        Gizmos.color = Color.green;
        Gizmos.DrawWireSphere(transform.position, 0.2f);
    }
}

================
File: ECS_Principled/MonoScripts/BurstMovement.cs.meta
================
fileFormatVersion: 2
guid: 8e0f7f48d9c2e439db3417617e6b029a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/BurstMovementUIController.cs
================
using System.Linq;
using UnityEngine;

/// <summary>
/// A system-like controller that manages multiple UI elements with burst movement behavior.
/// This controller follows ECS principles by separating data (BurstMovementData) from behavior
/// while maintaining MonoBehaviour compatibility.
/// </summary>
/// <remarks>
/// The burst movement creates a dynamic motion effect where elements:
/// 1. Start with an initial speed
/// 2. Accelerate smoothly to maximum speed
/// 3. Maintain that speed for a configurable distance
/// 4. Decelerate naturally to a stop
///
/// The controller processes all movements in batches for better performance
/// and provides default values that can be overridden per element.
/// </remarks>
public class BurstMovementUIController : MonoBehaviour
{
    private BurstMovementElement[] movementElements;

    [Header("Default Values")]
    [SerializeField]
    private float defaultMaxSpeed = 500f;

    [SerializeField]
    private float defaultAccelerationFactor = 2f;

    [SerializeField]
    private float defaultDecelerationFactor = 1.5f;

    [SerializeField]
    private float defaultBurstEndPercentage = 50f;

    [SerializeField]
    private float defaultInitialSpeedPercent = 0.1f;

    private Vector2[] cachedStartPosition;

    /// <summary>
    /// Initializes all movement elements when the controller starts.
    /// Sets up initial positions and applies default values where needed.
    /// </summary>
    public void InitializeElement(BurstMovementElement[] burstMovementElements)
    {
        movementElements = burstMovementElements;
        cachedStartPosition = new Vector2[movementElements.Length];
        int index = 0;
        foreach (var element in movementElements)
        {
            // Store initial position and normalize direction for consistent movement
            element.data.startPosition = element.target.anchoredPosition;
            element.data.direction = element.data.direction.normalized;
            element.data.hasStarted = true;
            element.data.isFinished = false;
            cachedStartPosition[index] = element.target.anchoredPosition;
            index++;

            ApplyDefaultsIfNeeded(ref element.data);
        }
        //Make all elements not move at start
        StopAll();
    }

    /// <summary>
    /// Applies default values to any unset or invalid movement parameters.
    /// This ensures all elements have valid movement settings even if not explicitly configured.
    /// </summary>
    /// <param name="data">Reference to the movement data to validate and update</param>
    private void ApplyDefaultsIfNeeded(ref BurstMovementData data)
    {
        if (data.maxSpeed <= 0)
            data.maxSpeed = defaultMaxSpeed;
        if (data.accelerationFactor <= 0)
            data.accelerationFactor = defaultAccelerationFactor;
        if (data.decelerationFactor <= 0)
            data.decelerationFactor = defaultDecelerationFactor;
        if (data.burstEndPercentage <= 0)
            data.burstEndPercentage = defaultBurstEndPercentage;
        if (data.initialSpeedPercent <= 0)
            data.initialSpeedPercent = defaultInitialSpeedPercent;
    }

    /// <summary>
    /// Processes movement updates for all active elements each frame.
    /// Follows a system-like approach by batch processing all movements.
    /// </summary>
    private void Update()
    {
        if (movementElements.Length == 0)
            return;

        foreach (var element in movementElements)
        {
            if (!element.data.hasStarted || element.data.isFinished)
                continue;
            ProcessMovement(element);
        }
    }

    /// <summary>
    /// Updates the position of a single movement element based on its current state and configuration.
    /// </summary>
    /// <param name="element">The movement element to process</param>
    private void ProcessMovement(BurstMovementElement element)
    {
        // Calculate how far we've moved as a percentage of total distance
        float distanceTraveled = Vector2.Distance(
            element.target.anchoredPosition,
            element.data.startPosition
        );
        float distancePercentage = (distanceTraveled / element.data.maxDistance) * 100f;

        // Check if we've reached our destination
        if (distancePercentage >= 100f)
        {
            element.data.isFinished = true;
            return;
        }

        // Calculate and apply movement for this frame
        element.data.currentSpeed = CalculateSpeed(distancePercentage, element.data);
        Vector2 newPosition =
            (Vector2)element.target.anchoredPosition
            + element.data.direction * (element.data.currentSpeed * Time.deltaTime);

        element.target.anchoredPosition = newPosition;
    }

    /// <summary>
    /// Calculates the current speed based on distance percentage using exponential curves
    /// for smooth acceleration and deceleration.
    /// </summary>
    /// <param name="distancePercentage">Current distance as percentage of total (0-100)</param>
    /// <param name="data">Movement configuration data</param>
    /// <returns>The calculated speed for the current frame</returns>
    /// <remarks>
    /// The speed calculation uses two different exponential curves:
    /// - Acceleration: speed = maxSpeed * (initial + (1-initial) * (1-e^(-aF * x)))
    /// - Deceleration: speed = maxSpeed * e^(-dF * x)
    /// Where:
    /// - aF = acceleration factor
    /// - dF = deceleration factor
    /// - x = progress (0 to 1) in current phase
    /// </remarks>
    private float CalculateSpeed(float distancePercentage, BurstMovementData data)
    {
        // Acceleration phase
        if (distancePercentage <= data.burstEndPercentage)
        {
            float accelerationProgress = distancePercentage / data.burstEndPercentage;
            // Use exponential approach for smooth acceleration
            return data.maxSpeed
                * (
                    data.initialSpeedPercent
                    + (1f - data.initialSpeedPercent)
                        * (1f - Mathf.Exp(-data.accelerationFactor * accelerationProgress))
                );
        }
        // Deceleration phase
        else
        {
            float decelerationProgress =
                (distancePercentage - data.burstEndPercentage) / (100f - data.burstEndPercentage);
            // Use exponential decay for natural-feeling deceleration
            return data.maxSpeed * Mathf.Exp(-data.decelerationFactor * decelerationProgress);
        }
    }

    /// <summary>
    /// Starts movement for all elements in the controller.
    /// </summary>
    public void StartAll()
    {
        foreach (var element in movementElements)
        {
            element.data.hasStarted = true;
            element.data.isFinished = false;
        }
    }

    /// <summary>
    /// Stops movement for all elements in the controller.
    /// </summary>
    public void StopAll()
    {
        foreach (var element in movementElements)
        {
            element.data.hasStarted = false;
        }
    }

    public void ResetAll()
    {
        for (int i = 0; i < cachedStartPosition.Length; i++)
        {
            movementElements[i].target.anchoredPosition = cachedStartPosition[i];
        }
    }

    /// <summary>
    /// Represents the configuration and runtime data for a single burst movement.
    /// Separates data from behavior following ECS principles.
    /// </summary>
    [System.Serializable]
    public struct BurstMovementData
    {
        public Vector2 direction; // Movement direction (will be normalized)
        public float maxDistance; // Total distance to travel

        public float maxSpeed; // Maximum movement speed during burst

        [Range(0.5f, 5)]
        public float accelerationFactor; // Controls how quickly max speed is reached

        [Range(0.5f, 5)]
        public float decelerationFactor; // Controls how quickly speed reduces after burst

        [Range(0f, 70f)]
        public float burstEndPercentage; // When to transition from burst to deceleration (% of total distance)

        [Range(0, 1)]
        public float initialSpeedPercent; // Starting speed as percentage of max speed

        // Runtime data - hidden from inspector
        [HideInInspector]
        public Vector2 startPosition;

        [HideInInspector]
        public float currentSpeed;

        [HideInInspector]
        public bool hasStarted;

        [HideInInspector]
        public bool isFinished;
    }

    /// <summary>
    /// Combines a UI element target with its movement configuration.
    /// </summary>
    [System.Serializable]
    public class BurstMovementElement
    {
        public RectTransform target; // The UI element to move
        public BurstMovementData data; // Movement configuration and runtime data
    }
}

================
File: ECS_Principled/MonoScripts/BurstMovementUIController.cs.meta
================
fileFormatVersion: 2
guid: 16ca30dd2c053408ca1f8899ec5e4e9e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/CrownTween.cs
================
using PrimeTween;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class CrownTween : MonoBehaviour
    {
        [SerializeField]
        private CrownProperties defaultValue;
        private CrownProperties[] crowns;
        private CrownProperties currentCrown;
        private int currentCrownIndexToProcess;

        public void InitializeCrowns(CrownProperties[] crownProperties)
        {
            this.crowns = crownProperties;
            currentCrownIndexToProcess = 0;
            Color color;

            for (int i = 0; i < crowns.Length; i++)
            {
                color = crowns[i].crownAwakenedImg.color;
                color.a = 0;
                ;
                crowns[i].crownAwakenedImg.color = color;
            }
        }

        public void PlayEffect()
        {
            currentCrown = crowns[currentCrownIndexToProcess];

            Tween
                .Scale(
                    target: currentCrown.crownRect,
                    startValue: currentCrown.scaleStartValue,
                    endValue: currentCrown.scaleMidValue,
                    duration: currentCrown.firstPhaseDuration,
                    ease: currentCrown.firstPhaseEase
                )
                .Group(
                    Tween.Scale(
                        target: currentCrown.crownAwakenedImg.rectTransform,
                        startValue: currentCrown.awakenedScaleStart,
                        endValue: currentCrown.awakenedScaleMid,
                        duration: currentCrown.firstPhaseDuration,
                        ease: currentCrown.firstPhaseEase
                    )
                )
                .Group(
                    Tween.Alpha(
                        target: currentCrown.crownAwakenedImg,
                        startValue: currentCrown.alphaStart,
                        endValue: currentCrown.alphaMid,
                        duration: currentCrown.firstPhaseDuration,
                        ease: currentCrown.firstPhaseEase
                    )
                )
                .Chain(
                    Tween
                        .Scale(
                            target: currentCrown.crownRect,
                            startValue: currentCrown.scaleMidValue,
                            endValue: currentCrown.scaleEndValue,
                            duration: currentCrown.secondPhaseDuration,
                            ease: currentCrown.secondPhaseEase
                        )
                        .Group(
                            Tween.Scale(
                                target: currentCrown.crownAwakenedImg.rectTransform,
                                startValue: currentCrown.awakenedScaleMid,
                                endValue: currentCrown.awakenedScaleEnd,
                                duration: currentCrown.secondPhaseDuration,
                                ease: currentCrown.secondPhaseEase
                            )
                        )
                        .Group(
                            Tween.Alpha(
                                target: currentCrown.crownAwakenedImg,
                                startValue: currentCrown.alphaMid,
                                endValue: currentCrown.alphaEnd,
                                duration: currentCrown.secondPhaseDuration,
                                ease: currentCrown.secondPhaseEase
                            )
                        )
                );
            currentCrownIndexToProcess++;
        }

        public bool IsAbleToPlay()
        {
            return currentCrownIndexToProcess < crowns.Length;
        }

        [System.Serializable]
        public class CrownProperties
        {
            [Header("Crown")]
            public RectTransform crownRect;
            public Image crownAwakenedImg;

            [Header("Scale properties")]
            public float scaleStartValue = 1f;
            public float scaleMidValue = 1.5f;
            public float scaleEndValue = 1f;

            [Header("Image awakened alpha properties")]
            public float awakenedScaleStart = 1f;
            public float awakenedScaleMid = 1.8f;
            public float awakenedScaleEnd = 1;
            public float alphaStart = 0;
            public float alphaMid = .5f;
            public float alphaEnd = 1f;

            [Header("Phase paremeters")]
            public float firstPhaseDuration = .4f;
            public Ease firstPhaseEase = Ease.OutCubic;
            public float secondPhaseDuration = .2f;
            public Ease secondPhaseEase = Ease.Linear;
        }
    }
}

================
File: ECS_Principled/MonoScripts/CrownTween.cs.meta
================
fileFormatVersion: 2
guid: 393ae28e0cc2e064691c4148f9fa023e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/EffectOnProgress.cs
================
using PrimeTween;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EffectOnProgress : MonoBehaviour
    {
        [SerializeField]
        private Vector2 startScale;

        [SerializeField]
        private Vector2 endScale;

        [SerializeField]
        private float duration;
        private RectTransform rectTransform;

        void Awake()
        {
            rectTransform = GetComponent<RectTransform>();
        }

        void Start()
        {
            Sequence
                .Create(cycles: -1)
                .Chain(
                    Tween.Scale(
                        target: rectTransform,
                        startValue: startScale,
                        endValue: endScale,
                        duration: duration,
                        ease: Ease.Linear
                    )
                )
                .Chain(
                    Tween.Scale(
                        target: rectTransform,
                        endValue: startScale,
                        duration: duration,
                        ease: Ease.Linear
                    )
                );
        }
    }
}

================
File: ECS_Principled/MonoScripts/EffectOnProgress.cs.meta
================
fileFormatVersion: 2
guid: 5bb97036fc31048bc8738dc49725bd85
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/ProgressEffectController.cs
================
using EventChannel;
using PrimeTween;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    [RequireComponent(typeof(StarTween))]
    [RequireComponent(typeof(CrownTween))]
    public class ProgressEffectController : MonoBehaviour
    {
        [SerializeField]
        private Slider progressSlider;

        [SerializeField]
        private RectTransform[] progressPoints;

        [SerializeField]
        private StarTween.StarProperties[] starPoints;

        [SerializeField]
        private CrownTween.CrownProperties[] crownPoints;

        private RectTransform progressSliderRect;

        private float[] segmentValues;

        private int currentPassedSegmentPoint;

        private StarTween starTween;
        private CrownTween crownTween;

        void Awake()
        {
            starTween = GetComponent<StarTween>();
            starTween.InitializeStars(starPoints);

            crownTween = GetComponent<CrownTween>();
            crownTween.InitializeCrowns(crownPoints);
        }

        void OnEnable()
        {
            progressSlider.onValueChanged.AddListener(OnProgressValueChanged);
        }

        void OnDisable()
        {
            progressSlider.onValueChanged.RemoveListener(OnProgressValueChanged);
        }

        void Start()
        {
            SetupPoints();
        }

        void OnValidate()
        {
            SetupPoints();
        }

        private void SetupPoints()
        {
            if (progressPoints.Length == 0 || progressSlider == null)
            {
                return;
            }

            if (progressSliderRect == null)
            {
                progressSliderRect = progressSlider.GetComponent<RectTransform>();
            }

            int pointCount = progressPoints.Length;
            float sliderWidth = progressSliderRect.sizeDelta.x;
            float segmentWidth = sliderWidth / pointCount;
            float baseSegmentValue = 1f / pointCount;

            segmentValues = new float[pointCount];

            for (int i = 0; i < progressPoints.Length; i++)
            {
                if (progressPoints[i] == null)
                    continue;
                progressPoints[i].anchoredPosition = new Vector2(
                    segmentWidth * (i + 1),
                    progressPoints[i].anchoredPosition.y
                );

                segmentValues[i] = (i + 1) * baseSegmentValue;
            }

            currentPassedSegmentPoint = 1;
        }

        private void OnProgressValueChanged(float value)
        {
            int index = currentPassedSegmentPoint - 1;

            if (value >= segmentValues[index])
            {
                if (starTween.IsAbleToPlay())
                {
                    starTween.PlayEffect();
                }
                else if (crownTween.IsAbleToPlay())
                {
                    crownTween.PlayEffect();
                }

                currentPassedSegmentPoint++;
            }
        }
    }
}

================
File: ECS_Principled/MonoScripts/ProgressEffectController.cs.meta
================
fileFormatVersion: 2
guid: 674545824a7a6ba4da646968bb607983
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/RaycastToObjects.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class RaycastToStartGame : MonoBehaviour
    {
        [SerializeField]
        private LayerMask targetLayer;

        [SerializeField]
        private IntEventChannel OnGameStartChannel;

        // Update is called once per frame
        void Update()
        {
            if (Input.GetMouseButtonDown(0))
            {
                FireRaycast();
            }
        }

        private void FireRaycast()
        {
            Vector2 mousePosition = Camera.main.ScreenToWorldPoint(Input.mousePosition);
            RaycastHit2D hit = Physics2D.Raycast(
                mousePosition,
                Vector2.zero,
                Mathf.Infinity,
                targetLayer
            );

            if (hit.collider != null)
            {
                if (hit.collider.tag == "StartNote")
                {
                    OnGameStartChannel?.RaiseEvent(
                        hit.collider.GetComponent<IEntityHolder>().EntityId
                    );
                }
            }
            else
            {
                Debug.Log("No object hit.");
            }
        }
    }
}

================
File: ECS_Principled/MonoScripts/RaycastToObjects.cs.meta
================
fileFormatVersion: 2
guid: 2b6518ec189777e4cbad7fdd60b44c76
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/ScoreEffectController.cs
================
using System;
using EventChannel;
using PrimeTween;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class ScoreEffectController : MonoBehaviour
    {
        [Header("Event Channels")]
        [SerializeField]
        private BoolEventChannel scoreSignalEffectChannel;

        [Header("Main Effect components")]
        [SerializeField]
        private CanvasGroup perfectScorePrefab;

        [SerializeField]
        private CanvasGroup greatScorePrefab;

        [Header("Burst Movement Setup")]
        [SerializeField]
        private BurstMovementUIController burstMovementUIController;

        [SerializeField]
        private BurstMovementUIController.BurstMovementElement[] burstMovementElements;
        private Sequence effectSequence;

        void Awake()
        {
            burstMovementUIController.InitializeElement(burstMovementElements);
        }

        void OnEnable()
        {
            scoreSignalEffectChannel.Subscribe(PlayEffect);
        }

        void OnDisable()
        {
            scoreSignalEffectChannel.Unsubscribe(PlayEffect);
        }

        private void PlayEffect(bool isPerfect)
        {
            effectSequence.Stop();

            burstMovementUIController?.ResetAll();
            burstMovementUIController?.StartAll();
            perfectScorePrefab.alpha = 1;

            for (int i = 1; i < burstMovementElements.Length; i++)
            {
                burstMovementElements[i].target.rotation = Quaternion.Euler(
                    0,
                    0,
                    UnityEngine.Random.Range(0, 360)
                );
            }

            effectSequence = Tween
                .Scale(
                    target: perfectScorePrefab.transform,
                    startValue: Vector3.zero,
                    endValue: Vector3.one,
                    duration: 0.2f,
                    ease: Ease.Linear
                )
                .Chain(
                    Tween
                        .Delay(duration: 0.5f)
                        .Chain(
                            Tween
                                .Alpha(
                                    target: perfectScorePrefab,
                                    startValue: 1f,
                                    endValue: 0f,
                                    duration: 0.5f,
                                    ease: Ease.Linear
                                )
                                .OnComplete(() =>
                                {
                                    burstMovementUIController.StopAll();
                                })
                        )
                );
        }
    }
}

================
File: ECS_Principled/MonoScripts/ScoreEffectController.cs.meta
================
fileFormatVersion: 2
guid: 4c404b5dc2d1b3243807aa10259f386a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/ScreenManager.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ScreenManager : PersistentSingleton<ScreenManager>
    {
        [SerializeField]
        private BoolEventChannel OnOrientationChange;

        public bool IsPortrait { get; private set; }

        void Start()
        {
            IsPortrait = Screen.currentResolution.width > Screen.currentResolution.height;
        }

        private void Update()
        {
            if (Screen.currentResolution.width < Screen.currentResolution.height)
            {
                if (!IsPortrait)
                {
                    IsPortrait = true;
                    OnOrientationChange.RaiseEvent(true);
                }
            }
            else
            {
                if (IsPortrait)
                {
                    IsPortrait = false;
                    OnOrientationChange.RaiseEvent(false);
                }
            }
        }
    }
}

================
File: ECS_Principled/MonoScripts/ScreenManager.cs.meta
================
fileFormatVersion: 2
guid: b5f3dbf897bb5481aa2da1550e237f93
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/StarTween.cs
================
using System;
using PrimeTween;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class StarTween : MonoBehaviour
    {
        [SerializeField]
        private StarProperties defaultValue;
        private StarProperties[] stars;
        private int currentStarIndexToProcess;

        StarProperties currentStar;

        public void InitializeStars(StarProperties[] stars)
        {
            this.stars = stars;
            currentStarIndexToProcess = 0;
            Color color;
            for (int i = 0; i < stars.Length; i++)
            {
                color = stars[i].starAwakenedImg.color;
                color.a = 0;
                ;
                stars[i].starAwakenedImg.color = color;
            }
        }

        public void PlayEffect()
        {
            currentStar = stars[currentStarIndexToProcess];

            Tween
                .Scale(
                    target: currentStar.starRect,
                    startValue: currentStar.scaleStartValue,
                    endValue: currentStar.scaleMidValue,
                    duration: currentStar.firstPhaseDuration,
                    ease: currentStar.firstPhaseEase
                )
                .Group(
                    Tween.Rotation(
                        target: currentStar.starRect,
                        startValue: currentStar.rotationStartValue,
                        endValue: currentStar.rotationMidValue,
                        duration: currentStar.firstPhaseDuration,
                        ease: currentStar.firstPhaseEase
                    )
                )
                .Group(
                    Tween.Alpha(
                        target: currentStar.starAwakenedImg,
                        startValue: currentStar.alphaStart,
                        endValue: currentStar.alphaMid,
                        duration: currentStar.firstPhaseDuration,
                        ease: currentStar.firstPhaseEase
                    )
                )
                .Group(
                    Tween.Scale(
                        target: currentStar.starAwakenedImg.rectTransform,
                        startValue: currentStar.awakenedScaleStart,
                        endValue: currentStar.awakenedScaleMid,
                        duration: currentStar.firstPhaseDuration,
                        ease: currentStar.firstPhaseEase
                    )
                )
                .Chain(
                    Tween
                        .Scale(
                            target: currentStar.starRect,
                            startValue: currentStar.scaleMidValue,
                            endValue: currentStar.scaleEndValue,
                            duration: currentStar.secondPhaseDuration,
                            ease: currentStar.secondPhaseEase
                        )
                        .Group(
                            Tween.Rotation(
                                target: currentStar.starRect,
                                startValue: currentStar.rotationMidValue,
                                endValue: currentStar.rotationEndValue,
                                duration: currentStar.secondPhaseDuration,
                                ease: currentStar.secondPhaseEase
                            )
                        )
                        .Group(
                            Tween.Alpha(
                                target: currentStar.starAwakenedImg,
                                startValue: currentStar.alphaMid,
                                endValue: currentStar.alphaEnd,
                                duration: currentStar.secondPhaseDuration,
                                ease: currentStar.secondPhaseEase
                            )
                        )
                        .Group(
                            Tween.Scale(
                                target: currentStar.starAwakenedImg.rectTransform,
                                startValue: currentStar.awakenedScaleMid,
                                endValue: currentStar.awakenedScaleEnd,
                                duration: currentStar.secondPhaseDuration,
                                ease: currentStar.secondPhaseEase
                            )
                        )
                );
            currentStarIndexToProcess++;
        }

        public bool IsAbleToPlay()
        {
            return currentStarIndexToProcess < stars.Length;
        }

        [Serializable]
        public class StarProperties
        {
            [Header("Star")]
            public RectTransform starRect;
            public Image starAwakenedImg;

            [Header("Scale properties")]
            public float scaleStartValue = 1f;
            public float scaleMidValue = 1.5f;
            public float scaleEndValue = 1f;

            [Header("Rotation properties")]
            public Vector3 rotationStartValue = new Vector3(0, 0, -180);
            public Vector3 rotationMidValue = new Vector3(0, 0, -240);
            public Vector3 rotationEndValue = new Vector3(0, 0, -360);

            [Header("Image awakened alpha properties")]
            public float awakenedScaleStart = 1f;
            public float awakenedScaleMid = 1.8f;
            public float awakenedScaleEnd = 1;
            public float alphaStart = 0;
            public float alphaMid = .5f;
            public float alphaEnd = 1f;

            [Header("Phase paremeters")]
            public float firstPhaseDuration = .4f;
            public Ease firstPhaseEase = Ease.OutCubic;
            public float secondPhaseDuration = .2f;
            public Ease secondPhaseEase = Ease.Linear;
        }
    }
}

================
File: ECS_Principled/MonoScripts/StarTween.cs.meta
================
fileFormatVersion: 2
guid: 6510a45b25480bc44839f20bff11111d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/VerticalLineSetup.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public class VerticalLineSetup : MonoBehaviour
    {
        private RectTransform[] verticalLines;
    }
}

================
File: ECS_Principled/MonoScripts/VerticalLineSetup.cs.meta
================
fileFormatVersion: 2
guid: a2bf9baa3aab15a4da083e100b25e8d4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-20T10:27:04.525Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
Core/
  Archetype.cs
  Archetype.cs.meta
  ArchetypeStorage.cs
  ArchetypeStorage.cs.meta
  ArchetypeSyncer.cs
  ArchetypeSyncer.cs.meta
  BaseSyncTool.cs
  BaseSyncTool.cs.meta
  ComponentType.cs
  ComponentType.cs.meta
  EntityIdHolder.cs
  EntityIdHolder.cs.meta
  EntityViewFactory.cs
  EntityViewFactory.cs.meta
  GlobalPoint.cs
  GlobalPoint.cs.meta
  IComponent.cs
  IComponent.cs.meta
  IEntityHolder.cs
  IEntityHolder.cs.meta
  IGameSystem.cs
  IGameSystem.cs.meta
  StorageManager.cs
  StorageManager.cs.meta
  SystemRegistry.cs
  SystemRegistry.cs.meta
  World.cs
  World.cs.meta
DataComponents/
  ActiveStateComponent.cs
  ActiveStateComponent.cs.meta
  CornerComponent.cs
  CornerComponent.cs.meta
  GraphicComponent.cs
  GraphicComponent.cs.meta
  InputStateComponent.cs
  InputStateComponent.cs.meta
  LongNoteTagComponent.cs
  LongNoteTagComponent.cs.meta
  MusicNoteComponent.cs
  MusicNoteComponent.cs.meta
  MusicNoteFillerComponent.cs
  MusicNoteFillerComponent.cs.meta
  MusicNoteInteractionComponent.cs
  MusicNoteInteractionComponent.cs.meta
  PerfectLineTagComponent.cs
  PerfectLineTagComponent.cs.meta
  ProgressComponent.cs
  ProgressComponent.cs.meta
  ScoreComponent.cs
  ScoreComponent.cs.meta
  ScoreEffectComponent.cs
  ScoreEffectComponent.cs.meta
  ScoreStateComponent.cs
  ScoreStateComponent.cs.meta
  ShortNoteTagComponent.cs
  ShortNoteTagComponent.cs.meta
  StartingNoteTagComponent.cs
  StartingNoteTagComponent.cs.meta
  TransformComponent.cs
  TransformComponent.cs.meta
  WorldStateComponent.cs
  WorldStateComponent.cs.meta
DTO/
  MusicNoteMidiData.cs
  MusicNoteMidiData.cs.meta
EventChannels/
  SOScripts/
    BoolEventChannel.cs
    BoolEventChannel.cs.meta
    IntEventChannel.cs
    IntEventChannel.cs.meta
  OnGameStartChannel.asset
  OnGameStartChannel.asset.meta
  OnOrientationChangeChannel.asset
  OnOrientationChangeChannel.asset.meta
  OnSongStartChannel.asset
  OnSongStartChannel.asset.meta
  SO_ScoreSignalEffectChannel.asset
  SO_ScoreSignalEffectChannel.asset.meta
  SOScripts.meta
Functions/
  PreciseNoteCalculator.cs
  PreciseNoteCalculator.cs.meta
MonoScripts/
  AudioManager.cs
  AudioManager.cs.meta
  BurstMovement.cs
  BurstMovement.cs.meta
  BurstMovementUIController.cs
  BurstMovementUIController.cs.meta
  CrownTween.cs
  CrownTween.cs.meta
  EffectOnProgress.cs
  EffectOnProgress.cs.meta
  ProgressEffectController.cs
  ProgressEffectController.cs.meta
  RaycastToObjects.cs
  RaycastToObjects.cs.meta
  ScoreEffectController.cs
  ScoreEffectController.cs.meta
  ScreenManager.cs
  ScreenManager.cs.meta
  StarTween.cs
  StarTween.cs.meta
  VerticalLineSetup.cs
  VerticalLineSetup.cs.meta
Settings/
  SO_SCripts/
    GeneralGameSetting.cs
    GeneralGameSetting.cs.meta
    LaneLineSettings.cs
    LaneLineSettings.cs.meta
    MidiNoteParser.cs
    MidiNoteParser.cs.meta
    MusicNoteCreationSetting.cs
    MusicNoteCreationSetting.cs.meta
    PerfectLineSetting.cs
    PerfectLineSetting.cs.meta
    ScoreEffectSettings.cs
    ScoreEffectSettings.cs.meta
  GeneralGameSetting_SO.asset
  GeneralGameSetting_SO.asset.meta
  LaneLineSettings_SO.asset
  LaneLineSettings_SO.asset.meta
  MusicNoteCreationSetting_SO.asset
  MusicNoteCreationSetting_SO.asset.meta
  PerfectLineSetting_SO.asset
  PerfectLineSetting_SO.asset.meta
  ScoreEffectSettings_SO.asset
  ScoreEffectSettings_SO.asset.meta
  SO_SCripts.meta
Syncers/
  GameScoreSyncTool.cs
  GameScoreSyncTool.cs.meta
  LaneLineSyncTool.cs
  LaneLineSyncTool.cs.meta
  MusicNoteSyncer.cs
  MusicNoteSyncer.cs.meta
  MusicNoteViewSyncTool.cs
  MusicNoteViewSyncTool.cs.meta
  PerfectLineSyncTool.cs
  PerfectLineSyncTool.cs.meta
  ProgressSyncer.cs
  ProgressSyncer.cs.meta
  ProgressSyncTool.cs
  ProgressSyncTool.cs.meta
  ScoreUISyncer.cs
  ScoreUISyncer.cs.meta
  StartingNoteSyncer.cs
  StartingNoteSyncer.cs.meta
  StartingNoteSyncTool.cs
  StartingNoteSyncTool.cs.meta
Systems/
  GameStateSystem.cs
  GameStateSystem.cs.meta
  InputCollisionSystem.cs
  InputCollisionSystem.cs.meta
  InputSystem.cs
  InputSystem.cs.meta
  LaneLineSystem.cs
  LaneLineSystem.cs.meta
  MovingNoteSystem.cs
  MovingNoteSystem.cs.meta
  MusicNoteCreationSystem.cs
  MusicNoteCreationSystem.cs.meta
  PerfectLineSystem.cs
  PerfectLineSystem.cs.meta
  ProgressSystem.cs
  ProgressSystem.cs.meta
  ScoringSystem.cs
  ScoringSystem.cs.meta
  SingletonCreationSystem.cs
  SingletonCreationSystem.cs.meta
  StartingNoteSystem.cs
  StartingNoteSystem.cs.meta
  TraceNoteToTriggerSongSystem.cs
  TraceNoteToTriggerSongSystem.cs.meta
Core.meta
DataComponents.meta
DTO.meta
EGameState.cs
EGameState.cs.meta
EventChannels.meta
Functions.meta
MonoScripts.meta
Settings.meta
Syncers.meta
Systems.meta

================================================================
Repository Files
================================================================

================
File: Core/Archetype.cs
================
using System;
using System.Linq;

namespace ECS_MagicTile
{
    public class Archetype
    {
        private readonly ComponentType[] types;
        private readonly int hash;
        private readonly bool isAspect;

        public bool IsAspect => isAspect;

        private Archetype(ComponentType[] types, bool isAspect = false)
        {
            // Store types in a fixed order for consistent hashing
            this.types = types.OrderBy(t => t.Id).ToArray();
            this.hash = CalculateHash(this.types);
            this.isAspect = isAspect;
        }

        // Utility methods for archetype management
        public ReadOnlySpan<ComponentType> GetTypes() => types;

        public int GetHash() => hash;

        private static int CalculateHash(ComponentType[] types)
        {
            // Simple but effective hash calculation for fixed component combinations
            int hash = 17;
            foreach (var type in types)
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        // Game-specific archetypes
        public static class Registry
        {
            // Note archetypes
            public static readonly Archetype MusicNote =
                new(
                    new[]
                    {
                        ComponentType.Registry.Transform,
                        ComponentType.Registry.MusicNote,
                        ComponentType.Registry.Corner, // Added CornerComponent
                        ComponentType.Registry.MusicNoteInteraction,
                        ComponentType.Registry.MusicNoteFiller,
                        ComponentType.Registry.NoteScoreState,
                    }
                );

            // Game setup archetypes
            public static readonly Archetype PerfectLine =
                new(
                    new[]
                    {
                        ComponentType.Registry.Transform,
                        ComponentType.Registry.PerfectLine,
                        ComponentType.Registry.Corner,
                    }
                );

            public static readonly Archetype Input = new(new[] { ComponentType.Registry.Input });
            public static readonly Archetype StartingNote =
                new(
                    new[]
                    {
                        ComponentType.Registry.Transform,
                        ComponentType.Registry.ActiveState,
                        ComponentType.Registry.StartingNote,
                    }
                );

            public static readonly Archetype GameScore =
                new(
                    new[]
                    {
                        ComponentType
                            .Registry
                            .GameScore // New score component
                        ,
                    }
                );

            public static readonly Archetype SongProgress =
                new(new[] { ComponentType.Registry.Progress });

            public static readonly Archetype LaneLines =
                new(new[] { ComponentType.Registry.Transform });

            public static readonly Archetype WorldState =
                new(new[] { ComponentType.Registry.WorldState });

            // Keep track of all archetypes for initialization
            private static readonly Archetype[] AllArchetypes =
            {
                MusicNote,
                PerfectLine,
                Input,
                StartingNote,
                GameScore,
                SongProgress,
                LaneLines,
                WorldState,
            };

            public static ReadOnlySpan<Archetype> GetAllArchetypes() => AllArchetypes;
        }
    }
}

================
File: Core/Archetype.cs.meta
================
fileFormatVersion: 2
guid: 6a700f18bf185134ebcd378e0ebfe28f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/ArchetypeStorage.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_MagicTile
{
    public class ArchetypeStorage
    {
        // Store component arrays indexed by their ComponentType
        private readonly Dictionary<ComponentType, Array> componentArrays;
        private int[] entityIds; // Tracks which entities are in this storage
        private readonly Dictionary<int, int> entityToIndex = new Dictionary<int, int>();
        private int count; // Number of active entities

        private const int DEFAULT_CAPACITY = 64; // Starting size for our arrays
        private const float GROWTH_FACTOR = 2.0f; // How much to grow when we need more space

        public ArchetypeStorage(Archetype archetype, int initialCapacity = DEFAULT_CAPACITY)
        {
            componentArrays = new Dictionary<ComponentType, Array>();

            // Create typed arrays for each component in the archetype
            foreach (var componentType in archetype.GetTypes())
            {
                // Creates an array of the proper type with our initial capacity
                componentArrays[componentType] = Array.CreateInstance(
                    componentType.Type,
                    initialCapacity
                );
            }

            entityIds = new int[initialCapacity];

            count = 0;
        }

        // Provides type-safe access to component arrays
        public T[] GetComponents<T>()
            where T : struct
        {
            var componentType = ComponentType.Registry.GetComponentType<T>();
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {typeof(T)} not found in archetype"
                );
            }
            return (T[])array;
        }

        // Adds an entity with its components to this storage
        public void Add(int entityId, ReadOnlySpan<object> components)
        {
            // Grow arrays if needed
            if (count >= entityIds.Length)
            {
                Grow();
            }

            // Add components to their respective arrays
            int componentIndex = 0;
            foreach (var array in componentArrays.Values)
            {
                Array.Copy(new[] { components[componentIndex] }, 0, array, count, 1);
                componentIndex++;
            }

            // Track the entity
            entityIds[count] = entityId;
            entityToIndex[entityId] = count;
            count++;
        }

        // Efficiently removes an entity by swapping with the last element
        public void Remove(int entityId)
        {
            // Find the entity's index
            int index = Array.IndexOf(entityIds, entityId, 0, count);
            if (index == -1)
                return;

            // If it's not the last element, swap with the last one
            int lastIndex = count - 1;
            if (index < lastIndex)
            {
                foreach (var array in componentArrays.Values)
                {
                    Array.Copy(array, lastIndex, array, index, 1);
                }
                entityIds[index] = entityIds[lastIndex];
                entityToIndex[entityIds[lastIndex]] = index;
            }

            entityToIndex.Remove(entityId);
            count--;
        }

        private void Grow()
        {
            int newCapacity = (int)(entityIds.Length * GROWTH_FACTOR);

            // Grow all component arrays
            foreach (var kvp in componentArrays.ToList())
            {
                var oldArray = kvp.Value;
                var newArray = Array.CreateInstance(kvp.Key.Type, newCapacity);
                Array.Copy(oldArray, 0, newArray, 0, count);
                componentArrays[kvp.Key] = newArray;
            }

            // Grow entity ID array
            Array.Resize(ref entityIds, newCapacity);
        }

        // And we need to add this method to ArchetypeStorage
        public Array GetComponentArrayRaw(ComponentType componentType)
        {
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {componentType.Type.Name} not found in archetype"
                );
            }
            return array;
        }

        public int GetEntityIndex(int entityId)
        {
            return entityToIndex.TryGetValue(entityId, out int index) ? index : -1;
        }

        // Properties for accessing storage information
        public int Count => count;
        public ReadOnlySpan<int> EntityIds => new ReadOnlySpan<int>(entityIds, 0, count);
    }
}

================
File: Core/ArchetypeStorage.cs.meta
================
fileFormatVersion: 2
guid: 785407d53c9c26746adb34ba3d74b58d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/ArchetypeSyncer.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public abstract class ArchetypeSyncer : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        protected ArchetypeStorage DedicatedStorage => World.GetStorage(Archetype);
        protected abstract Archetype Archetype { get; }

        public abstract EGameState GameStateToExecute { get; }

        public void SetWorld(World world)
        {
            World = world;
        }

        public virtual void Initialize() { }

        public virtual void Update(float deltaTime) { }

        public virtual void Cleanup() { }
    }
}

================
File: Core/ArchetypeSyncer.cs.meta
================
fileFormatVersion: 2
guid: 0df86895fba8144229e53825e79322a5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/BaseSyncTool.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public abstract class BaseSyncTool
    {
        protected World World;
        protected abstract Archetype Archetype { get; }
        protected ArchetypeStorage DedicatedStorage;

        public bool IsInitialized { get; set; }

        public BaseSyncTool(GlobalPoint globalPoint)
        {
            this.World = globalPoint.World;

            DedicatedStorage = World.GetStorage(Archetype);

            IsInitialized = false;
        }

        public virtual void InitializeTool()
        {
            if (IsInitialized)
                return;
            IsInitialized = true;
        }
    }
}

================
File: Core/BaseSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 5e44dbdf22074481cb483b4d3d14412b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/ComponentType.cs
================
using System;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using NUnit.Framework.Constraints;

namespace ECS_MagicTile
{
    public readonly struct ComponentType
    {
        public readonly Type Type;
        public readonly int Id;

        // Private constructor ensures all types are created through registry
        private ComponentType(Type type, int id)
        {
            Type = type;
            Id = id;
        }

        // Static registry of all component types in our game
        public static class Registry
        {
            // Core Components
            public static readonly ComponentType Transform = new(typeof(TransformComponent), 0);
            public static readonly ComponentType MusicNote = new(typeof(MusicNoteComponent), 1);

            public static readonly ComponentType PerfectLine =
                new(typeof(PerfectLineTagComponent), 3);
            public static readonly ComponentType Corner = new(typeof(CornerComponent), 4);

            public static readonly ComponentType Input = new(typeof(InputStateComponent), 5);
            public static readonly ComponentType MusicNoteInteraction =
                new(typeof(MusicNoteInteractionComponent), 6);
            public static readonly ComponentType MusicNoteFiller =
                new(typeof(MusicNoteFillerComponent), 7);

            public static readonly ComponentType ActiveState = new(typeof(ActiveStateComponent), 8);
            public static readonly ComponentType StartingNote =
                new(typeof(StartingNoteTagComponent), 9);
            public static readonly ComponentType GameScore = new(typeof(ScoreComponent), 10);
            public static readonly ComponentType NoteScoreState =
                new(typeof(ScoreStateComponent), 11);

            public static readonly ComponentType TransformGroup =
                new(typeof(TransformComponentGroup), 12);

            public static readonly ComponentType Progress = new(typeof(ProgressComponent), 14);
            public static readonly ComponentType WorldState = new(typeof(WorldStateComponent), 15);

            // A lookup dictionary to quickly find ComponentType by Type
            private static readonly Dictionary<Type, ComponentType> typeToComponentType =
                new Dictionary<Type, ComponentType>
                {
                    { typeof(TransformComponent), Transform },
                    { typeof(MusicNoteComponent), MusicNote },
                    { typeof(PerfectLineTagComponent), PerfectLine },
                    { typeof(CornerComponent), Corner },
                    { typeof(InputStateComponent), Input },
                    { typeof(MusicNoteInteractionComponent), MusicNoteInteraction },
                    { typeof(MusicNoteFillerComponent), MusicNoteFiller },
                    { typeof(ActiveStateComponent), ActiveState },
                    { typeof(StartingNoteTagComponent), StartingNote },
                    { typeof(ScoreComponent), GameScore },
                    { typeof(ScoreStateComponent), NoteScoreState },
                    { typeof(TransformComponentGroup), TransformGroup },
                    { typeof(ProgressComponent), Progress },
                    { typeof(WorldStateComponent), WorldState },
                };

            // This is our new generic lookup method
            public static ComponentType GetComponentType<T>()
                where T : struct
            {
                var type = typeof(T);
                if (!typeToComponentType.TryGetValue(type, out var componentType))
                {
                    throw new InvalidOperationException(
                        $"Component type {type.Name} is not registered. "
                            + "Make sure to add it to the ComponentType.Registry."
                    );
                }
                return componentType;
            }

            // The existing methods remain the same
            public static ReadOnlySpan<ComponentType> GetAllTypes() => AllTypes;

            private static readonly ComponentType[] AllTypes =
            {
                Transform,
                MusicNote,
                PerfectLine,
                Corner,
            };
        }
    }
}

================
File: Core/ComponentType.cs.meta
================
fileFormatVersion: 2
guid: 07d3246996a8eeb4ba2c5e2e4d0939c9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/EntityIdHolder.cs
================
using System.Linq;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EntityIdHolder : MonoBehaviour, IEntityHolder
    {
        public int EntityId { get; private set; }

        public void SetEntityId(int id)
        {
            EntityId = id;
            // Optional: Make the GameObject name more readable without losing the ID reference
            gameObject.name = $"{id}_{gameObject.name.Split('_').LastOrDefault() ?? "entity"}";
        }
    }
}

================
File: Core/EntityIdHolder.cs.meta
================
fileFormatVersion: 2
guid: 17dde60b87c53b14884d92c6a0f07c99
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/EntityViewFactory.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EntityViewFactory
    {
        private readonly Dictionary<int, GameObject> entityViews = new();
        private readonly GameObject prefabSource;
        private readonly Transform viewRoot;

        public EntityViewFactory() { }

        public EntityViewFactory(GameObject prefabSource, Transform viewRoot)
        {
            this.prefabSource = prefabSource;
            this.viewRoot = viewRoot;
        }

        public GameObject GetOrCreateView(int entityId, string nameOnCreation = "")
        {
            if (entityViews.TryGetValue(entityId, out var existing))
            {
                return existing;
            }

            var prefab = prefabSource;

            GameObject view = GameObject.Instantiate(prefab, viewRoot);
            EntityIdHolder viewEntityIdHolder = view.AddComponent<EntityIdHolder>();
            viewEntityIdHolder.SetEntityId(entityId);
            entityViews[entityId] = view;
            return view;
        }

        public GameObject GetView(int entityId)
        {
            return entityViews.TryGetValue(entityId, out var view) ? view : null;
        }
    }
}

================
File: Core/EntityViewFactory.cs.meta
================
fileFormatVersion: 2
guid: f36c2cdebdbc74a8db63bff96d758abd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/GlobalPoint.cs
================
using System.Diagnostics;
using EventChannel;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class GlobalPoint : MonoBehaviour
    {
        [Header("Game Settings")]
        public GeneralGameSetting generalGameSetting;

        public MusicNoteCreationSetting musicNoteCreationSettings;

        public PerfectLineSetting perfectLineSetting;
        public LaneLineSettings laneLineSettings;

        [Header("Event Channel")]
        public IntEventChannel OnGameStartChannel;
        public BoolEventChannel OnScoreHitChannel;
        public BoolEventChannel OnOrientationChangedChannel;
        public EmptyEventChannel OnSongStartChannel;

        [Header("UI references")]
        public Text scoreText;
        public Slider progressSlider;

        [Header("Object references")]
        public GameObject perfectLineObject;
        public Camera mainCamera;

        private World world;

        public World World
        {
            get => world;
        }

        public MusicNoteViewSyncTool musicNoteViewSyncTool { get; private set; }
        public PerfectLineSyncTool perfectLineSyncTool { get; private set; }
        public StartingNoteSyncTool startingNoteSyncTool { get; private set; }
        public GameScoreSyncTool gameScoreSyncTool { get; private set; }
        public ProgressSyncTool progressSyncTool { get; private set; }
        public LaneLineSyncTool laneLineSyncTool { get; private set; }

        private void Awake()
        {
            // Initialize our ECS world
            world = new World();

            SystemRegistry.Initialize(world);
            InitializeSyncTools();
            RegisterSystems();
        }

        private void InitializeSyncTools()
        {
            musicNoteViewSyncTool = new MusicNoteViewSyncTool(this);
            perfectLineSyncTool = new PerfectLineSyncTool(this);
            startingNoteSyncTool = new StartingNoteSyncTool(this);
            gameScoreSyncTool = new GameScoreSyncTool(this);
            progressSyncTool = new ProgressSyncTool(this);
            laneLineSyncTool = new LaneLineSyncTool(this);
        }

        private void RegisterSystems()
        {
            //Singleton Creation system
            SystemRegistry.AddSystem(new SingletonCreationSystem(this));

            //Creation System
            SystemRegistry.AddSystem(new PerfectLineSystem(this));
            SystemRegistry.AddSystem(new MusicNoteCreationSystem(this));
            SystemRegistry.AddSystem(new StartingNoteSystem(this));

            //Handling Data system
            SystemRegistry.AddSystem(new MovingNoteSystem(this));
            SystemRegistry.AddSystem(new TraceNoteToTriggerSongSystem(this));
            SystemRegistry.AddSystem(new InputSystem());
            SystemRegistry.AddSystem(new InputCollisionSystem(this));
            SystemRegistry.AddSystem(new ScoringSystem(this));
            SystemRegistry.AddSystem(new ProgressSystem(this));
            SystemRegistry.AddSystem(new LaneLineSystem(this));

            //Game State system
            SystemRegistry.AddSystem(new GameStateSystem(this));
        }

        private void Update()
        {
            // Update all systems with current frame's delta time
            SystemRegistry.Update(Time.deltaTime);
        }
    }
}

================
File: Core/GlobalPoint.cs.meta
================
fileFormatVersion: 2
guid: a3234adf86578d14ca74bc8cc99f7901
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/IComponent.cs
================
namespace ECS_MagicTile
{
    public interface IComponent { }
}

================
File: Core/IComponent.cs.meta
================
fileFormatVersion: 2
guid: 5bfc30fb61b4b4792b8875b3f63c5a3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/IEntityHolder.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public interface IEntityHolder
    {
        public int EntityId { get; }

        public void SetEntityId(int id);
    }
}

================
File: Core/IEntityHolder.cs.meta
================
fileFormatVersion: 2
guid: 1049762c28d04a94da5cb9e99c65ebb4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/IGameSystem.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    // Interface that all our game systems will implement

    public interface IGameSystem
    {
        void SetWorld(World world);
        void Initialize(); // Called when system is first created
        void Update(float deltaTime); // Called every frame
        void Cleanup();
        bool IsEnabled { get; set; } // Controls if system should be updated
        World World { get; set; }
        EGameState GameStateToExecute { get; }
    }
}

================
File: Core/IGameSystem.cs.meta
================
fileFormatVersion: 2
guid: 38d38b21b37a3cf4dbb318fce0f3efdf
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/StorageManager.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Manages all archetype storages in our game
    public class StorageManager
    {
        // Maps archetype hashes to their storage
        private readonly Dictionary<int, ArchetypeStorage> storages;
        private readonly Dictionary<int, List<ArchetypeStorage>> aspectStorages;

        public StorageManager()
        {
            storages = new Dictionary<int, ArchetypeStorage>();
            aspectStorages = new Dictionary<int, List<ArchetypeStorage>>();

            // First, create regular storages
            foreach (var archetype in Archetype.Registry.GetAllArchetypes())
            {
                if (!IsAspectArchetype(archetype))
                {
                    storages[archetype.GetHash()] = new ArchetypeStorage(archetype);
                }

                if (IsAspectArchetype(archetype))
                {
                    // Find all archetypes that contain these components
                    var matchingStorages = FindMatchingStorages(archetype);
                    aspectStorages[archetype.GetHash()] = matchingStorages;
                }
            }
        }

        private bool IsAspectArchetype(Archetype archetype)
        {
            // You could mark aspect archetypes explicitly, or use a naming convention,
            // or determine based on component count
            return archetype.IsAspect;
        }

        private List<ArchetypeStorage> FindMatchingStorages(Archetype aspectArchetype)
        {
            var matchingStorages = new List<ArchetypeStorage>();
            var requiredComponents = aspectArchetype.GetTypes();

            foreach (var storage in storages.Values)
            {
                // Check if this storage's archetype contains all required components
                bool matches = true;
                foreach (var component in requiredComponents)
                {
                    if (!HasComponent(storage, component))
                    {
                        matches = false;
                        break;
                    }
                }

                if (matches)
                {
                    matchingStorages.Add(storage);
                }
            }

            return matchingStorages;
        }

        // Get storage for a specific archetype
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            if (!storages.TryGetValue(archetype.GetHash(), out var storage))
            {
                throw new InvalidOperationException($"No storage found for archetype {archetype}");
            }
            return storage;
        }

        public IEnumerable<ArchetypeStorage> GetStoragesForAspect(Archetype aspectArchetype)
        {
            if (aspectStorages.TryGetValue(aspectArchetype.GetHash(), out var storageList))
            {
                return storageList;
            }
            return Array.Empty<ArchetypeStorage>();
        }

        private bool HasComponent(ArchetypeStorage storage, ComponentType componentType)
        {
            try
            {
                // We try to get the component array - if it exists, the storage has this component
                Array componentArray = storage.GetComponentArrayRaw(componentType);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}

================
File: Core/StorageManager.cs.meta
================
fileFormatVersion: 2
guid: 6e34b51edd65cc54298a958d1e7db250
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/SystemRegistry.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Our central system management class
    public static class SystemRegistry
    {
        // Store systems in order of execution priority
        private static readonly List<IGameSystem> updateSystems = new();
        private static World world;
        private static bool isInitialized;
        private static EGameState currentGameState = EGameState.WaitingToStart;

        // Initialize our registry with a world reference
        public static void Initialize(World gameWorld)
        {
            // Prevent multiple initializations
            if (isInitialized)
            {
                Debug.LogWarning("SystemRegistry already initialized!");
                return;
            }

            world = gameWorld;
            isInitialized = true;
        }

        // Allow adding systems from GlobalPoint
        public static void AddSystem(IGameSystem system)
        {
            if (!isInitialized)
            {
                Debug.LogError("SystemRegistry not initialized! Call Initialize first.");
                return;
            }

            // Provide the system with world reference and initialize it
            system.SetWorld(world);
            system.Initialize();

            updateSystems.Add(system);

            Debug.Log($"Added system: {system.GetType().Name}");
        }

        public static void Update(float deltaTime)
        {
            if (!isInitialized)
                return;

            foreach (var system in updateSystems)
            {
                if (
                    system.IsEnabled
                    && (
                        system.GameStateToExecute == currentGameState
                        || system.GameStateToExecute == EGameState.All
                    )
                )
                {
                    try
                    {
                        system.Update(deltaTime);
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error in system {system.GetType().Name}: {e}");
                    }
                }
            }
        }

        public static void Cleanup()
        {
            foreach (var system in updateSystems)
            {
                system.Cleanup();
            }

            updateSystems.Clear();
            isInitialized = false;
            world = null;
        }

        public static void SetGameState(EGameState newState)
        {
            currentGameState = newState;
        }
    }
}

================
File: Core/SystemRegistry.cs.meta
================
fileFormatVersion: 2
guid: ae3ac3479b706d64f83a41cf766e7021
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core/World.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    public class World
    {
        private readonly StorageManager storageManager;
        private int nextEntityId = 1000; // Starting from 1000 to leave room for special IDs

        public World()
        {
            storageManager = new StorageManager();
        }

        // Creates an entity of a specific archetype
        private int CreateEntity()
        {
            int entityId = nextEntityId++;
            return entityId;
        }

        // Gets a specific storage for systems to use
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            return storageManager.GetStorage(archetype);
        }

        // Helper method to create and set up an entity in one go
        public int CreateEntityWithComponents(Archetype archetype, ReadOnlySpan<object> components)
        {
            int entityId = CreateEntity();
            ArchetypeStorage storage = GetStorage(archetype);
            storage.Add(entityId, components);
            return entityId;
        }
    }
}

================
File: Core/World.cs.meta
================
fileFormatVersion: 2
guid: 1df84a3b9711fcb41b790ef98664b125
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/ActiveStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ActiveStateComponent : IComponent
    {
        public bool isActive;
    }
}

================
File: DataComponents/ActiveStateComponent.cs.meta
================
fileFormatVersion: 2
guid: a3c5cd13e343b874085a9dacaa62d089
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/CornerComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct CornerComponent : IComponent
    {
        public Vector2 TopLeft;
        public Vector2 TopRight;
        public Vector2 BottomLeft;
        public Vector2 BottomRight;
    }
}

================
File: DataComponents/CornerComponent.cs.meta
================
fileFormatVersion: 2
guid: b96e4a6c6cb604761b6ec117819be5b4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/GraphicComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct GraphicComponent : IComponent
    {
        public float Alpha;
    }
}

================
File: DataComponents/GraphicComponent.cs.meta
================
fileFormatVersion: 2
guid: 82ef7ef712a2447df8b498a1935315b2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/InputStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct InputStateComponent : IComponent
    {
        public bool IsActive;
        public Vector2 Position;
        public Vector2 PreviousPosition;
        public InputState State;
        public int FrameCount;
    }
}

================
File: DataComponents/InputStateComponent.cs.meta
================
fileFormatVersion: 2
guid: 97c04fe8669d4470d94eec98d4274ef1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/LongNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct LongNoteTagComponent : IComponent { }
}

================
File: DataComponents/LongNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 58353002a3593244d8bf12e61f349c98
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/MusicNoteComponent.cs
================
using ECS_MagicTile;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteComponent : IComponent
    {
        public int PostionId;
        public float TimeAppear;
        public float Duration;
        public MusicNoteType musicNoteType;
        public MusicNotePositionState musicNotePositionState;
    }
}

================
File: DataComponents/MusicNoteComponent.cs.meta
================
fileFormatVersion: 2
guid: e13eda0f52da940ceaec30f721998b78
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/MusicNoteFillerComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteFillerComponent : IComponent
    {
        public bool IsVisible;
        public float FillPercent;
    }
}

================
File: DataComponents/MusicNoteFillerComponent.cs.meta
================
fileFormatVersion: 2
guid: d7e3fc83bb7c04b7b9b06366cc8a2202
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/MusicNoteInteractionComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteInteractionComponent : IComponent
    {
        public MusicNoteInteractiveState State;
    }
}

================
File: DataComponents/MusicNoteInteractionComponent.cs.meta
================
fileFormatVersion: 2
guid: e6da2d26198754d3382d07b0e55fa2f1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/PerfectLineTagComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct PerfectLineTagComponent : IComponent
    {
        public float PerfectLineWidth;
    }
}

================
File: DataComponents/PerfectLineTagComponent.cs.meta
================
fileFormatVersion: 2
guid: e18089c9ed33d49f8b76960358f6a4d2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/ProgressComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public struct ProgressComponent : IComponent
    {
        public float MaxProgressRawValue;
        public float CurrentProgressRawValue;
        public float currentProgressPercent;
    }
}

================
File: DataComponents/ProgressComponent.cs.meta
================
fileFormatVersion: 2
guid: 10aad573b13074bc9be17ec7cf91ad53
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/ScoreComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ScoreComponent : IComponent
    {
        public int TotalScore;
    }
}

================
File: DataComponents/ScoreComponent.cs.meta
================
fileFormatVersion: 2
guid: fa68460c39b07454594ff59898fdcbbe
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/ScoreEffectComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct TransformComponentGroup : IComponent
    {
        public TransformComponent[] satelliteEffects;
    }
}

================
File: DataComponents/ScoreEffectComponent.cs.meta
================
fileFormatVersion: 2
guid: 363408fdc911f4ec2b3d751d95811afb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/ScoreStateComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile
{
    public struct ScoreStateComponent : IComponent
    {
        public bool HasBeenScored;
    }
}

================
File: DataComponents/ScoreStateComponent.cs.meta
================
fileFormatVersion: 2
guid: f7658e090bcd30d46b50748601faa672
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/ShortNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ShortNoteTagComponent : IComponent { }
}

================
File: DataComponents/ShortNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 83c9ef9fdf039c843b9556bfba72a05a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/StartingNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct StartingNoteTagComponent : IComponent
    {
        public int initalLane;
    }
}

================
File: DataComponents/StartingNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 60788d363c63c884e898300f27bf2be1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/TransformComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct TransformComponent : IComponent
    {
        public Vector2 Position;
        public Vector2 Size;
        public Vector2 rotation;
    }
}

================
File: DataComponents/TransformComponent.cs.meta
================
fileFormatVersion: 2
guid: ff2e94255bc1f499a986a60df04d62ec
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents/WorldStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct WorldStateComponent : IComponent
    {
        public float FirstNotePositionToTriggerSong;
    }
}

================
File: DataComponents/WorldStateComponent.cs.meta
================
fileFormatVersion: 2
guid: a5162f3c9a136cc41823dccde90295d3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DTO/MusicNoteMidiData.cs
================
using UnityEngine;

public struct MusicNoteMidiData : IDataComponent
{
    // Core data arrays
    public int[] Ids;
    public int[] NoteNumbers;
    public int[] PositionIds;
    public float[] TimeAppears;
    public float[] Timespans;
    public float[] Durations;
    public float[] Velocities;

    // Metadata
    public int TotalNotes;
    public float MinDuration;

    public MusicNoteMidiData(int capacity)
    {
        // Preallocate arrays with specified capacity
        Ids = new int[capacity];
        NoteNumbers = new int[capacity];
        TimeAppears = new float[capacity];
        Timespans = new float[capacity];
        Durations = new float[capacity];
        Velocities = new float[capacity];
        PositionIds = new int[capacity];

        TotalNotes = 0;
        MinDuration = float.MaxValue;
    }
}

================
File: DTO/MusicNoteMidiData.cs.meta
================
fileFormatVersion: 2
guid: 0772d691d2fae418b83ddb22ddc64cc6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannels/SOScripts/BoolEventChannel.cs
================
using UnityEngine;

namespace EventChannel
{
    [CreateAssetMenu(
        fileName = "sO_BoolEventChannel",
        menuName = "Event Channels/BoolEventChannel"
    )]
    public class BoolEventChannel : EventChannelSO<bool> { }
}

================
File: EventChannels/SOScripts/BoolEventChannel.cs.meta
================
fileFormatVersion: 2
guid: 20ec6d5789c44934380628f5b1389ae7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannels/SOScripts/IntEventChannel.cs
================
using UnityEngine;

namespace EventChannel
{
    [CreateAssetMenu(fileName = "IntEventChannel", menuName = "Event Channels/Int event channel")]
    public class IntEventChannel : EventChannelSO<int> { }
}

================
File: EventChannels/SOScripts/IntEventChannel.cs.meta
================
fileFormatVersion: 2
guid: 84c124985c8ec984998e8fd8a7792f33
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannels/OnGameStartChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 84c124985c8ec984998e8fd8a7792f33, type: 3}
  m_Name: OnGameStartChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: EventChannels/OnGameStartChannel.asset.meta
================
fileFormatVersion: 2
guid: 44439b2ecef163c4e8e6b70a713339a8
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannels/OnOrientationChangeChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 20ec6d5789c44934380628f5b1389ae7, type: 3}
  m_Name: OnOrientationChangeChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: EventChannels/OnOrientationChangeChannel.asset.meta
================
fileFormatVersion: 2
guid: 2ceeecf601ad944f699e78a3f56a522e
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannels/OnSongStartChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a25d70a25c32e5b4b99a7e2929ad8cea, type: 3}
  m_Name: OnSongStartChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: EventChannels/OnSongStartChannel.asset.meta
================
fileFormatVersion: 2
guid: e44f33d26247cc141ae0b8696485f784
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannels/SO_ScoreSignalEffectChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 20ec6d5789c44934380628f5b1389ae7, type: 3}
  m_Name: SO_ScoreSignalEffectChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: EventChannels/SO_ScoreSignalEffectChannel.asset.meta
================
fileFormatVersion: 2
guid: ea0ef8d03bdeb4c4784bc02c8a47c318
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannels/SOScripts.meta
================
fileFormatVersion: 2
guid: 7b8aa6ae181e147d8af51b60d816fe7a
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Functions/PreciseNoteCalculator.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    public static class PreciseNoteCalculator
    {
        /// <summary>
        /// Calculates the total song duration, in seconds, by summing the last
        /// note's appear time and duration.
        /// </summary>
        /// <param name="musicNoteMidiData">The parsed MIDI data to calculate the total duration from.</param>
        /// <returns>The total song duration, in seconds.</returns>
        ///
        public static float CalculateTotalSongDuration(MusicNoteMidiData musicNoteMidiData)
        {
            return musicNoteMidiData.TimeAppears[musicNoteMidiData.TotalNotes - 1]
                + musicNoteMidiData.Durations[musicNoteMidiData.TotalNotes - 1];
        }

        /// <summary>
        /// Finds the smallest note duration in the given MIDI data.
        /// </summary>
        /// <param name="musicNoteMidiData">The parsed MIDI data to find the smallest note duration from.</param>
        /// <param name="decimalPlaces">The number of decimal places to round the smallest duration to.</param>
        /// <returns>The smallest note duration, rounded to the specified number of decimal places.</returns>
        public static float FindSmallestNoteDuration(
            MusicNoteMidiData musicNoteMidiData,
            int decimalPlaces = 2
        )
        {
            if (musicNoteMidiData.TotalNotes == 0)
                return 0f;

            float smallestDuration = musicNoteMidiData.Durations[0];
            for (int i = 1; i < musicNoteMidiData.TotalNotes; i++)
            {
                smallestDuration = Mathf.Min(smallestDuration, musicNoteMidiData.Durations[i]);
            }

            return (float)Math.Round(smallestDuration, decimalPlaces);
        }

        /// <summary>
        /// Calculates the size of each note based on its duration compared to the smallest note duration.
        /// </summary>
        /// <param name="musicNoteMidiData">The parsed MIDI data to calculate the note sizes from.</param>
        /// <param name="baseSize">The base size of each note, to be scaled according to its duration.</param>
        /// <returns>An array of note sizes, where each size is relative to the smallest note duration.</returns>
        ///
        public static float[] CalculateNoteSizes(
            MusicNoteMidiData musicNoteMidiData,
            float baseSize = 2f
        )
        {
            float smallestDuration = FindSmallestNoteDuration(musicNoteMidiData, 2);
            float[] noteSizes = new float[musicNoteMidiData.TotalNotes];

            for (int i = 0; i < musicNoteMidiData.TotalNotes; i++)
            {
                noteSizes[i] = baseSize * (musicNoteMidiData.Durations[i] / smallestDuration);
            }

            return noteSizes;
        }

        public static float[] CalculateInitialPositions(
            MusicNoteMidiData midiData,
            float perfectLineY,
            float[] noteSizes,
            float baseSize = 2f
        )
        {
            float[] positions = new float[noteSizes.Length];
            if (noteSizes.Length == 0)
                return positions;

            // Position first note - add half its size to center point
            positions[0] = perfectLineY + (noteSizes[0] * 0.5f);
            float smallestDuration = FindSmallestNoteDuration(midiData, 2);

            // Position subsequent notes with proper gaps
            for (int i = 1; i < noteSizes.Length; i++)
            {
                // Start from previous note's center
                float pos = positions[i - 1];

                // Add half size of previous note (to get to its top)
                pos += noteSizes[i - 1] * 0.5f;

                // Calculate and add remaining gap space
                float remainingGap = midiData.Timespans[i] - midiData.Durations[i - 1];
                if (remainingGap > 0)
                {
                    // Convert time gap to space using velocity
                    float gapSpace = baseSize * (remainingGap / smallestDuration);
                    pos += gapSpace;
                }

                // Add half size of current note (to get to its center)
                pos += noteSizes[i] * 0.5f;

                positions[i] = pos;
            }

            return positions;
        }

        // Calculate road length from last note position and size
        public static float CalculateRoadLength(float[] noteSizes, MusicNoteMidiData midiData)
        {
            float totalLength = noteSizes[0]; // First note's size

            // Add subsequent notes' sizes and their gaps
            for (int i = 1; i < noteSizes.Length; i++)
            {
                // Add remaining gap space
                float remainingGap = midiData.Timespans[i] - midiData.Durations[i - 1];
                if (remainingGap > 0)
                {
                    // Estimate gap space relative to note sizes
                    float gapScale = remainingGap / midiData.Durations[i];
                    totalLength += noteSizes[i] * gapScale;
                }

                // Add current note's size
                totalLength += noteSizes[i];
            }

            return totalLength;
        }

        // Calculate velocity based on road length and total time
        public static float CalculateRequiredVelocity(float totalTime, float roadLength)
        {
            if (totalTime <= 0f)
                return 0f;
            return roadLength / totalTime;
        }
    }
}

================
File: Functions/PreciseNoteCalculator.cs.meta
================
fileFormatVersion: 2
guid: 0e15eb8261a3ad94583181063bec9b20
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/AudioManager.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class AudioManager : MonoBehaviour
    {
        [SerializeField]
        private EmptyEventChannel onSongStartChannel;

        [SerializeField]
        private AudioClip audioClip;

        private AudioSource audioSource;

        void Start()
        {
            audioSource = GetComponent<AudioSource>();
            audioSource.clip = audioClip;
        }

        void OnEnable()
        {
            onSongStartChannel.Subscribe(OnGameStart);
        }

        private void OnGameStart(EmptyData data)
        {
            audioSource.PlayWithFadeIn(this, .8f);
        }
    }
}

================
File: MonoScripts/AudioManager.cs.meta
================
fileFormatVersion: 2
guid: 1a6eec2221ddc4ba2aadd917abe77374
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/BurstMovement.cs
================
using UnityEngine;

/// <summary>
/// Implements a customizable burst movement behavior where an object accelerates to a maximum speed,
/// maintains that speed for a configurable distance, then smoothly decelerates to a stop.
/// The movement uses exponential functions to create natural-feeling acceleration and deceleration.
/// </summary>
/// <remarks>
/// The movement is divided into two phases:
/// 1. Burst Phase: Object accelerates from initial speed to max speed using a smooth exponential curve
/// 2. Deceleration Phase: Object gradually slows down to a stop using natural exponential decay
///
/// Mathematical formulas used:
/// - Acceleration: speed = maxSpeed * (initialPercent + (1-initialPercent) * (1-e^(-aF * x)))
/// - Deceleration: speed = maxSpeed * e^(-dF * x)
/// Where:
/// - aF = acceleration factor
/// - dF = deceleration factor
/// - x = progress (0 to 1) in current phase
/// </remarks>
public class BurstMovement : MonoBehaviour
{
    [Header("Movement Properties")]
    [SerializeField]
    private Vector3 direction = Vector3.forward;

    [SerializeField]
    private float maxDistance = 10f;

    [Header("Speed Properties")]
    [SerializeField]
    private float maxSpeed = 10f;

    [SerializeField, Range(0.5f, 5f)]
    private float accelerationFactor = 2f;

    [SerializeField, Range(0.5f, 5f)]
    private float decelerationFactor = 1.5f;

    [Header("Burst Configuration")]
    [SerializeField, Range(0f, 100f)]
    private float burstEndPercentage = 50f;

    [SerializeField, Range(0f, 1f)]
    private float initialSpeedPercent = 0.1f;

    private Vector3 startPosition;
    private float currentSpeed;
    private bool hasStarted;

    /// <summary>
    /// Initializes the movement component by storing the starting position and normalizing the direction vector.
    /// </summary>
    private void Start()
    {
        startPosition = transform.position;
        direction = direction.normalized;
        hasStarted = true;

        Debug.Log(
            $"=== Initial Parameters ===\n"
                + $"Max Speed: {maxSpeed}\n"
                + $"Max Distance: {maxDistance}\n"
                + $"Acceleration Factor: {accelerationFactor}\n"
                + $"Deceleration Factor: {decelerationFactor}\n"
                + $"Direction: {direction}"
        );
    }

    /// <summary>
    /// Updates the object's position each frame based on the current movement phase and calculated speed.
    /// Handles progression through acceleration and deceleration phases until reaching the target distance.
    /// </summary>
    private void Update()
    {
        if (!hasStarted)
            return;

        float distanceTraveled = Vector3.Distance(transform.position, startPosition);
        float distancePercentage = (distanceTraveled / maxDistance) * 100f;

        if (distancePercentage >= 100f)
        {
            hasStarted = false;
            return;
        }

        currentSpeed = CalculateSpeed(distancePercentage);
        transform.position += direction * (currentSpeed * Time.deltaTime);
    }

    /// <summary>
    /// Calculates the current speed based on the percentage of total distance traveled.
    /// Uses different mathematical formulas for acceleration and deceleration phases.
    /// </summary>
    /// <param name="distancePercentage">Current distance traveled as a percentage (0-100) of total distance</param>
    /// <returns>The calculated speed for the current frame</returns>
    /// <remarks>
    /// During acceleration (0% to burstEndPercentage):
    /// - Starts at initialSpeedPercent of maxSpeed
    /// - Smoothly accelerates to maxSpeed using exponential approach
    ///
    /// During deceleration (burstEndPercentage to 100%):
    /// - Starts at maxSpeed
    /// - Exponentially decays to zero
    /// </remarks>
    private float CalculateSpeed(float distancePercentage)
    {
        // Acceleration phase
        if (distancePercentage <= burstEndPercentage)
        {
            float accelerationProgress = distancePercentage / burstEndPercentage;
            return maxSpeed
                * (
                    initialSpeedPercent
                    + (1f - initialSpeedPercent)
                        * (1f - Mathf.Exp(-accelerationFactor * accelerationProgress))
                );
        }
        // Deceleration phase
        else
        {
            float decelerationProgress =
                (distancePercentage - burstEndPercentage) / (100f - burstEndPercentage);
            return maxSpeed * Mathf.Exp(-decelerationFactor * decelerationProgress);
        }
    }

    /// <summary>
    /// Draws debug visualization in the Scene view to help understand the movement path and progress.
    /// </summary>
    private void OnDrawGizmos()
    {
        if (!Application.isPlaying)
            return;

        // Draw the full path
        Gizmos.color = Color.yellow;
        Gizmos.DrawLine(startPosition, startPosition + direction * maxDistance);

        // Draw burst end point
        Vector3 burstEndPoint =
            startPosition + direction * (maxDistance * burstEndPercentage / 100f);
        Gizmos.color = Color.blue;
        Gizmos.DrawWireSphere(burstEndPoint, 0.3f);

        // Draw current position
        Gizmos.color = Color.green;
        Gizmos.DrawWireSphere(transform.position, 0.2f);
    }
}

================
File: MonoScripts/BurstMovement.cs.meta
================
fileFormatVersion: 2
guid: 8e0f7f48d9c2e439db3417617e6b029a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/BurstMovementUIController.cs
================
using System.Linq;
using UnityEngine;

/// <summary>
/// A system-like controller that manages multiple UI elements with burst movement behavior.
/// This controller follows ECS principles by separating data (BurstMovementData) from behavior
/// while maintaining MonoBehaviour compatibility.
/// </summary>
/// <remarks>
/// The burst movement creates a dynamic motion effect where elements:
/// 1. Start with an initial speed
/// 2. Accelerate smoothly to maximum speed
/// 3. Maintain that speed for a configurable distance
/// 4. Decelerate naturally to a stop
///
/// The controller processes all movements in batches for better performance
/// and provides default values that can be overridden per element.
/// </remarks>
public class BurstMovementUIController : MonoBehaviour
{
    private BurstMovementElement[] movementElements;

    [Header("Default Values")]
    [SerializeField]
    private float defaultMaxSpeed = 500f;

    [SerializeField]
    private float defaultAccelerationFactor = 2f;

    [SerializeField]
    private float defaultDecelerationFactor = 1.5f;

    [SerializeField]
    private float defaultBurstEndPercentage = 50f;

    [SerializeField]
    private float defaultInitialSpeedPercent = 0.1f;

    private Vector2[] cachedStartPosition;

    /// <summary>
    /// Initializes all movement elements when the controller starts.
    /// Sets up initial positions and applies default values where needed.
    /// </summary>
    public void InitializeElement(BurstMovementElement[] burstMovementElements)
    {
        movementElements = burstMovementElements;
        cachedStartPosition = new Vector2[movementElements.Length];
        int index = 0;
        foreach (var element in movementElements)
        {
            // Store initial position and normalize direction for consistent movement
            element.data.startPosition = element.target.anchoredPosition;
            element.data.direction = element.data.direction.normalized;
            element.data.hasStarted = true;
            element.data.isFinished = false;
            cachedStartPosition[index] = element.target.anchoredPosition;
            index++;

            ApplyDefaultsIfNeeded(ref element.data);
        }
        //Make all elements not move at start
        StopAll();
    }

    /// <summary>
    /// Applies default values to any unset or invalid movement parameters.
    /// This ensures all elements have valid movement settings even if not explicitly configured.
    /// </summary>
    /// <param name="data">Reference to the movement data to validate and update</param>
    private void ApplyDefaultsIfNeeded(ref BurstMovementData data)
    {
        if (data.maxSpeed <= 0)
            data.maxSpeed = defaultMaxSpeed;
        if (data.accelerationFactor <= 0)
            data.accelerationFactor = defaultAccelerationFactor;
        if (data.decelerationFactor <= 0)
            data.decelerationFactor = defaultDecelerationFactor;
        if (data.burstEndPercentage <= 0)
            data.burstEndPercentage = defaultBurstEndPercentage;
        if (data.initialSpeedPercent <= 0)
            data.initialSpeedPercent = defaultInitialSpeedPercent;
    }

    /// <summary>
    /// Processes movement updates for all active elements each frame.
    /// Follows a system-like approach by batch processing all movements.
    /// </summary>
    private void Update()
    {
        if (movementElements.Length == 0)
            return;

        foreach (var element in movementElements)
        {
            if (!element.data.hasStarted || element.data.isFinished)
                continue;
            ProcessMovement(element);
        }
    }

    /// <summary>
    /// Updates the position of a single movement element based on its current state and configuration.
    /// </summary>
    /// <param name="element">The movement element to process</param>
    private void ProcessMovement(BurstMovementElement element)
    {
        // Calculate how far we've moved as a percentage of total distance
        float distanceTraveled = Vector2.Distance(
            element.target.anchoredPosition,
            element.data.startPosition
        );
        float distancePercentage = (distanceTraveled / element.data.maxDistance) * 100f;

        // Check if we've reached our destination
        if (distancePercentage >= 100f)
        {
            element.data.isFinished = true;
            return;
        }

        // Calculate and apply movement for this frame
        element.data.currentSpeed = CalculateSpeed(distancePercentage, element.data);
        Vector2 newPosition =
            (Vector2)element.target.anchoredPosition
            + element.data.direction * (element.data.currentSpeed * Time.deltaTime);

        element.target.anchoredPosition = newPosition;
    }

    /// <summary>
    /// Calculates the current speed based on distance percentage using exponential curves
    /// for smooth acceleration and deceleration.
    /// </summary>
    /// <param name="distancePercentage">Current distance as percentage of total (0-100)</param>
    /// <param name="data">Movement configuration data</param>
    /// <returns>The calculated speed for the current frame</returns>
    /// <remarks>
    /// The speed calculation uses two different exponential curves:
    /// - Acceleration: speed = maxSpeed * (initial + (1-initial) * (1-e^(-aF * x)))
    /// - Deceleration: speed = maxSpeed * e^(-dF * x)
    /// Where:
    /// - aF = acceleration factor
    /// - dF = deceleration factor
    /// - x = progress (0 to 1) in current phase
    /// </remarks>
    private float CalculateSpeed(float distancePercentage, BurstMovementData data)
    {
        // Acceleration phase
        if (distancePercentage <= data.burstEndPercentage)
        {
            float accelerationProgress = distancePercentage / data.burstEndPercentage;
            // Use exponential approach for smooth acceleration
            return data.maxSpeed
                * (
                    data.initialSpeedPercent
                    + (1f - data.initialSpeedPercent)
                        * (1f - Mathf.Exp(-data.accelerationFactor * accelerationProgress))
                );
        }
        // Deceleration phase
        else
        {
            float decelerationProgress =
                (distancePercentage - data.burstEndPercentage) / (100f - data.burstEndPercentage);
            // Use exponential decay for natural-feeling deceleration
            return data.maxSpeed * Mathf.Exp(-data.decelerationFactor * decelerationProgress);
        }
    }

    /// <summary>
    /// Starts movement for all elements in the controller.
    /// </summary>
    public void StartAll()
    {
        foreach (var element in movementElements)
        {
            element.data.hasStarted = true;
            element.data.isFinished = false;
        }
    }

    /// <summary>
    /// Stops movement for all elements in the controller.
    /// </summary>
    public void StopAll()
    {
        foreach (var element in movementElements)
        {
            element.data.hasStarted = false;
        }
    }

    public void ResetAll()
    {
        for (int i = 0; i < cachedStartPosition.Length; i++)
        {
            movementElements[i].target.anchoredPosition = cachedStartPosition[i];
        }
    }

    /// <summary>
    /// Represents the configuration and runtime data for a single burst movement.
    /// Separates data from behavior following ECS principles.
    /// </summary>
    [System.Serializable]
    public struct BurstMovementData
    {
        public Vector2 direction; // Movement direction (will be normalized)
        public float maxDistance; // Total distance to travel

        public float maxSpeed; // Maximum movement speed during burst

        [Range(0.5f, 5)]
        public float accelerationFactor; // Controls how quickly max speed is reached

        [Range(0.5f, 5)]
        public float decelerationFactor; // Controls how quickly speed reduces after burst

        [Range(0f, 70f)]
        public float burstEndPercentage; // When to transition from burst to deceleration (% of total distance)

        [Range(0, 1)]
        public float initialSpeedPercent; // Starting speed as percentage of max speed

        // Runtime data - hidden from inspector
        [HideInInspector]
        public Vector2 startPosition;

        [HideInInspector]
        public float currentSpeed;

        [HideInInspector]
        public bool hasStarted;

        [HideInInspector]
        public bool isFinished;
    }

    /// <summary>
    /// Combines a UI element target with its movement configuration.
    /// </summary>
    [System.Serializable]
    public class BurstMovementElement
    {
        public RectTransform target; // The UI element to move
        public BurstMovementData data; // Movement configuration and runtime data
    }
}

================
File: MonoScripts/BurstMovementUIController.cs.meta
================
fileFormatVersion: 2
guid: 16ca30dd2c053408ca1f8899ec5e4e9e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/CrownTween.cs
================
using PrimeTween;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class CrownTween : MonoBehaviour
    {
        [SerializeField]
        private CrownProperties defaultValue;
        private CrownProperties[] crowns;
        private CrownProperties currentCrown;
        private int currentCrownIndexToProcess;

        public void InitializeCrowns(CrownProperties[] crownProperties)
        {
            this.crowns = crownProperties;
            currentCrownIndexToProcess = 0;
            Color color;

            for (int i = 0; i < crowns.Length; i++)
            {
                color = crowns[i].crownAwakenedImg.color;
                color.a = 0;
                ;
                crowns[i].crownAwakenedImg.color = color;
            }
        }

        public void PlayEffect()
        {
            currentCrown = crowns[currentCrownIndexToProcess];

            Tween
                .Scale(
                    target: currentCrown.crownRect,
                    startValue: currentCrown.scaleStartValue,
                    endValue: currentCrown.scaleMidValue,
                    duration: currentCrown.firstPhaseDuration,
                    ease: currentCrown.firstPhaseEase
                )
                .Group(
                    Tween.Scale(
                        target: currentCrown.crownAwakenedImg.rectTransform,
                        startValue: currentCrown.awakenedScaleStart,
                        endValue: currentCrown.awakenedScaleMid,
                        duration: currentCrown.firstPhaseDuration,
                        ease: currentCrown.firstPhaseEase
                    )
                )
                .Group(
                    Tween.Alpha(
                        target: currentCrown.crownAwakenedImg,
                        startValue: currentCrown.alphaStart,
                        endValue: currentCrown.alphaMid,
                        duration: currentCrown.firstPhaseDuration,
                        ease: currentCrown.firstPhaseEase
                    )
                )
                .Chain(
                    Tween
                        .Scale(
                            target: currentCrown.crownRect,
                            startValue: currentCrown.scaleMidValue,
                            endValue: currentCrown.scaleEndValue,
                            duration: currentCrown.secondPhaseDuration,
                            ease: currentCrown.secondPhaseEase
                        )
                        .Group(
                            Tween.Scale(
                                target: currentCrown.crownAwakenedImg.rectTransform,
                                startValue: currentCrown.awakenedScaleMid,
                                endValue: currentCrown.awakenedScaleEnd,
                                duration: currentCrown.secondPhaseDuration,
                                ease: currentCrown.secondPhaseEase
                            )
                        )
                        .Group(
                            Tween.Alpha(
                                target: currentCrown.crownAwakenedImg,
                                startValue: currentCrown.alphaMid,
                                endValue: currentCrown.alphaEnd,
                                duration: currentCrown.secondPhaseDuration,
                                ease: currentCrown.secondPhaseEase
                            )
                        )
                );
            currentCrownIndexToProcess++;
        }

        public bool IsAbleToPlay()
        {
            return currentCrownIndexToProcess < crowns.Length;
        }

        [System.Serializable]
        public class CrownProperties
        {
            [Header("Crown")]
            public RectTransform crownRect;
            public Image crownAwakenedImg;

            [Header("Scale properties")]
            public float scaleStartValue = 1f;
            public float scaleMidValue = 1.5f;
            public float scaleEndValue = 1f;

            [Header("Image awakened alpha properties")]
            public float awakenedScaleStart = 1f;
            public float awakenedScaleMid = 1.8f;
            public float awakenedScaleEnd = 1;
            public float alphaStart = 0;
            public float alphaMid = .5f;
            public float alphaEnd = 1f;

            [Header("Phase paremeters")]
            public float firstPhaseDuration = .4f;
            public Ease firstPhaseEase = Ease.OutCubic;
            public float secondPhaseDuration = .2f;
            public Ease secondPhaseEase = Ease.Linear;
        }
    }
}

================
File: MonoScripts/CrownTween.cs.meta
================
fileFormatVersion: 2
guid: 393ae28e0cc2e064691c4148f9fa023e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/EffectOnProgress.cs
================
using PrimeTween;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EffectOnProgress : MonoBehaviour
    {
        [SerializeField]
        private Vector2 startScale;

        [SerializeField]
        private Vector2 endScale;

        [SerializeField]
        private float duration;
        private RectTransform rectTransform;

        void Awake()
        {
            rectTransform = GetComponent<RectTransform>();
        }

        void Start()
        {
            Sequence
                .Create(cycles: -1)
                .Chain(
                    Tween.Scale(
                        target: rectTransform,
                        startValue: startScale,
                        endValue: endScale,
                        duration: duration,
                        ease: Ease.Linear
                    )
                )
                .Chain(
                    Tween.Scale(
                        target: rectTransform,
                        endValue: startScale,
                        duration: duration,
                        ease: Ease.Linear
                    )
                );
        }
    }
}

================
File: MonoScripts/EffectOnProgress.cs.meta
================
fileFormatVersion: 2
guid: 5bb97036fc31048bc8738dc49725bd85
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/ProgressEffectController.cs
================
using EventChannel;
using PrimeTween;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    [RequireComponent(typeof(StarTween))]
    [RequireComponent(typeof(CrownTween))]
    public class ProgressEffectController : MonoBehaviour
    {
        [SerializeField]
        private Slider progressSlider;

        [SerializeField]
        private RectTransform[] progressPoints;

        [SerializeField]
        private StarTween.StarProperties[] starPoints;

        [SerializeField]
        private CrownTween.CrownProperties[] crownPoints;

        private RectTransform progressSliderRect;

        private float[] segmentValues;

        private int currentPassedSegmentPoint;

        private StarTween starTween;
        private CrownTween crownTween;

        void Awake()
        {
            starTween = GetComponent<StarTween>();
            starTween.InitializeStars(starPoints);

            crownTween = GetComponent<CrownTween>();
            crownTween.InitializeCrowns(crownPoints);
        }

        void OnEnable()
        {
            progressSlider.onValueChanged.AddListener(OnProgressValueChanged);
        }

        void OnDisable()
        {
            progressSlider.onValueChanged.RemoveListener(OnProgressValueChanged);
        }

        void Start()
        {
            SetupPoints();
        }

        void OnValidate()
        {
            SetupPoints();
        }

        private void SetupPoints()
        {
            if (progressPoints.Length == 0 || progressSlider == null)
            {
                return;
            }

            if (progressSliderRect == null)
            {
                progressSliderRect = progressSlider.GetComponent<RectTransform>();
            }

            int pointCount = progressPoints.Length;
            float sliderWidth = progressSliderRect.sizeDelta.x;
            float segmentWidth = sliderWidth / pointCount;
            float baseSegmentValue = 1f / pointCount;

            segmentValues = new float[pointCount];

            for (int i = 0; i < progressPoints.Length; i++)
            {
                if (progressPoints[i] == null)
                    continue;
                progressPoints[i].anchoredPosition = new Vector2(
                    segmentWidth * (i + 1),
                    progressPoints[i].anchoredPosition.y
                );

                segmentValues[i] = (i + 1) * baseSegmentValue;
            }

            currentPassedSegmentPoint = 1;
        }

        private void OnProgressValueChanged(float value)
        {
            int index = currentPassedSegmentPoint - 1;

            if (value >= segmentValues[index])
            {
                if (starTween.IsAbleToPlay())
                {
                    starTween.PlayEffect();
                }
                else if (crownTween.IsAbleToPlay())
                {
                    crownTween.PlayEffect();
                }

                currentPassedSegmentPoint++;
            }
        }
    }
}

================
File: MonoScripts/ProgressEffectController.cs.meta
================
fileFormatVersion: 2
guid: 674545824a7a6ba4da646968bb607983
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/RaycastToObjects.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class RaycastToStartGame : MonoBehaviour
    {
        [SerializeField]
        private LayerMask targetLayer;

        [SerializeField]
        private IntEventChannel OnGameStartChannel;

        // Update is called once per frame
        void Update()
        {
            if (Input.GetMouseButtonDown(0))
            {
                FireRaycast();
            }
        }

        private void FireRaycast()
        {
            Vector2 mousePosition = Camera.main.ScreenToWorldPoint(Input.mousePosition);
            RaycastHit2D hit = Physics2D.Raycast(
                mousePosition,
                Vector2.zero,
                Mathf.Infinity,
                targetLayer
            );

            if (hit.collider != null)
            {
                if (hit.collider.tag == "StartNote")
                {
                    OnGameStartChannel?.RaiseEvent(
                        hit.collider.GetComponent<IEntityHolder>().EntityId
                    );
                }
            }
            else
            {
                Debug.Log("No object hit.");
            }
        }
    }
}

================
File: MonoScripts/RaycastToObjects.cs.meta
================
fileFormatVersion: 2
guid: 2b6518ec189777e4cbad7fdd60b44c76
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/ScoreEffectController.cs
================
using System;
using EventChannel;
using PrimeTween;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class ScoreEffectController : MonoBehaviour
    {
        [Header("Event Channels")]
        [SerializeField]
        private BoolEventChannel scoreSignalEffectChannel;

        [Header("Main Effect components")]
        [SerializeField]
        private CanvasGroup perfectScorePrefab;

        [SerializeField]
        private CanvasGroup greatScorePrefab;

        [Header("Burst Movement Setup")]
        [SerializeField]
        private BurstMovementUIController burstMovementUIController;

        [SerializeField]
        private BurstMovementUIController.BurstMovementElement[] burstMovementElements;
        private Sequence effectSequence;

        void Awake()
        {
            burstMovementUIController.InitializeElement(burstMovementElements);
        }

        void OnEnable()
        {
            scoreSignalEffectChannel.Subscribe(PlayEffect);
        }

        void OnDisable()
        {
            scoreSignalEffectChannel.Unsubscribe(PlayEffect);
        }

        private void PlayEffect(bool isPerfect)
        {
            effectSequence.Stop();

            burstMovementUIController?.ResetAll();
            burstMovementUIController?.StartAll();
            perfectScorePrefab.alpha = 1;

            for (int i = 1; i < burstMovementElements.Length; i++)
            {
                burstMovementElements[i].target.rotation = Quaternion.Euler(
                    0,
                    0,
                    UnityEngine.Random.Range(0, 360)
                );
            }

            effectSequence = Tween
                .Scale(
                    target: perfectScorePrefab.transform,
                    startValue: Vector3.zero,
                    endValue: Vector3.one,
                    duration: 0.2f,
                    ease: Ease.Linear
                )
                .Chain(
                    Tween
                        .Delay(duration: 0.5f)
                        .Chain(
                            Tween
                                .Alpha(
                                    target: perfectScorePrefab,
                                    startValue: 1f,
                                    endValue: 0f,
                                    duration: 0.5f,
                                    ease: Ease.Linear
                                )
                                .OnComplete(() =>
                                {
                                    burstMovementUIController.StopAll();
                                })
                        )
                );
        }
    }
}

================
File: MonoScripts/ScoreEffectController.cs.meta
================
fileFormatVersion: 2
guid: 4c404b5dc2d1b3243807aa10259f386a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/ScreenManager.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ScreenManager : PersistentSingleton<ScreenManager>
    {
        [SerializeField]
        private BoolEventChannel OnOrientationChange;

        public bool IsPortrait { get; private set; }

        void Start()
        {
            IsPortrait = Screen.currentResolution.width > Screen.currentResolution.height;
        }

        private void Update()
        {
            if (Screen.currentResolution.width < Screen.currentResolution.height)
            {
                if (!IsPortrait)
                {
                    IsPortrait = true;
                    OnOrientationChange.RaiseEvent(true);
                }
            }
            else
            {
                if (IsPortrait)
                {
                    IsPortrait = false;
                    OnOrientationChange.RaiseEvent(false);
                }
            }
        }
    }
}

================
File: MonoScripts/ScreenManager.cs.meta
================
fileFormatVersion: 2
guid: b5f3dbf897bb5481aa2da1550e237f93
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/StarTween.cs
================
using System;
using PrimeTween;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class StarTween : MonoBehaviour
    {
        [SerializeField]
        private StarProperties defaultValue;
        private StarProperties[] stars;
        private int currentStarIndexToProcess;

        StarProperties currentStar;

        public void InitializeStars(StarProperties[] stars)
        {
            this.stars = stars;
            currentStarIndexToProcess = 0;
            Color color;
            for (int i = 0; i < stars.Length; i++)
            {
                color = stars[i].starAwakenedImg.color;
                color.a = 0;
                ;
                stars[i].starAwakenedImg.color = color;
            }
        }

        public void PlayEffect()
        {
            currentStar = stars[currentStarIndexToProcess];

            Tween
                .Scale(
                    target: currentStar.starRect,
                    startValue: currentStar.scaleStartValue,
                    endValue: currentStar.scaleMidValue,
                    duration: currentStar.firstPhaseDuration,
                    ease: currentStar.firstPhaseEase
                )
                .Group(
                    Tween.Rotation(
                        target: currentStar.starRect,
                        startValue: currentStar.rotationStartValue,
                        endValue: currentStar.rotationMidValue,
                        duration: currentStar.firstPhaseDuration,
                        ease: currentStar.firstPhaseEase
                    )
                )
                .Group(
                    Tween.Alpha(
                        target: currentStar.starAwakenedImg,
                        startValue: currentStar.alphaStart,
                        endValue: currentStar.alphaMid,
                        duration: currentStar.firstPhaseDuration,
                        ease: currentStar.firstPhaseEase
                    )
                )
                .Group(
                    Tween.Scale(
                        target: currentStar.starAwakenedImg.rectTransform,
                        startValue: currentStar.awakenedScaleStart,
                        endValue: currentStar.awakenedScaleMid,
                        duration: currentStar.firstPhaseDuration,
                        ease: currentStar.firstPhaseEase
                    )
                )
                .Chain(
                    Tween
                        .Scale(
                            target: currentStar.starRect,
                            startValue: currentStar.scaleMidValue,
                            endValue: currentStar.scaleEndValue,
                            duration: currentStar.secondPhaseDuration,
                            ease: currentStar.secondPhaseEase
                        )
                        .Group(
                            Tween.Rotation(
                                target: currentStar.starRect,
                                startValue: currentStar.rotationMidValue,
                                endValue: currentStar.rotationEndValue,
                                duration: currentStar.secondPhaseDuration,
                                ease: currentStar.secondPhaseEase
                            )
                        )
                        .Group(
                            Tween.Alpha(
                                target: currentStar.starAwakenedImg,
                                startValue: currentStar.alphaMid,
                                endValue: currentStar.alphaEnd,
                                duration: currentStar.secondPhaseDuration,
                                ease: currentStar.secondPhaseEase
                            )
                        )
                        .Group(
                            Tween.Scale(
                                target: currentStar.starAwakenedImg.rectTransform,
                                startValue: currentStar.awakenedScaleMid,
                                endValue: currentStar.awakenedScaleEnd,
                                duration: currentStar.secondPhaseDuration,
                                ease: currentStar.secondPhaseEase
                            )
                        )
                );
            currentStarIndexToProcess++;
        }

        public bool IsAbleToPlay()
        {
            return currentStarIndexToProcess < stars.Length;
        }

        [Serializable]
        public class StarProperties
        {
            [Header("Star")]
            public RectTransform starRect;
            public Image starAwakenedImg;

            [Header("Scale properties")]
            public float scaleStartValue = 1f;
            public float scaleMidValue = 1.5f;
            public float scaleEndValue = 1f;

            [Header("Rotation properties")]
            public Vector3 rotationStartValue = new Vector3(0, 0, -180);
            public Vector3 rotationMidValue = new Vector3(0, 0, -240);
            public Vector3 rotationEndValue = new Vector3(0, 0, -360);

            [Header("Image awakened alpha properties")]
            public float awakenedScaleStart = 1f;
            public float awakenedScaleMid = 1.8f;
            public float awakenedScaleEnd = 1;
            public float alphaStart = 0;
            public float alphaMid = .5f;
            public float alphaEnd = 1f;

            [Header("Phase paremeters")]
            public float firstPhaseDuration = .4f;
            public Ease firstPhaseEase = Ease.OutCubic;
            public float secondPhaseDuration = .2f;
            public Ease secondPhaseEase = Ease.Linear;
        }
    }
}

================
File: MonoScripts/StarTween.cs.meta
================
fileFormatVersion: 2
guid: 6510a45b25480bc44839f20bff11111d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts/VerticalLineSetup.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public class VerticalLineSetup : MonoBehaviour
    {
        private RectTransform[] verticalLines;
    }
}

================
File: MonoScripts/VerticalLineSetup.cs.meta
================
fileFormatVersion: 2
guid: a2bf9baa3aab15a4da083e100b25e8d4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO_SCripts/GeneralGameSetting.cs
================
using UnityEngine;

[CreateAssetMenu(fileName = "GeneralGameSetting_SO", menuName = "Settings/GeneralGameSetting")]
public class GeneralGameSetting : ScriptableObject
{
    public float GameSpeed;

    public float PreciseGameSpeed { get; set; }
}

================
File: Settings/SO_SCripts/GeneralGameSetting.cs.meta
================
fileFormatVersion: 2
guid: 24a2a689475a5aa4997e54b10cc3c33c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO_SCripts/LaneLineSettings.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(fileName = "LaneLineSettings_SO", menuName = "Settings/LaneLineSettings")]
    public class LaneLineSettings : ScriptableObject
    {
        public GameObject landLinePrefab;

        public RangeReactiveFloat laneLineWidth;

        private void OnValidate()
        {
            laneLineWidth.OnChangeValidatedInInpsector();
        }
    }
}

================
File: Settings/SO_SCripts/LaneLineSettings.cs.meta
================
fileFormatVersion: 2
guid: bfcaf33992d1246beafffa977f1b7a56
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO_SCripts/MidiNoteParser.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

public static class MidiNoteParser
{
    public static MusicNoteMidiData ParseFromText(string content)
    {
        if (string.IsNullOrEmpty(content))
            throw new MidiParseException("MIDI content cannot be empty");

        var entries = content.Split(',', StringSplitOptions.RemoveEmptyEntries);
        if (entries.Length == 0)
            throw new MidiParseException("No valid MIDI entries found");

        // Split into note entries
        var data = new MusicNoteMidiData(entries.Length);

        for (int i = 0; i < entries.Length; i++)
        {
            try
            {
                ParseEntry(entries[i], i, ref data);
                data.TotalNotes++;
            }
            catch (Exception ex)
            {
                throw new MidiParseException($"Error parsing entry {i}: {ex.Message}");
            }
        }

        ValidateData(ref data);

        return data;
    }

    private static void ParseEntry(string entry, int index, ref MusicNoteMidiData data)
    {
        var properties = entry.Split('-');
        var requiredFields = new HashSet<string> { "id", "n", "ta", "ts", "d", "v", "pid" };
        var parsedFields = new HashSet<string>();

        foreach (var prop in properties)
        {
            var kv = prop.Split(':');
            if (kv.Length != 2)
                throw new MidiParseException($"Invalid property format: {prop}");

            if (!ParseProperty(kv[0], kv[1], index, ref data))
                throw new MidiParseException($"Failed to parse property: {kv[0]}");

            parsedFields.Add(kv[0]);
        }

        // Check for missing required fields
        requiredFields.ExceptWith(parsedFields);
        if (requiredFields.Count > 0)
            throw new MidiParseException(
                $"Missing required fields: {string.Join(", ", requiredFields)}"
            );
    }

    private static bool ParseProperty(
        string key,
        string value,
        int index,
        ref MusicNoteMidiData data
    )
    {
        try
        {
            switch (key)
            {
                case "id":
                    data.Ids[index] = int.Parse(value);
                    break;
                case "n":
                    data.NoteNumbers[index] = int.Parse(value);
                    break;
                case "ta":
                    data.TimeAppears[index] = float.Parse(value);
                    break;
                case "ts":
                    data.Timespans[index] = float.Parse(value);
                    break;
                case "d":
                    float duration = float.Parse(value);
                    data.Durations[index] = duration;
                    data.MinDuration = Mathf.Min(data.MinDuration, duration);
                    break;
                case "v":
                    data.Velocities[index] = float.Parse(value);
                    break;
                case "pid":
                    data.PositionIds[index] = int.Parse(value);
                    break;
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static void ValidateData(ref MusicNoteMidiData data)
    {
        if (data.MinDuration <= 0)
            throw new MidiParseException("Invalid minimum duration");

        if (data.TotalNotes <= 0)
            throw new MidiParseException("No valid notes parsed");
    }
}

public class MidiParseException : Exception
{
    public MidiParseException(string message)
        : base(message) { }
}

================
File: Settings/SO_SCripts/MidiNoteParser.cs.meta
================
fileFormatVersion: 2
guid: ccd8b8d0c202c4c46a3c94a768d54c37
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO_SCripts/MusicNoteCreationSetting.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(
        fileName = "MusicNoteCreationSetting_SO",
        menuName = "Settings/MusicNoteCreationSetting"
    )]
    public class MusicNoteCreationSetting : ScriptableObject
    {
        [Header("Note Calculation Mode")]
        public bool UsePreciseNoteCalculation;

        [Header("Song Data")]
        public TextAsset MidiContent;

        [Header("Note Configuration")]
        [Header("Portrait")]
        public float ShortNoteScaleYFactor;
        public float LongNoteScaleYFactor;
        public float startingNoteLane;

        [Header("Prefabs")]
        public GameObject LongTilePrefab;
        public GameObject ShortTilePrefab;
        public GameObject startingNotePrefab;
    }
}

================
File: Settings/SO_SCripts/MusicNoteCreationSetting.cs.meta
================
fileFormatVersion: 2
guid: a5af8e59dd796d941989a811a2c8754b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO_SCripts/PerfectLineSetting.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(
        fileName = "PerfectLineSetting_SO",
        menuName = "Settings/PerfectLineSetting_SO"
    )]
    public class PerfectLineSetting : ScriptableObject
    {
        [Header(" Normalize Positions")]
        public NormalizedFloatPreset portraitNormalizedPos;

        public NormalizedFloatPreset landscapeNormalizedPos;

        [Header("Normalized Size")]
        public NormalizedFloatPreset portraitNormalizedSize;

        public NormalizedFloatPreset landscapeNormalizedSize;

        [System.Serializable]
        public struct NormalizedFloatPreset
        {
            public RangeReactiveFloat normalizedX;

            public RangeReactiveFloat normalizedY;
        }

        private void OnValidate()
        {
            portraitNormalizedPos.normalizedX.OnChangeValidatedInInpsector();
            portraitNormalizedPos.normalizedY.OnChangeValidatedInInpsector();

            landscapeNormalizedPos.normalizedX.OnChangeValidatedInInpsector();
            landscapeNormalizedPos.normalizedY.OnChangeValidatedInInpsector();

            portraitNormalizedSize.normalizedX.OnChangeValidatedInInpsector();
            portraitNormalizedSize.normalizedY.OnChangeValidatedInInpsector();

            landscapeNormalizedSize.normalizedX.OnChangeValidatedInInpsector();
            landscapeNormalizedSize.normalizedY.OnChangeValidatedInInpsector();
        }
    }

    [Serializable]
    public class RangeReactiveFloat : ReactiveValue<float>
    {
        [Range(0, 1)]
        protected new float _value;
    }
}

================
File: Settings/SO_SCripts/PerfectLineSetting.cs.meta
================
fileFormatVersion: 2
guid: 2794e685ab5b84c7299a27a309baa90b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO_SCripts/ScoreEffectSettings.cs
================
using UnityEngine;

namespace ECS_MagicTile.Settings
{
    [CreateAssetMenu(
        fileName = "ScoreEffectSettings_SO",
        menuName = "Settings/ScoreEffectSettings"
    )]
    public class ScoreEffectSettings : ScriptableObject
    {
        [Header("Perfect Score Effect")]
        public GameObject perfectScoreEffectPrefab;

        [Header("Great Score Prefab")]
        public GameObject greatScoreEffectPrefab;
    }
}

================
File: Settings/SO_SCripts/ScoreEffectSettings.cs.meta
================
fileFormatVersion: 2
guid: 90b3ef9aef2e740baa6d7b0a8da6158d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/GeneralGameSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 24a2a689475a5aa4997e54b10cc3c33c, type: 3}
  m_Name: GeneralGameSetting_SO
  m_EditorClassIdentifier: 
  GameSpeed: 0

================
File: Settings/GeneralGameSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: cc747aeaca6f5864099880016a577e56
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/LaneLineSettings_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: bfcaf33992d1246beafffa977f1b7a56, type: 3}
  m_Name: LaneLineSettings_SO
  m_EditorClassIdentifier: 
  landLinePrefab: {fileID: 856688113385644598, guid: af74a368381e1114095acf0acae2ec78, type: 3}
  laneLineWidth:
    _value: 0.004

================
File: Settings/LaneLineSettings_SO.asset.meta
================
fileFormatVersion: 2
guid: 6a5958e8da5e84e76b82907765c02fbe
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/MusicNoteCreationSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a5af8e59dd796d941989a811a2c8754b, type: 3}
  m_Name: MusicNoteCreationSetting_SO
  m_EditorClassIdentifier: 
  UsePreciseNoteCalculation: 1
  MidiContent: {fileID: 4900000, guid: 5651cca0434e843a4af2569038996f88, type: 3}
  ShortNoteScaleYFactor: 2
  LongNoteScaleYFactor: 2.5
  startingNoteLane: 0
  LongTilePrefab: {fileID: 8137537297466452066, guid: 12f1ab7db8533406285c2148378e45d8, type: 3}
  ShortTilePrefab: {fileID: 8137537297466452066, guid: 8c1c272d019a341fa8cc13b90b199606, type: 3}
  startingNotePrefab: {fileID: 8137537297466452066, guid: 3ab92a42b30f7d440901bcd50afe0d58, type: 3}

================
File: Settings/MusicNoteCreationSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: 5d1ed20f8d24fbd4f95a64d2f692fb66
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/PerfectLineSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 2794e685ab5b84c7299a27a309baa90b, type: 3}
  m_Name: PerfectLineSetting_SO
  m_EditorClassIdentifier: 
  portraitNormalizedPos:
    normalizedX:
      _value: 0.5
    normalizedY:
      _value: 0.3
  landscapeNormalizedPos:
    normalizedX:
      _value: 0.5
    normalizedY:
      _value: 0.3
  portraitNormalizedSize:
    normalizedX:
      _value: 1
    normalizedY:
      _value: 0.004
  landscapeNormalizedSize:
    normalizedX:
      _value: 0.5
    normalizedY:
      _value: 0.004

================
File: Settings/PerfectLineSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: d1a21492714ea480f9449e5933a8acd1
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/ScoreEffectSettings_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 90b3ef9aef2e740baa6d7b0a8da6158d, type: 3}
  m_Name: ScoreEffectSettings_SO
  m_EditorClassIdentifier: 
  perfectScoreEffectPrefab: {fileID: 0}
  greatScoreEffectPrefab: {fileID: 0}

================
File: Settings/ScoreEffectSettings_SO.asset.meta
================
fileFormatVersion: 2
guid: 0fc1bf2a08ee74502af5a8c06e294b7f
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO_SCripts.meta
================
fileFormatVersion: 2
guid: ae204fe6d86024e5e910ea37c76036a1
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers/GameScoreSyncTool.cs
================
using ECS_MagicTile.Components;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class GameScoreSyncTool : BaseSyncTool
    {
        public GameScoreSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            scoreText = globalPoint.scoreText;
        }

        protected override Archetype Archetype => Archetype.Registry.GameScore;
        private readonly Text scoreText;

        public void SyncGameScore(ScoreComponent scoreComponent)
        {
            scoreText.text = $"Score: {scoreComponent.TotalScore}";
        }
    }
}

================
File: Syncers/GameScoreSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 0c8248051d057454891cb9aa519fe33f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers/LaneLineSyncTool.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class LaneLineSyncTool : BaseSyncTool
    {
        public LaneLineSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            laneLineViewFactory = new EntityViewFactory(
                globalPoint.laneLineSettings.landLinePrefab,
                null
            );
        }

        protected override Archetype Archetype => Archetype.Registry.LaneLines;

        public SpriteRenderer[] LaneLineSprites => laneLineSprites;

        private readonly EntityViewFactory laneLineViewFactory;
        private SpriteRenderer[] laneLineSprites;

        public override void InitializeTool()
        {
            base.InitializeTool();
            laneLineSprites = new SpriteRenderer[DedicatedStorage.Count];

            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];
                laneLineSprites[i] = GetOrCreateLaneLineView(entityId)
                    .GetComponent<SpriteRenderer>();
            }
        }

        public void SyncLaneLineTransform(TransformComponent[] lanelineTransform)
        {
            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                laneLineSprites[i].transform.position = lanelineTransform[i].Position;
                laneLineSprites[i].transform.localScale = lanelineTransform[i].Size;
            }
        }

        private GameObject GetOrCreateLaneLineView(int entityId)
        {
            return laneLineViewFactory.GetOrCreateView(entityId);
        }
    }
}

================
File: Syncers/LaneLineSyncTool.cs.meta
================
fileFormatVersion: 2
guid: a6ae83dcdaff94f34bcae29a8ff8377d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers/MusicNoteSyncer.cs
================
using System;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteSyncer : ArchetypeSyncer
    {
        protected override Archetype Archetype => Archetype.Registry.MusicNote;

        public override EGameState GameStateToExecute { get; } = EGameState.Ingame;

        private readonly EntityViewFactory shortNoteViewFactory;
        private readonly EntityViewFactory longNoteViewFactory;

        // Cache component arrays to avoid getting them each frame
        private TransformComponent[] transforms;
        private MusicNoteComponent[] notes;
        private MusicNoteInteractionComponent[] interactions;
        private MusicNoteFillerComponent[] fillers;

        // Cache frequently accessed components
        private readonly Dictionary<int, SpriteRenderer> noteRenderers = new();
        private readonly Dictionary<int, (GameObject obj, SpriteRenderer renderer)> fillerCache =
            new();

        public MusicNoteSyncer(GlobalPoint globalPoint)
        {
            shortNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.ShortTilePrefab,
                globalPoint.transform
            );
            longNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.LongTilePrefab,
                globalPoint.transform
            );
        }

        public override void Initialize()
        {
            IsEnabled = true;

            // Initialize component array references
            transforms = DedicatedStorage.GetComponents<TransformComponent>();
            notes = DedicatedStorage.GetComponents<MusicNoteComponent>();
            interactions = DedicatedStorage.GetComponents<MusicNoteInteractionComponent>();
            fillers = DedicatedStorage.GetComponents<MusicNoteFillerComponent>();
        }

        public override void Update(float deltaTime)
        {
            // Process notes in batches for better cache utilization
            const int BATCH_SIZE = 64;
            int totalNotes = DedicatedStorage.Count;

            for (int batchStart = 0; batchStart < totalNotes; batchStart += BATCH_SIZE)
            {
                int batchEnd = Math.Min(batchStart + BATCH_SIZE, totalNotes);
                ProcessNoteBatch(batchStart, batchEnd);
            }
        }

        private void ProcessNoteBatch(int start, int end)
        {
            for (int i = start; i < end; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];

                // Get or create view based on note type
                GameObject view = GetOrCreateNoteView(entityId, notes[i].musicNoteType);

                view.transform.position = transforms[i].Position;
                view.transform.localScale = transforms[i].Size;

                SyncNoteState(entityId, view, notes[i], interactions[i], fillers[i]);
            }
        }

        private GameObject GetOrCreateNoteView(int entityId, MusicNoteType noteType)
        {
            return noteType == MusicNoteType.LongNote
                ? longNoteViewFactory.GetOrCreateView(entityId, "longNote")
                : shortNoteViewFactory.GetOrCreateView(entityId, "shortNote");
        }

        private void SyncNoteState(
            int entityId,
            GameObject view,
            MusicNoteComponent note,
            MusicNoteInteractionComponent interaction,
            MusicNoteFillerComponent filler
        )
        {
            // Get cached renderer or cache it
            if (!noteRenderers.TryGetValue(entityId, out var noteRenderer))
            {
                noteRenderer = view.GetComponent<SpriteRenderer>();
                noteRenderers[entityId] = noteRenderer;
            }

            // Update note color based on state
            UpdateNoteColor(noteRenderer, interaction.State);

            // Handle long note filler
            if (note.musicNoteType == MusicNoteType.LongNote)
            {
                SyncNoteFiller(entityId, view, filler);
            }
        }

        private static void UpdateNoteColor(
            SpriteRenderer renderer,
            MusicNoteInteractiveState state
        )
        {
            renderer.color = state switch
            {
                MusicNoteInteractiveState.Normal => Color.white,
                MusicNoteInteractiveState.Pressed or MusicNoteInteractiveState.Hold => Color.yellow,
                MusicNoteInteractiveState.Completed => new Color(1, 1, 1, 0.5f),
                _ => Color.white,
            };
        }

        private void SyncNoteFiller(int entityId, GameObject view, MusicNoteFillerComponent filler)
        {
            if (!fillerCache.TryGetValue(entityId, out var fillerComponents))
            {
                var fillerObj = view.transform.Find("Filler")?.gameObject;
                if (fillerObj != null)
                {
                    fillerComponents = (fillerObj, fillerObj.GetComponent<SpriteRenderer>());
                    fillerCache[entityId] = fillerComponents;
                }
            }

            if (fillerComponents.obj != null)
            {
                fillerComponents.obj.SetActive(filler.IsVisible);
                if (filler.IsVisible)
                {
                    UpdateFillerVisuals(
                        fillerComponents.obj,
                        fillerComponents.renderer,
                        filler.FillPercent
                    );
                }
            }
        }

        private static void UpdateFillerVisuals(
            GameObject fillerObj,
            SpriteRenderer renderer,
            float fillPercent
        )
        {
            Vector3 scale = fillerObj.transform.localScale;
            scale.y = fillPercent;
            SpriteUtility.ScaleFromPivot(renderer, scale, SpriteUtility.PivotPointXY.Bottom);
            renderer.color = Color.Lerp(Color.yellow, Color.green, fillPercent);
        }
    }
}

================
File: Syncers/MusicNoteSyncer.cs.meta
================
fileFormatVersion: 2
guid: 541f4a77356ee45a381eacb214f2b6e2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers/MusicNoteViewSyncTool.cs
================
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteViewSyncTool : BaseSyncTool
    {
        private readonly EntityViewFactory shortNoteViewFactory;
        private readonly EntityViewFactory longNoteViewFactory;
        protected override Archetype Archetype => Archetype.Registry.MusicNote;

        private readonly Dictionary<int, SpriteRenderer> noteRenderers = new();
        private readonly Dictionary<int, (GameObject obj, SpriteRenderer renderer)> fillerCache =
            new();

        public MusicNoteViewSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            shortNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.ShortTilePrefab,
                globalPoint.transform
            );
            longNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.LongTilePrefab,
                globalPoint.transform
            );
        }

        private GameObject GetOrCreateNoteView(int entityId, MusicNoteType noteType)
        {
            return noteType == MusicNoteType.LongNote
                ? longNoteViewFactory.GetOrCreateView(entityId, "longNote")
                : shortNoteViewFactory.GetOrCreateView(entityId, "shortNote");
        }

        public void SyncNoteTransforms(TransformComponent[] transforms, MusicNoteComponent[] notes)
        {
            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];
                GameObject view = GetOrCreateNoteView(entityId, notes[i].musicNoteType);

                view.transform.position = transforms[i].Position;
                view.transform.localScale = transforms[i].Size;
            }
        }

        public void SyncNoteState(
            MusicNoteInteractionComponent[] interaction,
            MusicNoteFillerComponent[] fillers,
            MusicNoteComponent[] notes
        )
        {
            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];
                GameObject view = GetOrCreateNoteView(entityId, notes[i].musicNoteType);

                if (!noteRenderers.TryGetValue(entityId, out var noteRenderer))
                {
                    noteRenderer = view.GetComponent<SpriteRenderer>();
                    noteRenderers[entityId] = noteRenderer;
                }

                // Update note color based on state
                UpdateNoteColor(noteRenderer, interaction[i].State);

                // Handle long note filler
                if (notes[i].musicNoteType == MusicNoteType.LongNote)
                {
                    SyncNoteFiller(entityId, view, fillers[i]);
                }
            }
        }

        private static void UpdateNoteColor(
            SpriteRenderer renderer,
            MusicNoteInteractiveState state
        )
        {
            renderer.color = state switch
            {
                MusicNoteInteractiveState.Normal => Color.white,
                MusicNoteInteractiveState.Pressed or MusicNoteInteractiveState.Hold => Color.yellow,
                MusicNoteInteractiveState.Completed => new Color(1, 1, 1, 0.5f),
                _ => Color.white,
            };
        }

        public void SyncNoteFiller(int entityId, GameObject view, MusicNoteFillerComponent filler)
        {
            if (!fillerCache.TryGetValue(entityId, out var fillerComponents))
            {
                var fillerObj = view.transform.Find("Filler")?.gameObject;
                if (fillerObj != null)
                {
                    fillerComponents = (fillerObj, fillerObj.GetComponent<SpriteRenderer>());
                    fillerCache[entityId] = fillerComponents;
                }
            }

            if (fillerComponents.obj != null)
            {
                fillerComponents.obj.SetActive(filler.IsVisible);
                if (filler.IsVisible)
                {
                    UpdateFillerVisuals(
                        fillerComponents.obj,
                        fillerComponents.renderer,
                        filler.FillPercent
                    );
                }
            }
        }

        private static void UpdateFillerVisuals(
            GameObject fillerObj,
            SpriteRenderer renderer,
            float fillPercent
        )
        {
            Vector3 scale = fillerObj.transform.localScale;
            scale.y = fillPercent;
            SpriteUtility.ScaleFromPivot(renderer, scale, SpriteUtility.PivotPointXY.Bottom);
            renderer.color = Color.Lerp(Color.yellow, Color.green, fillPercent);
        }
    }
}

================
File: Syncers/MusicNoteViewSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 22e852c0f8e864a82b2f0b4de5c0d491
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers/PerfectLineSyncTool.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class PerfectLineSyncTool : BaseSyncTool
    {
        protected override Archetype Archetype => Archetype.Registry.PerfectLine;
        private SpriteRenderer perfectLineSprite;

        public PerfectLineSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            perfectLineSprite = globalPoint.perfectLineObject.GetComponent<SpriteRenderer>();
        }

        public void SyncPerfectLineTransform(TransformComponent perfectLineTransform)
        {
            perfectLineSprite.transform.position = perfectLineTransform.Position;
            perfectLineSprite.transform.localScale = perfectLineTransform.Size;
        }
    }
}

================
File: Syncers/PerfectLineSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 819e9d873fddd406b8d1b795f2309e15
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers/ProgressSyncer.cs
================
using EventChannel;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class ProgressSyncer : ArchetypeSyncer
    {
        public override EGameState GameStateToExecute => EGameState.Ingame;

        protected override Archetype Archetype => Archetype.Registry.SongProgress;

        private readonly BoolEventChannel scoreEventChannel;

        private readonly Slider progressSlider;

        private ProgressComponent[] progressComponents;

        public ProgressSyncer(GlobalPoint globalPoint)
        {
            scoreEventChannel = globalPoint.OnScoreHitChannel;
            progressSlider = globalPoint.progressSlider;
        }

        public override void Initialize()
        {
            IsEnabled = true;

            progressComponents = DedicatedStorage.GetComponents<ProgressComponent>();

            scoreEventChannel.Subscribe(SyncProgressToView);
        }

        private void SyncProgressToView(bool isPerfect)
        {
            ProgressComponent progressComponent = progressComponents[0];
            progressSlider.value = progressComponent.currentProgressPercent;
        }
    }
}

================
File: Syncers/ProgressSyncer.cs.meta
================
fileFormatVersion: 2
guid: 5cdfedb8ec59b493682499a649eefe39
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers/ProgressSyncTool.cs
================
using ECS_MagicTile;
using UnityEngine.UI;

public class ProgressSyncTool : BaseSyncTool
{
    public ProgressSyncTool(GlobalPoint globalPoint)
        : base(globalPoint)
    {
        progressSlider = globalPoint.progressSlider;
    }

    protected override Archetype Archetype => Archetype.Registry.SongProgress;

    private readonly Slider progressSlider;

    public void SycnProgress(ProgressComponent progressComponent)
    {
        progressSlider.value = progressComponent.currentProgressPercent;
    }
}

================
File: Syncers/ProgressSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 993d5dc1edc4c46a1b6c416f877f7f11
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers/ScoreUISyncer.cs
================
using ECS_MagicTile;
using ECS_MagicTile.Components;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class ScoreUISyncer : ArchetypeSyncer
    {
        public override EGameState GameStateToExecute => EGameState.All;

        protected override Archetype Archetype => Archetype.Registry.GameScore;

        private readonly Text scoreText;

        // Instead of creating UI, we receive references to existing UI elements
        public ScoreUISyncer(GlobalPoint globalPoint)
        {
            this.scoreText = globalPoint.scoreText;
        }

        public override void Update(float deltaTime)
        {
            // Get score data from storage
            ScoreComponent scoreComponent = DedicatedStorage.GetComponents<ScoreComponent>()[0];

            // Update UI
            scoreText.text = $"Score: {scoreComponent.TotalScore}";
        }
    }
}

================
File: Syncers/ScoreUISyncer.cs.meta
================
fileFormatVersion: 2
guid: 3a2ef7a4a601b9a45a648bd1a5870c32
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers/StartingNoteSyncer.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class StartingNoteSyncer : ArchetypeSyncer
    {
        protected override Archetype Archetype => Archetype.Registry.StartingNote;

        public override EGameState GameStateToExecute => EGameState.All;

        private readonly EntityViewFactory startingNoteFactory;

        ActiveStateComponent[] startingNoteActiveStateComponents;
        TransformComponent[] startingNoteTransformComponents;

        private GameObject startingNoteViewObject;

        public StartingNoteSyncer(GlobalPoint globalPoint)
        {
            startingNoteFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.startingNotePrefab,
                globalPoint.transform
            );
        }

        public override void Initialize()
        {
            base.Initialize();
            IsEnabled = true;

            startingNoteActiveStateComponents =
                DedicatedStorage.GetComponents<ActiveStateComponent>();

            startingNoteTransformComponents = DedicatedStorage.GetComponents<TransformComponent>();

            int entityId_ = DedicatedStorage.EntityIds[0];

            startingNoteViewObject = startingNoteFactory.GetOrCreateView(entityId_, "StartingNote");
            startingNoteViewObject.transform.localScale = startingNoteTransformComponents[0].Size;
        }

        public override void Update(float deltaTime)
        {
            startingNoteViewObject.SetActive(startingNoteActiveStateComponents[0].isActive);
            // if (!startingNoteViewObject.activeSelf)
            // {
            //     IsEnabled = false;
            // }

            startingNoteViewObject.transform.position = startingNoteTransformComponents[0].Position;
            startingNoteViewObject.transform.localScale = startingNoteTransformComponents[0].Size;
        }
    }
}

================
File: Syncers/StartingNoteSyncer.cs.meta
================
fileFormatVersion: 2
guid: c69681375b44edd44bf95aec281d01af
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers/StartingNoteSyncTool.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class StartingNoteSyncTool : BaseSyncTool
    {
        public StartingNoteSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            startingNoteFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.startingNotePrefab,
                globalPoint.transform
            );
        }

        protected override Archetype Archetype => Archetype.Registry.StartingNote;

        private readonly EntityViewFactory startingNoteFactory;
        private GameObject startingNoteViewObject;

        public override void InitializeTool()
        {
            base.InitializeTool();
            int entityId_ = DedicatedStorage.EntityIds[0];

            startingNoteViewObject = startingNoteFactory.GetOrCreateView(entityId_, "StartingNote");
        }

        public void SyncStartNoteTransform(TransformComponent startNoteTransform)
        {
            startingNoteViewObject.transform.position = startNoteTransform.Position;
            startingNoteViewObject.transform.localScale = startNoteTransform.Size;
        }

        public void SyncStartNoteState(ActiveStateComponent startNoteState)
        {
            startingNoteViewObject.SetActive(startNoteState.isActive);
        }
    }
}

================
File: Syncers/StartingNoteSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 59c15b38042c74518a09fc378d320993
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/GameStateSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class GameStateSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.All;

        private readonly IntEventChannel OnGameStartChannel;

        ArchetypeStorage startingNoteStorage;
        ActiveStateComponent[] startingNoteActiveState;
        private StartingNoteSyncTool startingNoteSyncTool;

        public GameStateSystem(GlobalPoint globalPoint)
        {
            OnGameStartChannel = globalPoint.OnGameStartChannel;

            startingNoteSyncTool = globalPoint.startingNoteSyncTool;
        }

        public void Cleanup()
        {
            //
        }

        public void Initialize()
        {
            startingNoteStorage = World.GetStorage(Archetype.Registry.StartingNote);

            startingNoteActiveState = startingNoteStorage.GetComponents<ActiveStateComponent>();

            OnGameStartChannel.Subscribe(OnStartNoteInteraction);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            //
        }

        private void OnStartNoteInteraction(int startNoteId)
        {
            SystemRegistry.SetGameState(EGameState.Ingame);
            startingNoteActiveState[0].isActive = false;
            startingNoteSyncTool.SyncStartNoteState(startingNoteActiveState[0]);
        }
    }
}

================
File: Systems/GameStateSystem.cs.meta
================
fileFormatVersion: 2
guid: 01ad329a4e8ba17448b524ad53b02f01
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/InputCollisionSystem.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class InputCollisionSystem : IGameSystem
    {
        private const string LOG_PREFIX = "[Input Collision] ";
        private const int MAX_INPUTS = 2;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        private readonly GeneralGameSetting generalGameSetting;
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;

        ArchetypeStorage inputStorage;
        ArchetypeStorage musicNoteStorage;

        InputStateComponent[] inputStates;
        CornerComponent[] musicNoteCorners;
        MusicNoteInteractionComponent[] musicNoteInteractions;
        MusicNoteFillerComponent[] musicNoteFillers;
        MusicNoteComponent[] musicNotes;

        private readonly MusicNoteViewSyncTool musicNoteViewSyncTool;

        public InputCollisionSystem(GlobalPoint globalPoint)
        {
            this.generalGameSetting = globalPoint.generalGameSetting;
            musicNoteViewSyncTool = globalPoint.musicNoteViewSyncTool;
            musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);
            inputStorage = World.GetStorage(Archetype.Registry.Input);

            inputStates = inputStorage.GetComponents<InputStateComponent>();
            musicNoteCorners = musicNoteStorage.GetComponents<CornerComponent>();
            musicNoteInteractions = musicNoteStorage.GetComponents<MusicNoteInteractionComponent>();
            musicNoteFillers = musicNoteStorage.GetComponents<MusicNoteFillerComponent>();
            musicNotes = musicNoteStorage.GetComponents<MusicNoteComponent>();
        }

        public void Update(float deltaTime)
        {
            for (int inputIdx = 0; inputIdx < MAX_INPUTS; inputIdx++)
            {
                if (!inputStates[inputIdx].IsActive)
                    continue;

                for (int noteIdx = 0; noteIdx < musicNoteStorage.Count; noteIdx++)
                {
                    ProcessNoteCollision(
                        inputStates[inputIdx],
                        ref musicNoteCorners[noteIdx],
                        ref musicNoteInteractions[noteIdx],
                        ref musicNoteFillers[noteIdx],
                        musicNotes[noteIdx]
                    );
                }
            }

            musicNoteViewSyncTool.SyncNoteState(
                musicNoteInteractions,
                musicNoteFillers,
                musicNotes
            );
        }

        private void ProcessNoteCollision(
            InputStateComponent input,
            ref CornerComponent corners,
            ref MusicNoteInteractionComponent interaction,
            ref MusicNoteFillerComponent filler,
            MusicNoteComponent note
        )
        {
            // Skip completed notes
            if (interaction.State == MusicNoteInteractiveState.Completed)
                return;

            bool isInsideNote = IsPointInNote(
                input.Position,
                corners.TopLeft,
                corners.TopRight,
                corners.BottomLeft,
                corners.BottomRight
            );

            if (!isInsideNote)
                return;

            ProcessNoteInteraction(input, ref interaction, ref corners, ref filler, note);
        }

        private void ProcessNoteInteraction(
            InputStateComponent input,
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler,
            MusicNoteComponent note
        )
        {
            switch (input.State)
            {
                case InputState.JustPressed:
                    if (interaction.State == MusicNoteInteractiveState.Normal)
                    {
                        if (note.musicNoteType == MusicNoteType.ShortNote)
                        {
                            CompleteNote(ref interaction);
                        }
                        else
                        {
                            StartLongNote(input, ref interaction, ref corners, ref filler);
                        }
                    }
                    break;

                case InputState.Held:
                    if (note.musicNoteType == MusicNoteType.LongNote)
                    {
                        if (interaction.State == MusicNoteInteractiveState.Pressed)
                        {
                            interaction.State = MusicNoteInteractiveState.Hold;
                        }
                        else if (interaction.State == MusicNoteInteractiveState.Hold)
                        {
                            UpdateLongNoteFill(ref interaction, ref corners, ref filler);
                        }
                    }
                    break;

                case InputState.JustReleased:
                    if (
                        note.musicNoteType == MusicNoteType.LongNote
                        && (
                            interaction.State == MusicNoteInteractiveState.Pressed
                            || interaction.State == MusicNoteInteractiveState.Hold
                        )
                    )
                    {
                        CompleteNote(ref interaction);
                    }
                    break;
            }
        }

        private void CompleteNote(ref MusicNoteInteractionComponent interaction)
        {
            interaction.State = MusicNoteInteractiveState.Completed;
            Debug.Log($"{LOG_PREFIX} Note completed");
        }

        private void StartLongNote(
            InputStateComponent input,
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler
        )
        {
            interaction.State = MusicNoteInteractiveState.Pressed;
            filler.IsVisible = true;

            float sizeOfNote = corners.TopLeft.y - corners.BottomLeft.y;
            float fromTouchPositionToLowerOfNote = input.Position.y - corners.BottomLeft.y;
            float touchPercent = fromTouchPositionToLowerOfNote / sizeOfNote;
            filler.FillPercent = touchPercent + 0.1f;

            Debug.Log($"{LOG_PREFIX} Long note pressed");
        }

        private void UpdateLongNoteFill(
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler
        )
        {
            float gameSpeed = generalGameSetting.GameSpeed;
            if (musicNoteCreationSetting.UsePreciseNoteCalculation)
            {
                gameSpeed = generalGameSetting.PreciseGameSpeed;
            }
            float noteLength = corners.TopLeft.y - corners.BottomLeft.y;
            float fillSpeed = gameSpeed / noteLength;

            float nextFillPercent = filler.FillPercent + (fillSpeed * Time.deltaTime);
            nextFillPercent = Mathf.Min(nextFillPercent, 1f);

            filler.FillPercent = nextFillPercent;

            if (nextFillPercent >= 1f)
            {
                CompleteNote(ref interaction);
            }
        }

        private static bool IsPointInNote(
            Vector2 point,
            Vector2 topLeft,
            Vector2 topRight,
            Vector2 bottomLeft,
            Vector2 bottomRight
        )
        {
            int wn = 0; // Winding number

            Vector2[] vertices = { topLeft, topRight, bottomRight, bottomLeft };

            for (int i = 0; i < vertices.Length; i++)
            {
                Vector2 current = vertices[i];
                Vector2 next = vertices[(i + 1) % vertices.Length];

                if (current.y <= point.y)
                {
                    if (next.y > point.y && IsLeftOf(current, next, point) > 0)
                        wn++;
                }
                else
                {
                    if (next.y <= point.y && IsLeftOf(current, next, point) < 0)
                        wn--;
                }
            }

            return wn != 0;
        }

        private static float IsLeftOf(Vector2 a, Vector2 b, Vector2 point)
        {
            return (b.x - a.x) * (point.y - a.y) - (point.x - a.x) * (b.y - a.y);
        }

        public void Cleanup() { }
    }
}

================
File: Systems/InputCollisionSystem.cs.meta
================
fileFormatVersion: 2
guid: a0d38e0610e6340709395f4e4d69e409
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/InputSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class InputSystem : IGameSystem
    {
        private const int MAX_INPUTS = 2;
        private const string LOG_PREFIX = "[Input System] ";
        private bool wasMousePressed;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            // Create input entities
            for (int i = 0; i < MAX_INPUTS; i++)
            {
                var inputComponent = new InputStateComponent
                {
                    IsActive = false,
                    Position = Vector2.zero,
                    PreviousPosition = Vector2.zero,
                    State = InputState.None,
                    FrameCount = 0,
                };

                World.CreateEntityWithComponents(
                    Archetype.Registry.Input,
                    new object[] { inputComponent }
                );
            }
        }

        public void Update(float deltaTime)
        {
            ArchetypeStorage inputStorage = World.GetStorage(Archetype.Registry.Input);
            var inputStates = inputStorage.GetComponents<InputStateComponent>();

            // Update previous states
            UpdatePreviousStates(inputStates);

            // Process new input
            if (Input.touchCount > 0)
            {
                ProcessTouchInput(inputStates);
            }
            else
            {
                ProcessMouseInput(inputStates);
            }
        }

        private void UpdatePreviousStates(InputStateComponent[] inputStates)
        {
            for (int i = 0; i < MAX_INPUTS; i++)
            {
                if (inputStates[i].State == InputState.JustReleased)
                {
                    inputStates[i].State = InputState.None;
                    inputStates[i].FrameCount = 0;
                    inputStates[i].IsActive = false;
                }
                else if (inputStates[i].State == InputState.JustPressed)
                {
                    inputStates[i].State = InputState.Held;
                }
            }
        }

        private void ProcessMouseInput(InputStateComponent[] inputStates)
        {
            bool isCurrentlyPressed = Input.GetMouseButton(0);
            Vector2 worldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);

            ref var currentState = ref inputStates[0];
            InputState newState = DetermineNewInputState(isCurrentlyPressed, wasMousePressed);

            // Only update if state changed or position changed
            if (newState != currentState.State || worldPos != currentState.Position)
            {
                UpdateInputState(ref currentState, worldPos, newState);
            }

            wasMousePressed = isCurrentlyPressed;
        }

        private void ProcessTouchInput(InputStateComponent[] inputStates)
        {
            int touchCount = Mathf.Min(Input.touchCount, MAX_INPUTS);

            // Reset unused input slots
            for (int i = touchCount; i < MAX_INPUTS; i++)
            {
                if (inputStates[i].IsActive)
                {
                    inputStates[i].State = InputState.None;
                    inputStates[i].IsActive = false;
                }
            }

            // Process active touches
            for (int i = 0; i < touchCount; i++)
            {
                Touch touch = Input.GetTouch(i);
                Vector2 worldPos = Camera.main.ScreenToWorldPoint(touch.position);

                InputState newState = touch.phase switch
                {
                    TouchPhase.Began => InputState.JustPressed,
                    TouchPhase.Moved => InputState.Held,
                    TouchPhase.Stationary => InputState.Held,
                    TouchPhase.Ended => InputState.JustReleased,
                    TouchPhase.Canceled => InputState.JustReleased,
                    _ => InputState.None,
                };

                UpdateInputState(ref inputStates[i], worldPos, newState);
            }
        }

        private void UpdateInputState(
            ref InputStateComponent state,
            Vector2 position,
            InputState newState
        )
        {
            state.PreviousPosition = state.Position;
            state.Position = position;
            state.State = newState;
            state.IsActive = newState != InputState.None;

            if (newState != state.State)
            {
                state.FrameCount = 0;
            }
            state.FrameCount++;
        }

        private InputState DetermineNewInputState(bool isPressed, bool wasPressed)
        {
            if (isPressed && !wasPressed)
                return InputState.JustPressed;
            if (!isPressed && wasPressed)
                return InputState.JustReleased;
            if (isPressed)
                return InputState.Held;
            return InputState.None;
        }

        public void Cleanup()
        {
            // Nothing to cleanup for now
        }
    }
}

================
File: Systems/InputSystem.cs.meta
================
fileFormatVersion: 2
guid: 3a7c2b94a0f5a416c8d8401ea289c387
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/LaneLineSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using Unity.VisualScripting;
using UnityEngine;

namespace ECS_MagicTile
{
    public class LaneLineSystem : IGameSystem
    {
        public LaneLineSystem(GlobalPoint globalPoint)
        {
            onOrientationChangedChannel = globalPoint.OnOrientationChangedChannel;
            laneLineSyncTool = globalPoint.laneLineSyncTool;
            laneLineSettings = globalPoint.laneLineSettings;
            targetCamera = globalPoint.mainCamera;
        }

        public bool IsEnabled { get; set; }
        public World World { get; set; }

        private BoolEventChannel onOrientationChangedChannel;
        private Camera targetCamera;

        public EGameState GameStateToExecute => EGameState.WaitingToStart;

        ArchetypeStorage perfectLineStorage;
        CornerComponent[] perfectLineCorners;

        ArchetypeStorage laneLineStorage;
        TransformComponent[] laneLineTransforms;

        private LaneLineSyncTool laneLineSyncTool;
        private LaneLineSettings laneLineSettings;

        public void Cleanup() { }

        public void Initialize()
        {
            CreateLaneLines();
            laneLineSyncTool.InitializeTool();
            perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);
            laneLineStorage = World.GetStorage(Archetype.Registry.LaneLines);

            laneLineTransforms = laneLineStorage.GetComponents<TransformComponent>();
            perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>();

            AdjustLaneLines();

            onOrientationChangedChannel.Subscribe(OnOrientationChanged);

            laneLineSettings.laneLineWidth.Subscribe(OnLaneLineSettingsAdjustInInpector);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime) { }

        private void CreateLaneLines()
        {
            for (int i = 0; i < 5; i++)
            {
                var LaneLinesComponents = new object[] { new TransformComponent() };
                World.CreateEntityWithComponents(Archetype.Registry.LaneLines, LaneLinesComponents);
            }
        }

        private void OnOrientationChanged(bool isPortrait)
        {
            AdjustLaneLines();
        }

        private void OnLaneLineSettingsAdjustInInpector(float value)
        {
            AdjustLaneLines();
        }

        private void AdjustLaneLines()
        {
            ref CornerComponent perfectLineCorner = ref perfectLineCorners[0];

            // Calculate lane width once
            float totalWidth = perfectLineCorner.TopRight.x - perfectLineCorner.TopLeft.x;
            float laneWidth = totalWidth / 4;

            for (int i = 0; i < laneLineStorage.Count; i++)
            {
                float spawnX = i * laneWidth + perfectLineCorner.TopLeft.x;
                float spawnY = CameraViewUtils.GetPositionYInCameraView(targetCamera, .5f);

                laneLineTransforms[i].Position = new Vector3(spawnX, spawnY, 0);
                laneLineTransforms[i].Size = SpriteUtility.ResizeInCameraView(
                    laneLineSyncTool.LaneLineSprites[i],
                    targetCamera,
                    laneLineSettings.laneLineWidth.Value,
                    1,
                    false
                );
            }

            laneLineSyncTool.SyncLaneLineTransform(laneLineTransforms);
        }
    }
}

================
File: Systems/LaneLineSystem.cs.meta
================
fileFormatVersion: 2
guid: 36b27db23e135449bb2d06e40f049e10
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/MovingNoteSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MovingNoteSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        private readonly GeneralGameSetting generalGameSetting;
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;

        ArchetypeStorage musicNoteStorage;

        TransformComponent[] musicNoteTransforms;
        CornerComponent[] musicNoteCornsers;
        MusicNoteComponent[] musicNoteComponents;

        private readonly MusicNoteViewSyncTool musicNoteViewSyncTool;

        public MovingNoteSystem(GlobalPoint globalPoint)
        {
            this.generalGameSetting = globalPoint.generalGameSetting;
            this.musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
            musicNoteViewSyncTool = globalPoint.musicNoteViewSyncTool;
        }

        public void Cleanup() { }

        public void Initialize()
        {
            musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            musicNoteTransforms = musicNoteStorage.GetComponents<TransformComponent>();
            musicNoteCornsers = musicNoteStorage.GetComponents<CornerComponent>();
            musicNoteComponents = musicNoteStorage.GetComponents<MusicNoteComponent>();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            float gameSpeed;

            if (musicNoteCreationSetting.UsePreciseNoteCalculation)
            {
                gameSpeed = generalGameSetting.PreciseGameSpeed;
            }
            else
            {
                gameSpeed = generalGameSetting.GameSpeed;
            }

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                if (
                    musicNoteComponents[i].musicNotePositionState
                    == MusicNotePositionState.OutOfScreen
                )
                {
                    continue;
                }

                // Update position
                Vector2 newPos = musicNoteTransforms[i].Position;
                newPos.y -= gameSpeed * Time.deltaTime;
                musicNoteTransforms[i].Position = newPos;

                // Update corners based on new position and size
                Vector2 halfSize = musicNoteTransforms[i].Size * 0.5f;
                musicNoteCornsers[i].TopLeft = new Vector2(
                    newPos.x - halfSize.x,
                    newPos.y + halfSize.y
                );
                musicNoteCornsers[i].TopRight = new Vector2(
                    newPos.x + halfSize.x,
                    newPos.y + halfSize.y
                );
                musicNoteCornsers[i].BottomLeft = new Vector2(
                    newPos.x - halfSize.x,
                    newPos.y - halfSize.y
                );
                musicNoteCornsers[i].BottomRight = new Vector2(
                    newPos.x + halfSize.x,
                    newPos.y - halfSize.y
                );

                if (
                    CameraViewUtils.IsPositionOutOfBounds(
                        Camera.main,
                        musicNoteCornsers[i].TopLeft,
                        CameraViewUtils.CameraBoundCheck.Bottom
                    )
                )
                {
                    musicNoteComponents[i].musicNotePositionState =
                        MusicNotePositionState.OutOfScreen;
                }
            }

            musicNoteViewSyncTool.SyncNoteTransforms(musicNoteTransforms, musicNoteComponents);

            //SystemRegistry.SetGameState(EGameState.Outro);
        }
    }
}

================
File: Systems/MovingNoteSystem.cs.meta
================
fileFormatVersion: 2
guid: 23e31434417084f63bbc9efc34471f1f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/MusicNoteCreationSystem.cs
================
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteCreationSystem : IGameSystem
    {
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;
        private readonly GeneralGameSetting generalGameSetting;
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.WaitingToStart;

        MusicNoteMidiData musicNoteMidiData;

        ArchetypeStorage perfectLineStorage;
        PerfectLineTagComponent[] perfectLineTag;
        CornerComponent[] perfectLineCorners;

        ArchetypeStorage musicNoteStorage;
        TransformComponent[] musicNoteTransforms;
        MusicNoteComponent[] musicNotes;

        ArchetypeStorage worldStateStorage;
        WorldStateComponent[] worldStates;

        Camera targetCamera;

        float lastPerfectLineTopLeftY;
        float lastPerfectLineTopLeftX;

        public MusicNoteCreationSystem(GlobalPoint globalPoint)
        {
            this.musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
            this.generalGameSetting = globalPoint.generalGameSetting;
            targetCamera = globalPoint.mainCamera;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            musicNoteMidiData = MidiNoteParser.ParseFromText(
                musicNoteCreationSetting.MidiContent.text
            );

            perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);
            perfectLineTag = perfectLineStorage.GetComponents<PerfectLineTagComponent>();
            perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>();

            worldStateStorage = World.GetStorage(Archetype.Registry.WorldState);
            worldStates = worldStateStorage.GetComponents<WorldStateComponent>();

            var noteCount = musicNoteMidiData.TotalNotes;
            var durations = musicNoteMidiData.Durations;
            var positionIds = musicNoteMidiData.PositionIds;
            var timeAppears = musicNoteMidiData.TimeAppears;
            var minDuration = musicNoteMidiData.MinDuration;

            var componentsList = new List<object[]>(noteCount);

            for (int i = 0; i < noteCount; i++)
            {
                var musicNoteType =
                    durations[i] > minDuration ? MusicNoteType.LongNote : MusicNoteType.ShortNote;

                componentsList.Add(
                    new object[]
                    {
                        new TransformComponent(),
                        new MusicNoteComponent
                        {
                            Duration = durations[i],
                            PostionId = positionIds[i],
                            TimeAppear = timeAppears[i],
                            musicNoteType = musicNoteType,
                            musicNotePositionState = MusicNotePositionState.AbovePerfectLine,
                        },
                        new CornerComponent(),
                        new MusicNoteInteractionComponent(),
                        new MusicNoteFillerComponent(),
                        new ScoreStateComponent { HasBeenScored = false },
                    }
                );
            }

            foreach (var components in componentsList)
            {
                World.CreateEntityWithComponents(Archetype.Registry.MusicNote, components);
            }

            musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            musicNoteTransforms = musicNoteStorage.GetComponents<TransformComponent>();
            musicNotes = musicNoteStorage.GetComponents<MusicNoteComponent>();
        }

        public void Update(float deltaTime)
        {
            if (
                lastPerfectLineTopLeftY != perfectLineCorners[0].TopLeft.y
                || lastPerfectLineTopLeftX != perfectLineCorners[0].TopLeft.x
            )
            {
                lastPerfectLineTopLeftY = perfectLineCorners[0].TopLeft.y;
                lastPerfectLineTopLeftX = perfectLineCorners[0].TopLeft.x;

                if (musicNoteCreationSetting.UsePreciseNoteCalculation)
                {
                    CalculateMusicNoteDataPrecisely();
                }
                else
                {
                    CalculateMusicNoteData();
                }
            }
        }

        public void Cleanup()
        {
            //
        }

        private void CalculateMusicNoteData()
        {
            ref CornerComponent perfectLineCorner = ref perfectLineCorners[0];

            // Calculate lane width and half lane width
            float totalWidth = perfectLineCorner.TopRight.x - perfectLineCorner.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            // Calculate Short and Long Note scale factors
            float shortNoteScaleYFactor = MagicTileHelper.CalculateScaleY(
                musicNoteCreationSetting.ShortNoteScaleYFactor,
                perfectLineTag[0].PerfectLineWidth / 4
            );
            float longNoteScaleYFactor = MagicTileHelper.CalculateScaleY(
                musicNoteCreationSetting.LongNoteScaleYFactor,
                perfectLineTag[0].PerfectLineWidth / 4
            );

            // Set all music note positions and sizes
            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                float spawnX =
                    perfectLineCorner.TopLeft.x
                    + (musicNoteMidiData.PositionIds[i] * laneWidth)
                    + halfLaneWidth;

                float spawnY =
                    perfectLineCorner.TopLeft.y
                    + (musicNoteMidiData.TimeAppears[i] * generalGameSetting.GameSpeed)
                    + (
                        musicNotes[i].musicNoteType == MusicNoteType.ShortNote
                            ? shortNoteScaleYFactor
                            : longNoteScaleYFactor
                    );

                musicNoteTransforms[i].Position = new Vector2(spawnX, spawnY);

                musicNoteTransforms[i].Size = new Vector2(
                    perfectLineTag[0].PerfectLineWidth / 4,
                    musicNotes[i].musicNoteType == MusicNoteType.ShortNote
                        ? shortNoteScaleYFactor
                        : longNoteScaleYFactor
                );
            }
        }

        private void CalculateMusicNoteDataPrecisely()
        {
            float[] noteSizes = PreciseNoteCalculator.CalculateNoteSizes(
                musicNoteMidiData,
                musicNoteCreationSetting.ShortNoteScaleYFactor
            );
            float[] positions = PreciseNoteCalculator.CalculateInitialPositions(
                musicNoteMidiData,
                perfectLineCorners[0].TopLeft.y,
                noteSizes,
                musicNoteCreationSetting.ShortNoteScaleYFactor
            );

            worldStates[0].FirstNotePositionToTriggerSong = positions[0];

            ref CornerComponent perfectLineCorner = ref perfectLineCorners[0];

            float totalWidth = perfectLineCorner.TopRight.x - perfectLineCorner.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            float cameraBoundYOffset = CameraViewUtils.GetPositionYInCameraView(targetCamera, 1);

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                float spawnX =
                    perfectLineCorner.TopLeft.x
                    + (musicNoteMidiData.PositionIds[i] * laneWidth)
                    + halfLaneWidth;

                musicNoteTransforms[i].Position = new Vector2(
                    spawnX,
                    positions[i] + (cameraBoundYOffset - perfectLineCorner.TopLeft.y)
                );
                musicNoteTransforms[i].Size = new Vector2(
                    perfectLineTag[0].PerfectLineWidth / 4,
                    noteSizes[i]
                );
            }

            float totalTime = PreciseNoteCalculator.CalculateTotalSongDuration(musicNoteMidiData);
            float roadLength = PreciseNoteCalculator.CalculateRoadLength(
                noteSizes,
                musicNoteMidiData
            );

            generalGameSetting.PreciseGameSpeed = PreciseNoteCalculator.CalculateRequiredVelocity(
                totalTime,
                roadLength
            );
        }
    }
}

================
File: Systems/MusicNoteCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: 27223b00486847b4b86f21b0b74f2e53
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/PerfectLineSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class PerfectLineSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        //Storage and Data arrays
        ArchetypeStorage perfectLineStorage;
        PerfectLineTagComponent[] perfectLineTagComponents;
        CornerComponent[] perfectLineCorners;
        TransformComponent[] perfectLineTransforms;

        //SO settings
        PerfectLineSetting perfectLineSetting;

        //Event Channels
        private BoolEventChannel OnOrientationChangedChannel;

        //Game object refs
        SpriteRenderer perfectLineSprite;
        Camera mainCamera;

        SpriteUtility.SpriteCorners perfectLineCornersInCamSpace;

        private PerfectLineSyncTool perfectLineSyncTool;

        public PerfectLineSystem(GlobalPoint globalPoint)
        {
            perfectLineSprite = globalPoint.perfectLineObject.GetComponent<SpriteRenderer>();
            perfectLineSetting = globalPoint.perfectLineSetting;
            mainCamera = globalPoint.mainCamera;
            OnOrientationChangedChannel = globalPoint.OnOrientationChangedChannel;

            perfectLineSyncTool = globalPoint.perfectLineSyncTool;
        }

        public EGameState GameStateToExecute => EGameState.All;

        public void Initialize()
        {
            perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            perfectLineTagComponents = perfectLineStorage.GetComponents<PerfectLineTagComponent>();
            perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>();
            perfectLineTransforms = perfectLineStorage.GetComponents<TransformComponent>();

            //
            perfectLineSetting.portraitNormalizedPos.normalizedX.Subscribe(UpdatePerfectLinePos);
            perfectLineSetting.portraitNormalizedPos.normalizedY.Subscribe(UpdatePerfectLinePos);

            //
            perfectLineSetting.landscapeNormalizedPos.normalizedX.Subscribe(UpdatePerfectLinePos);
            perfectLineSetting.landscapeNormalizedPos.normalizedY.Subscribe(UpdatePerfectLinePos);

            //
            perfectLineSetting.portraitNormalizedSize.normalizedX.Subscribe(
                UpdatePerfectLineSizeData
            );
            perfectLineSetting.portraitNormalizedSize.normalizedY.Subscribe(
                UpdatePerfectLineSizeData
            );

            //
            perfectLineSetting.landscapeNormalizedSize.normalizedX.Subscribe(
                UpdatePerfectLineSizeData
            );
            perfectLineSetting.landscapeNormalizedSize.normalizedY.Subscribe(
                UpdatePerfectLineSizeData
            );

            OnOrientationChangedChannel.Subscribe(OnOrientationChanged);
        }

        public void Cleanup() { }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime) { }

        private void UpdatePerfectLinePos(float value)
        {
            if (ScreenManager.Instance.IsPortrait)
            {
                perfectLineTransforms[0].Position = CameraViewUtils.GetPositionInCameraView(
                    mainCamera,
                    perfectLineSetting.portraitNormalizedPos.normalizedX.Value,
                    perfectLineSetting.portraitNormalizedPos.normalizedY.Value
                );
            }
            else
            {
                perfectLineTransforms[0].Position = CameraViewUtils.GetPositionInCameraView(
                    mainCamera,
                    perfectLineSetting.landscapeNormalizedPos.normalizedX.Value,
                    perfectLineSetting.landscapeNormalizedPos.normalizedY.Value
                );
            }

            perfectLineSyncTool.SyncPerfectLineTransform(perfectLineTransforms[0]);

            UpdatePerfectLineCornersData();
        }

        private void UpdatePerfectLineSizeData(float value)
        {
            if (ScreenManager.Instance.IsPortrait)
            {
                perfectLineTransforms[0].Size = SpriteUtility.ResizeInCameraView(
                    perfectLineSprite,
                    mainCamera,
                    perfectLineSetting.portraitNormalizedSize.normalizedX.Value,
                    perfectLineSetting.portraitNormalizedSize.normalizedY.Value,
                    false
                );
            }
            else
            {
                perfectLineTransforms[0].Size = SpriteUtility.ResizeInCameraView(
                    perfectLineSprite,
                    mainCamera,
                    perfectLineSetting.landscapeNormalizedSize.normalizedX.Value,
                    perfectLineSetting.landscapeNormalizedSize.normalizedY.Value,
                    false
                );
            }

            perfectLineSyncTool.SyncPerfectLineTransform(perfectLineTransforms[0]);

            UpdatePerfectLineCornersData();
        }

        private void UpdatePerfectLineCornersData()
        {
            perfectLineCornersInCamSpace = SpriteUtility.GetSpriteCorners(perfectLineSprite);

            perfectLineCorners[0].TopLeft = perfectLineCornersInCamSpace.TopLeft;
            perfectLineCorners[0].TopRight = perfectLineCornersInCamSpace.TopRight;
            perfectLineCorners[0].BottomLeft = perfectLineCornersInCamSpace.BottomLeft;
            perfectLineCorners[0].BottomRight = perfectLineCornersInCamSpace.BottomRight;

            perfectLineTagComponents[0].PerfectLineWidth = Mathf.Abs(
                perfectLineCornersInCamSpace.TopLeft.x - perfectLineCornersInCamSpace.TopRight.x
            );
        }

        private void OnOrientationChanged(bool isPortrait)
        {
            if (isPortrait)
            {
                UpdatePerfectLinePos(0f);
            }
            else
            {
                UpdatePerfectLinePos(0f);
            }
            UpdatePerfectLineSizeData(0f);
        }
    }
}

================
File: Systems/PerfectLineSystem.cs.meta
================
fileFormatVersion: 2
guid: 1b10a060d587046339f5da333963b154
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/ProgressSystem.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ProgressSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        private BoolEventChannel scoreEventChannel;

        private ProgressSyncTool progressSyncTool;

        public ProgressSystem(GlobalPoint globalPoint)
        {
            this.scoreEventChannel = globalPoint.OnScoreHitChannel;
            progressSyncTool = globalPoint.progressSyncTool;
        }

        private ArchetypeStorage progressArchetype;

        public void Cleanup() { }

        public void Initialize()
        {
            progressArchetype = World.GetStorage(Archetype.Registry.SongProgress);

            scoreEventChannel.Subscribe(OnScoreEvent);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime) { }

        private void OnScoreEvent(bool isScore)
        {
            ref ProgressComponent progress =
                ref progressArchetype.GetComponents<ProgressComponent>()[0];
            progress.CurrentProgressRawValue++;
            progress.currentProgressPercent =
                progress.CurrentProgressRawValue / progress.MaxProgressRawValue;

            Debug.Log($"Current Progress: {progress.currentProgressPercent}");

            progressSyncTool.SycnProgress(progress);
        }
    }
}

================
File: Systems/ProgressSystem.cs.meta
================
fileFormatVersion: 2
guid: 48ac64d4224f142299e7f0d4888feaf5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/ScoringSystem.cs
================
using System;
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ScoringSystem : IGameSystem
    {
        private const int PERFECT_SCORE = 100;
        private const int GREAT_SCORE = 50;

        // How close to perfect line needed for perfect score (in units)
        private const float PERFECT_THRESHOLD = 0.1f;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        ArchetypeStorage noteStorage;
        ArchetypeStorage gameScoreStorage;
        ArchetypeStorage perfectLineStorage;

        MusicNoteInteractionComponent[] musicNoteInteractionComponents;
        TransformComponent[] musicNoteTransformComponents;
        ScoreStateComponent[] musicScoreStateComponents;
        MusicNoteComponent[] musicNoteComponents;

        BoolEventChannel scoreSignalEffectChannel;

        private GameScoreSyncTool gameScoreSyncTool;

        public ScoringSystem(GlobalPoint globalPoint)
        {
            this.scoreSignalEffectChannel = globalPoint.OnScoreHitChannel;
            this.gameScoreSyncTool = globalPoint.gameScoreSyncTool;
        }

        public void Cleanup()
        {
            //
        }

        public void Initialize()
        {
            noteStorage = World.GetStorage(Archetype.Registry.MusicNote);
            gameScoreStorage = World.GetStorage(Archetype.Registry.GameScore);
            perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            musicNoteComponents = noteStorage.GetComponents<MusicNoteComponent>();
            musicNoteInteractionComponents =
                noteStorage.GetComponents<MusicNoteInteractionComponent>();
            musicNoteTransformComponents = noteStorage.GetComponents<TransformComponent>();
            musicScoreStateComponents = noteStorage.GetComponents<ScoreStateComponent>();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            var perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>()[0];
            ref var gameScore = ref gameScoreStorage.GetComponents<ScoreComponent>()[0];

            //process note
            for (int i = 0; i < noteStorage.Count; i++)
            {
                // Only process notes that were just hit and haven't been scored
                if (musicScoreStateComponents[i].HasBeenScored)
                {
                    continue;
                }

                if (musicNoteComponents[i].musicNoteType == MusicNoteType.LongNote)
                {
                    if (
                        musicNoteInteractionComponents[i].State == MusicNoteInteractiveState.Pressed
                    )
                    {
                        ProcessNoteScore(
                            musicNoteTransformComponents[i],
                            perfectLineCorners,
                            ref gameScore,
                            ref musicScoreStateComponents[i]
                        );
                    }
                }
                else
                {
                    if (
                        musicNoteInteractionComponents[i].State == MusicNoteInteractiveState.Pressed
                        || musicNoteInteractionComponents[i].State
                            == MusicNoteInteractiveState.Completed
                    )
                    {
                        ProcessNoteScore(
                            musicNoteTransformComponents[i],
                            perfectLineCorners,
                            ref gameScore,
                            ref musicScoreStateComponents[i]
                        );
                    }
                }
            }
        }

        private void ProcessNoteScore(
            TransformComponent musicTransform,
            CornerComponent perfectLineCorners,
            ref ScoreComponent gameScore,
            ref ScoreStateComponent scoreStateComponent
        )
        {
            float distanceFromPerfect = Mathf.Abs(
                musicTransform.Position.y - perfectLineCorners.TopLeft.y
            );

            int scoreToAdd;

            if (distanceFromPerfect <= PERFECT_THRESHOLD)
            {
                scoreToAdd = PERFECT_SCORE;
                scoreSignalEffectChannel.RaiseEvent(true);
            }
            else
            {
                scoreToAdd = GREAT_SCORE;
                scoreSignalEffectChannel.RaiseEvent(false);
            }

            gameScore.TotalScore += scoreToAdd;
            scoreStateComponent.HasBeenScored = true;

            gameScoreSyncTool.SyncGameScore(gameScore);
        }
    }
}

================
File: Systems/ScoringSystem.cs.meta
================
fileFormatVersion: 2
guid: 8fca9e9bcd6671c42bc6b410aa575c9e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/SingletonCreationSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class SingletonCreationSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.WaitingToStart;

        private readonly MusicNoteCreationSetting musicNoteCreationSetting;
        private readonly PerfectLineSetting perfectLineSetting;

        private ArchetypeStorage perfectLineStorage;

        private SpriteRenderer perfectLineSprite;

        public SingletonCreationSystem(GlobalPoint globalPoint)
        {
            musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
            perfectLineSetting = globalPoint.perfectLineSetting;

            perfectLineSprite = globalPoint.perfectLineObject.GetComponent<SpriteRenderer>();
        }

        public void Cleanup()
        {
            //
        }

        public void Initialize()
        {
            CreatePerfectLine();
            CreateStartingNote();
            CreateGameScore();
            CreateProgress();
            CreateWorldStateComponent();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            //
        }

        private void CreatePerfectLine()
        {
            //The perfect line singleton
            var components = new object[]
            {
                new TransformComponent(),
                new PerfectLineTagComponent(),
                new CornerComponent(),
            };
            World.CreateEntityWithComponents(Archetype.Registry.PerfectLine, components);
        }

        private void CreateStartingNote()
        {
            var components = new object[]
            {
                new TransformComponent(),
                new ActiveStateComponent(),
                new StartingNoteTagComponent(),
            };
            World.CreateEntityWithComponents(Archetype.Registry.StartingNote, components);
        }

        private void CreateGameScore()
        {
            var components = new object[] { new ScoreComponent { TotalScore = 0 } };
            World.CreateEntityWithComponents(Archetype.Registry.GameScore, components);
        }

        private void CreateProgress()
        {
            MusicNoteMidiData musicNoteMidiData = MidiNoteParser.ParseFromText(
                musicNoteCreationSetting.MidiContent.text
            );
            var components = new object[]
            {
                new ProgressComponent
                {
                    CurrentProgressRawValue = 0,
                    currentProgressPercent = 0,
                    MaxProgressRawValue = musicNoteMidiData.TotalNotes,
                },
            };
            World.CreateEntityWithComponents(Archetype.Registry.SongProgress, components);
        }

        private void CreateWorldStateComponent()
        {
            var components = new object[] { new WorldStateComponent() };
            World.CreateEntityWithComponents(Archetype.Registry.WorldState, components);
        }
    }
}

================
File: Systems/SingletonCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: 0363a30a155e7de4492faa5045403325
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/StartingNoteSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class StartingNoteSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.All;

        private readonly MusicNoteCreationSetting musicNoteCreationSetting;

        private readonly StartingNoteSyncTool startingNoteSyncTool;

        private ArchetypeStorage startingNoteStorage;
        private ArchetypeStorage perfectLineStorage;

        private TransformComponent[] startingNoteTransforms;
        private CornerComponent[] perfectLineCorners;

        float lastPerfectLineTopLeftY;
        float lastPerfectLineTopLeftX;

        public StartingNoteSystem(GlobalPoint globalPoint)
        {
            musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
            startingNoteSyncTool = globalPoint.startingNoteSyncTool;
        }

        public void Cleanup() { }

        public void Initialize()
        {
            startingNoteSyncTool.InitializeTool();

            startingNoteStorage ??= World.GetStorage(Archetype.Registry.StartingNote);
            perfectLineStorage ??= World.GetStorage(Archetype.Registry.PerfectLine);

            perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>();
            startingNoteTransforms = startingNoteStorage.GetComponents<TransformComponent>();

            ref ActiveStateComponent activeState =
                ref startingNoteStorage.GetComponents<ActiveStateComponent>()[0];
            activeState.isActive = true;

            SetupStartingNote();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            if (
                lastPerfectLineTopLeftY != perfectLineCorners[0].TopLeft.y
                || lastPerfectLineTopLeftX != perfectLineCorners[0].TopLeft.x
            )
            {
                lastPerfectLineTopLeftY = perfectLineCorners[0].TopLeft.y;
                lastPerfectLineTopLeftX = perfectLineCorners[0].TopLeft.x;
                SetupStartingNote();
            }

            //Debug.Log($"PerfectLine Topleft: {perfectLineCorners[0].TopLeft.x}");
        }

        private void SetupStartingNote()
        {
            ref TransformComponent transform = ref startingNoteTransforms[0];

            ref CornerComponent perfectLineCorner = ref perfectLineCorners[0];

            // Calculate lane width
            float totalWidth = perfectLineCorner.TopRight.x - perfectLineCorner.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            // Calculate spawn position
            float spawnX = perfectLineCorner.TopLeft.x + (0 * laneWidth) + halfLaneWidth;
            float spawnY = perfectLineCorner.TopLeft.y;

            transform.Position = new Vector2(spawnX, spawnY);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            float scaleX = PerfectLine.PerfectLineWidth / 4;

            float scaleY = MagicTileHelper.CalculateScaleY(
                musicNoteCreationSetting.ShortNoteScaleYFactor,
                scaleX
            );

            transform.Size = new Vector2(scaleX, scaleY);

            startingNoteSyncTool.SyncStartNoteTransform(transform);
        }
    }
}

================
File: Systems/StartingNoteSystem.cs.meta
================
fileFormatVersion: 2
guid: bd30870514eee4c529701bd1bedca700
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/TraceNoteToTriggerSongSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class TraceNoteToTriggerSongSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        ArchetypeStorage musicnNoteStorage;
        TransformComponent[] musicNoteTransforms;

        ArchetypeStorage worldStateStorage;
        WorldStateComponent[] worldStateComponents;

        EmptyEventChannel OnSongStartChannel;

        public TraceNoteToTriggerSongSystem(GlobalPoint globalPoint)
        {
            OnSongStartChannel = globalPoint.OnSongStartChannel;
        }

        public void Cleanup() { }

        public void Initialize()
        {
            worldStateStorage = World.GetStorage(Archetype.Registry.WorldState);
            worldStateComponents = worldStateStorage.GetComponents<WorldStateComponent>();

            musicnNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);
            musicNoteTransforms = musicnNoteStorage.GetComponents<TransformComponent>();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            if (
                musicNoteTransforms[0].Position.y
                <= worldStateComponents[0].FirstNotePositionToTriggerSong
            )
            {
                OnSongStartChannel.RaiseEvent(new EmptyData());
                IsEnabled = false;
            }
        }
    }
}

================
File: Systems/TraceNoteToTriggerSongSystem.cs.meta
================
fileFormatVersion: 2
guid: 93c4845eb14e3064ea19d934433b14f2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Core.meta
================
fileFormatVersion: 2
guid: b57c2d5fbb39b489e9c51a111e5e8e4f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponents.meta
================
fileFormatVersion: 2
guid: 401cb534838cf40049f69183b5206b9c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DTO.meta
================
fileFormatVersion: 2
guid: c3e7f3ef03f524e6089d969eb175e299
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EGameState.cs
================
namespace ECS_MagicTile
{
    public enum EGameState
    {
        WaitingToStart,
        Ingame,
        Outro,
        All,
    }
}

================
File: EGameState.cs.meta
================
fileFormatVersion: 2
guid: ea96b7999d1692748b0c374877fef0d4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannels.meta
================
fileFormatVersion: 2
guid: a808c7b858a7cf1459c4ba6cf1d5efe8
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Functions.meta
================
fileFormatVersion: 2
guid: 640c8ae1ec4198a4e9afbf063ad8727d
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoScripts.meta
================
fileFormatVersion: 2
guid: eca84261f4209ea438546467839df383
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings.meta
================
fileFormatVersion: 2
guid: 27da12294979945e1b5cbf9800389eb4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Syncers.meta
================
fileFormatVersion: 2
guid: 200d0ba3dc7c04ac6920253abe6c74a4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems.meta
================
fileFormatVersion: 2
guid: c822eec9dba9f4d4b88020ce8c3090ef
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/repomix-output.txt.meta
================
fileFormatVersion: 2
guid: b12cb1c54834d1b499c32c541d65e977
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings.meta
================
fileFormatVersion: 2
guid: 27da12294979945e1b5cbf9800389eb4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/GeneralGameSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 24a2a689475a5aa4997e54b10cc3c33c, type: 3}
  m_Name: GeneralGameSetting_SO
  m_EditorClassIdentifier: 
  GameSpeed: 0

================
File: ECS_Principled/Settings/GeneralGameSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: cc747aeaca6f5864099880016a577e56
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/LaneLineSettings_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: bfcaf33992d1246beafffa977f1b7a56, type: 3}
  m_Name: LaneLineSettings_SO
  m_EditorClassIdentifier: 
  landLinePrefab: {fileID: 856688113385644598, guid: af74a368381e1114095acf0acae2ec78, type: 3}
  laneLineWidth:
    _value: 0.004

================
File: ECS_Principled/Settings/LaneLineSettings_SO.asset.meta
================
fileFormatVersion: 2
guid: 6a5958e8da5e84e76b82907765c02fbe
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/MusicNoteCreationSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a5af8e59dd796d941989a811a2c8754b, type: 3}
  m_Name: MusicNoteCreationSetting_SO
  m_EditorClassIdentifier: 
  UsePreciseNoteCalculation: 1
  MidiContent: {fileID: 4900000, guid: 5651cca0434e843a4af2569038996f88, type: 3}
  ShortNoteScaleYFactor: 2
  LongNoteScaleYFactor: 2.5
  startingNoteLane: 0
  LongTilePrefab: {fileID: 8137537297466452066, guid: 12f1ab7db8533406285c2148378e45d8, type: 3}
  ShortTilePrefab: {fileID: 8137537297466452066, guid: 8c1c272d019a341fa8cc13b90b199606, type: 3}
  startingNotePrefab: {fileID: 8137537297466452066, guid: 3ab92a42b30f7d440901bcd50afe0d58, type: 3}

================
File: ECS_Principled/Settings/MusicNoteCreationSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: 5d1ed20f8d24fbd4f95a64d2f692fb66
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/PerfectLineSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 2794e685ab5b84c7299a27a309baa90b, type: 3}
  m_Name: PerfectLineSetting_SO
  m_EditorClassIdentifier: 
  portraitNormalizedPos:
    normalizedX:
      _value: 0.5
    normalizedY:
      _value: 0.3
  landscapeNormalizedPos:
    normalizedX:
      _value: 0.5
    normalizedY:
      _value: 0.3
  portraitNormalizedSize:
    normalizedX:
      _value: 1
    normalizedY:
      _value: 0.004
  landscapeNormalizedSize:
    normalizedX:
      _value: 0.5
    normalizedY:
      _value: 0.004

================
File: ECS_Principled/Settings/PerfectLineSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: d1a21492714ea480f9449e5933a8acd1
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/ScoreEffectSettings_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 90b3ef9aef2e740baa6d7b0a8da6158d, type: 3}
  m_Name: ScoreEffectSettings_SO
  m_EditorClassIdentifier: 
  perfectScoreEffectPrefab: {fileID: 0}
  greatScoreEffectPrefab: {fileID: 0}

================
File: ECS_Principled/Settings/ScoreEffectSettings_SO.asset.meta
================
fileFormatVersion: 2
guid: 0fc1bf2a08ee74502af5a8c06e294b7f
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts.meta
================
fileFormatVersion: 2
guid: ae204fe6d86024e5e910ea37c76036a1
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts/GeneralGameSetting.cs
================
using UnityEngine;

[CreateAssetMenu(fileName = "GeneralGameSetting_SO", menuName = "Settings/GeneralGameSetting")]
public class GeneralGameSetting : ScriptableObject
{
    public float GameSpeed;

    public float PreciseGameSpeed { get; set; }
}

================
File: ECS_Principled/Settings/SO_SCripts/GeneralGameSetting.cs.meta
================
fileFormatVersion: 2
guid: 24a2a689475a5aa4997e54b10cc3c33c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts/LaneLineSettings.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(fileName = "LaneLineSettings_SO", menuName = "Settings/LaneLineSettings")]
    public class LaneLineSettings : ScriptableObject
    {
        public GameObject landLinePrefab;

        public RangeReactiveFloat laneLineWidth;

        private void OnValidate()
        {
            laneLineWidth.OnChangeValidatedInInpsector();
        }
    }
}

================
File: ECS_Principled/Settings/SO_SCripts/LaneLineSettings.cs.meta
================
fileFormatVersion: 2
guid: bfcaf33992d1246beafffa977f1b7a56
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts/MidiNoteParser.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

public static class MidiNoteParser
{
    public static MusicNoteMidiData ParseFromText(string content)
    {
        if (string.IsNullOrEmpty(content))
            throw new MidiParseException("MIDI content cannot be empty");

        var entries = content.Split(',', StringSplitOptions.RemoveEmptyEntries);
        if (entries.Length == 0)
            throw new MidiParseException("No valid MIDI entries found");

        // Split into note entries
        var data = new MusicNoteMidiData(entries.Length);

        for (int i = 0; i < entries.Length; i++)
        {
            try
            {
                ParseEntry(entries[i], i, ref data);
                data.TotalNotes++;
            }
            catch (Exception ex)
            {
                throw new MidiParseException($"Error parsing entry {i}: {ex.Message}");
            }
        }

        ValidateData(ref data);

        return data;
    }

    private static void ParseEntry(string entry, int index, ref MusicNoteMidiData data)
    {
        var properties = entry.Split('-');
        var requiredFields = new HashSet<string> { "id", "n", "ta", "ts", "d", "v", "pid" };
        var parsedFields = new HashSet<string>();

        foreach (var prop in properties)
        {
            var kv = prop.Split(':');
            if (kv.Length != 2)
                throw new MidiParseException($"Invalid property format: {prop}");

            if (!ParseProperty(kv[0], kv[1], index, ref data))
                throw new MidiParseException($"Failed to parse property: {kv[0]}");

            parsedFields.Add(kv[0]);
        }

        // Check for missing required fields
        requiredFields.ExceptWith(parsedFields);
        if (requiredFields.Count > 0)
            throw new MidiParseException(
                $"Missing required fields: {string.Join(", ", requiredFields)}"
            );
    }

    private static bool ParseProperty(
        string key,
        string value,
        int index,
        ref MusicNoteMidiData data
    )
    {
        try
        {
            switch (key)
            {
                case "id":
                    data.Ids[index] = int.Parse(value);
                    break;
                case "n":
                    data.NoteNumbers[index] = int.Parse(value);
                    break;
                case "ta":
                    data.TimeAppears[index] = float.Parse(value);
                    break;
                case "ts":
                    data.Timespans[index] = float.Parse(value);
                    break;
                case "d":
                    float duration = float.Parse(value);
                    data.Durations[index] = duration;
                    data.MinDuration = Mathf.Min(data.MinDuration, duration);
                    break;
                case "v":
                    data.Velocities[index] = float.Parse(value);
                    break;
                case "pid":
                    data.PositionIds[index] = int.Parse(value);
                    break;
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static void ValidateData(ref MusicNoteMidiData data)
    {
        if (data.MinDuration <= 0)
            throw new MidiParseException("Invalid minimum duration");

        if (data.TotalNotes <= 0)
            throw new MidiParseException("No valid notes parsed");
    }
}

public class MidiParseException : Exception
{
    public MidiParseException(string message)
        : base(message) { }
}

================
File: ECS_Principled/Settings/SO_SCripts/MidiNoteParser.cs.meta
================
fileFormatVersion: 2
guid: ccd8b8d0c202c4c46a3c94a768d54c37
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts/MusicNoteCreationSetting.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(
        fileName = "MusicNoteCreationSetting_SO",
        menuName = "Settings/MusicNoteCreationSetting"
    )]
    public class MusicNoteCreationSetting : ScriptableObject
    {
        [Header("Note Calculation Mode")]
        public bool UsePreciseNoteCalculation;

        [Header("Song Data")]
        public TextAsset MidiContent;

        [Header("Note Configuration")]
        [Header("Portrait")]
        public float ShortNoteScaleYFactor;
        public float LongNoteScaleYFactor;
        public float startingNoteLane;

        [Header("Prefabs")]
        public GameObject LongTilePrefab;
        public GameObject ShortTilePrefab;
        public GameObject startingNotePrefab;
    }
}

================
File: ECS_Principled/Settings/SO_SCripts/MusicNoteCreationSetting.cs.meta
================
fileFormatVersion: 2
guid: a5af8e59dd796d941989a811a2c8754b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts/PerfectLineSetting.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(
        fileName = "PerfectLineSetting_SO",
        menuName = "Settings/PerfectLineSetting_SO"
    )]
    public class PerfectLineSetting : ScriptableObject
    {
        [Header(" Normalize Positions")]
        public NormalizedFloatPreset portraitNormalizedPos;

        public NormalizedFloatPreset landscapeNormalizedPos;

        [Header("Normalized Size")]
        public NormalizedFloatPreset portraitNormalizedSize;

        public NormalizedFloatPreset landscapeNormalizedSize;

        [System.Serializable]
        public struct NormalizedFloatPreset
        {
            public RangeReactiveFloat normalizedX;

            public RangeReactiveFloat normalizedY;
        }

        private void OnValidate()
        {
            portraitNormalizedPos.normalizedX.OnChangeValidatedInInpsector();
            portraitNormalizedPos.normalizedY.OnChangeValidatedInInpsector();

            landscapeNormalizedPos.normalizedX.OnChangeValidatedInInpsector();
            landscapeNormalizedPos.normalizedY.OnChangeValidatedInInpsector();

            portraitNormalizedSize.normalizedX.OnChangeValidatedInInpsector();
            portraitNormalizedSize.normalizedY.OnChangeValidatedInInpsector();

            landscapeNormalizedSize.normalizedX.OnChangeValidatedInInpsector();
            landscapeNormalizedSize.normalizedY.OnChangeValidatedInInpsector();
        }
    }

    [Serializable]
    public class RangeReactiveFloat : ReactiveValue<float>
    {
        [Range(0, 1)]
        protected new float _value;
    }
}

================
File: ECS_Principled/Settings/SO_SCripts/PerfectLineSetting.cs.meta
================
fileFormatVersion: 2
guid: 2794e685ab5b84c7299a27a309baa90b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts/ScoreEffectSettings.cs
================
using UnityEngine;

namespace ECS_MagicTile.Settings
{
    [CreateAssetMenu(
        fileName = "ScoreEffectSettings_SO",
        menuName = "Settings/ScoreEffectSettings"
    )]
    public class ScoreEffectSettings : ScriptableObject
    {
        [Header("Perfect Score Effect")]
        public GameObject perfectScoreEffectPrefab;

        [Header("Great Score Prefab")]
        public GameObject greatScoreEffectPrefab;
    }
}

================
File: ECS_Principled/Settings/SO_SCripts/ScoreEffectSettings.cs.meta
================
fileFormatVersion: 2
guid: 90b3ef9aef2e740baa6d7b0a8da6158d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers.meta
================
fileFormatVersion: 2
guid: 200d0ba3dc7c04ac6920253abe6c74a4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/GameScoreSyncTool.cs
================
using ECS_MagicTile.Components;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class GameScoreSyncTool : BaseSyncTool
    {
        public GameScoreSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            scoreText = globalPoint.scoreText;
        }

        protected override Archetype Archetype => Archetype.Registry.GameScore;
        private readonly Text scoreText;

        public void SyncGameScore(ScoreComponent scoreComponent)
        {
            scoreText.text = $"Score: {scoreComponent.TotalScore}";
        }
    }
}

================
File: ECS_Principled/Syncers/GameScoreSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 0c8248051d057454891cb9aa519fe33f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/LaneLineSyncTool.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class LaneLineSyncTool : BaseSyncTool
    {
        public LaneLineSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            laneLineViewFactory = new EntityViewFactory(
                globalPoint.laneLineSettings.landLinePrefab,
                null
            );
        }

        protected override Archetype Archetype => Archetype.Registry.LaneLines;

        public SpriteRenderer[] LaneLineSprites => laneLineSprites;

        private readonly EntityViewFactory laneLineViewFactory;
        private SpriteRenderer[] laneLineSprites;

        public override void InitializeTool()
        {
            base.InitializeTool();
            laneLineSprites = new SpriteRenderer[DedicatedStorage.Count];

            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];
                laneLineSprites[i] = GetOrCreateLaneLineView(entityId)
                    .GetComponent<SpriteRenderer>();
            }
        }

        public void SyncLaneLineTransform(TransformComponent[] lanelineTransform)
        {
            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                laneLineSprites[i].transform.position = lanelineTransform[i].Position;
                laneLineSprites[i].transform.localScale = lanelineTransform[i].Size;
            }
        }

        private GameObject GetOrCreateLaneLineView(int entityId)
        {
            return laneLineViewFactory.GetOrCreateView(entityId);
        }
    }
}

================
File: ECS_Principled/Syncers/LaneLineSyncTool.cs.meta
================
fileFormatVersion: 2
guid: a6ae83dcdaff94f34bcae29a8ff8377d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/MusicNoteSyncer.cs
================
using System;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteSyncer : ArchetypeSyncer
    {
        protected override Archetype Archetype => Archetype.Registry.MusicNote;

        public override EGameState GameStateToExecute { get; } = EGameState.Ingame;

        private readonly EntityViewFactory shortNoteViewFactory;
        private readonly EntityViewFactory longNoteViewFactory;

        // Cache component arrays to avoid getting them each frame
        private TransformComponent[] transforms;
        private MusicNoteComponent[] notes;
        private MusicNoteInteractionComponent[] interactions;
        private MusicNoteFillerComponent[] fillers;

        // Cache frequently accessed components
        private readonly Dictionary<int, SpriteRenderer> noteRenderers = new();
        private readonly Dictionary<int, (GameObject obj, SpriteRenderer renderer)> fillerCache =
            new();

        public MusicNoteSyncer(GlobalPoint globalPoint)
        {
            shortNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.ShortTilePrefab,
                globalPoint.transform
            );
            longNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.LongTilePrefab,
                globalPoint.transform
            );
        }

        public override void Initialize()
        {
            IsEnabled = true;

            // Initialize component array references
            transforms = DedicatedStorage.GetComponents<TransformComponent>();
            notes = DedicatedStorage.GetComponents<MusicNoteComponent>();
            interactions = DedicatedStorage.GetComponents<MusicNoteInteractionComponent>();
            fillers = DedicatedStorage.GetComponents<MusicNoteFillerComponent>();
        }

        public override void Update(float deltaTime)
        {
            // Process notes in batches for better cache utilization
            const int BATCH_SIZE = 64;
            int totalNotes = DedicatedStorage.Count;

            for (int batchStart = 0; batchStart < totalNotes; batchStart += BATCH_SIZE)
            {
                int batchEnd = Math.Min(batchStart + BATCH_SIZE, totalNotes);
                ProcessNoteBatch(batchStart, batchEnd);
            }
        }

        private void ProcessNoteBatch(int start, int end)
        {
            for (int i = start; i < end; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];

                // Get or create view based on note type
                GameObject view = GetOrCreateNoteView(entityId, notes[i].musicNoteType);

                view.transform.position = transforms[i].Position;
                view.transform.localScale = transforms[i].Size;

                SyncNoteState(entityId, view, notes[i], interactions[i], fillers[i]);
            }
        }

        private GameObject GetOrCreateNoteView(int entityId, MusicNoteType noteType)
        {
            return noteType == MusicNoteType.LongNote
                ? longNoteViewFactory.GetOrCreateView(entityId, "longNote")
                : shortNoteViewFactory.GetOrCreateView(entityId, "shortNote");
        }

        private void SyncNoteState(
            int entityId,
            GameObject view,
            MusicNoteComponent note,
            MusicNoteInteractionComponent interaction,
            MusicNoteFillerComponent filler
        )
        {
            // Get cached renderer or cache it
            if (!noteRenderers.TryGetValue(entityId, out var noteRenderer))
            {
                noteRenderer = view.GetComponent<SpriteRenderer>();
                noteRenderers[entityId] = noteRenderer;
            }

            // Update note color based on state
            UpdateNoteColor(noteRenderer, interaction.State);

            // Handle long note filler
            if (note.musicNoteType == MusicNoteType.LongNote)
            {
                SyncNoteFiller(entityId, view, filler);
            }
        }

        private static void UpdateNoteColor(
            SpriteRenderer renderer,
            MusicNoteInteractiveState state
        )
        {
            renderer.color = state switch
            {
                MusicNoteInteractiveState.Normal => Color.white,
                MusicNoteInteractiveState.Pressed or MusicNoteInteractiveState.Hold => Color.yellow,
                MusicNoteInteractiveState.Completed => new Color(1, 1, 1, 0.5f),
                _ => Color.white,
            };
        }

        private void SyncNoteFiller(int entityId, GameObject view, MusicNoteFillerComponent filler)
        {
            if (!fillerCache.TryGetValue(entityId, out var fillerComponents))
            {
                var fillerObj = view.transform.Find("Filler")?.gameObject;
                if (fillerObj != null)
                {
                    fillerComponents = (fillerObj, fillerObj.GetComponent<SpriteRenderer>());
                    fillerCache[entityId] = fillerComponents;
                }
            }

            if (fillerComponents.obj != null)
            {
                fillerComponents.obj.SetActive(filler.IsVisible);
                if (filler.IsVisible)
                {
                    UpdateFillerVisuals(
                        fillerComponents.obj,
                        fillerComponents.renderer,
                        filler.FillPercent
                    );
                }
            }
        }

        private static void UpdateFillerVisuals(
            GameObject fillerObj,
            SpriteRenderer renderer,
            float fillPercent
        )
        {
            Vector3 scale = fillerObj.transform.localScale;
            scale.y = fillPercent;
            SpriteUtility.ScaleFromPivot(renderer, scale, SpriteUtility.PivotPointXY.Bottom);
            renderer.color = Color.Lerp(Color.yellow, Color.green, fillPercent);
        }
    }
}

================
File: ECS_Principled/Syncers/MusicNoteSyncer.cs.meta
================
fileFormatVersion: 2
guid: 541f4a77356ee45a381eacb214f2b6e2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/MusicNoteViewSyncTool.cs
================
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteViewSyncTool : BaseSyncTool
    {
        private readonly EntityViewFactory shortNoteViewFactory;
        private readonly EntityViewFactory longNoteViewFactory;
        protected override Archetype Archetype => Archetype.Registry.MusicNote;

        private readonly Dictionary<int, SpriteRenderer> noteRenderers = new();
        private readonly Dictionary<int, (GameObject obj, SpriteRenderer renderer)> fillerCache =
            new();

        public MusicNoteViewSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            shortNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.ShortTilePrefab,
                globalPoint.transform
            );
            longNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.LongTilePrefab,
                globalPoint.transform
            );
        }

        private GameObject GetOrCreateNoteView(int entityId, MusicNoteType noteType)
        {
            return noteType == MusicNoteType.LongNote
                ? longNoteViewFactory.GetOrCreateView(entityId, "longNote")
                : shortNoteViewFactory.GetOrCreateView(entityId, "shortNote");
        }

        public void SyncNoteTransforms(TransformComponent[] transforms, MusicNoteComponent[] notes)
        {
            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];
                GameObject view = GetOrCreateNoteView(entityId, notes[i].musicNoteType);

                view.transform.position = transforms[i].Position;
                view.transform.localScale = transforms[i].Size;
            }
        }

        public void SyncNoteState(
            MusicNoteInteractionComponent[] interaction,
            MusicNoteFillerComponent[] fillers,
            MusicNoteComponent[] notes
        )
        {
            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];
                GameObject view = GetOrCreateNoteView(entityId, notes[i].musicNoteType);

                if (!noteRenderers.TryGetValue(entityId, out var noteRenderer))
                {
                    noteRenderer = view.GetComponent<SpriteRenderer>();
                    noteRenderers[entityId] = noteRenderer;
                }

                // Update note color based on state
                UpdateNoteColor(noteRenderer, interaction[i].State);

                // Handle long note filler
                if (notes[i].musicNoteType == MusicNoteType.LongNote)
                {
                    SyncNoteFiller(entityId, view, fillers[i]);
                }
            }
        }

        private static void UpdateNoteColor(
            SpriteRenderer renderer,
            MusicNoteInteractiveState state
        )
        {
            renderer.color = state switch
            {
                MusicNoteInteractiveState.Normal => Color.white,
                MusicNoteInteractiveState.Pressed or MusicNoteInteractiveState.Hold => Color.yellow,
                MusicNoteInteractiveState.Completed => new Color(1, 1, 1, 0.5f),
                _ => Color.white,
            };
        }

        public void SyncNoteFiller(int entityId, GameObject view, MusicNoteFillerComponent filler)
        {
            if (!fillerCache.TryGetValue(entityId, out var fillerComponents))
            {
                var fillerObj = view.transform.Find("Filler")?.gameObject;
                if (fillerObj != null)
                {
                    fillerComponents = (fillerObj, fillerObj.GetComponent<SpriteRenderer>());
                    fillerCache[entityId] = fillerComponents;
                }
            }

            if (fillerComponents.obj != null)
            {
                fillerComponents.obj.SetActive(filler.IsVisible);
                if (filler.IsVisible)
                {
                    UpdateFillerVisuals(
                        fillerComponents.obj,
                        fillerComponents.renderer,
                        filler.FillPercent
                    );
                }
            }
        }

        private static void UpdateFillerVisuals(
            GameObject fillerObj,
            SpriteRenderer renderer,
            float fillPercent
        )
        {
            Vector3 scale = fillerObj.transform.localScale;
            scale.y = fillPercent;
            SpriteUtility.ScaleFromPivot(renderer, scale, SpriteUtility.PivotPointXY.Bottom);
            renderer.color = Color.Lerp(Color.yellow, Color.green, fillPercent);
        }
    }
}

================
File: ECS_Principled/Syncers/MusicNoteViewSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 22e852c0f8e864a82b2f0b4de5c0d491
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/PerfectLineSyncTool.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class PerfectLineSyncTool : BaseSyncTool
    {
        protected override Archetype Archetype => Archetype.Registry.PerfectLine;
        private SpriteRenderer perfectLineSprite;

        public PerfectLineSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            perfectLineSprite = globalPoint.perfectLineObject.GetComponent<SpriteRenderer>();
        }

        public void SyncPerfectLineTransform(TransformComponent perfectLineTransform)
        {
            perfectLineSprite.transform.position = perfectLineTransform.Position;
            perfectLineSprite.transform.localScale = perfectLineTransform.Size;
        }
    }
}

================
File: ECS_Principled/Syncers/PerfectLineSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 819e9d873fddd406b8d1b795f2309e15
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/ProgressSyncer.cs
================
using EventChannel;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class ProgressSyncer : ArchetypeSyncer
    {
        public override EGameState GameStateToExecute => EGameState.Ingame;

        protected override Archetype Archetype => Archetype.Registry.SongProgress;

        private readonly BoolEventChannel scoreEventChannel;

        private readonly Slider progressSlider;

        private ProgressComponent[] progressComponents;

        public ProgressSyncer(GlobalPoint globalPoint)
        {
            scoreEventChannel = globalPoint.OnScoreHitChannel;
            progressSlider = globalPoint.progressSlider;
        }

        public override void Initialize()
        {
            IsEnabled = true;

            progressComponents = DedicatedStorage.GetComponents<ProgressComponent>();

            scoreEventChannel.Subscribe(SyncProgressToView);
        }

        private void SyncProgressToView(bool isPerfect)
        {
            ProgressComponent progressComponent = progressComponents[0];
            progressSlider.value = progressComponent.currentProgressPercent;
        }
    }
}

================
File: ECS_Principled/Syncers/ProgressSyncer.cs.meta
================
fileFormatVersion: 2
guid: 5cdfedb8ec59b493682499a649eefe39
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/ProgressSyncTool.cs
================
using ECS_MagicTile;
using UnityEngine.UI;

public class ProgressSyncTool : BaseSyncTool
{
    public ProgressSyncTool(GlobalPoint globalPoint)
        : base(globalPoint)
    {
        progressSlider = globalPoint.progressSlider;
    }

    protected override Archetype Archetype => Archetype.Registry.SongProgress;

    private readonly Slider progressSlider;

    public void SycnProgress(ProgressComponent progressComponent)
    {
        progressSlider.value = progressComponent.currentProgressPercent;
    }
}

================
File: ECS_Principled/Syncers/ProgressSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 993d5dc1edc4c46a1b6c416f877f7f11
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/ScoreUISyncer.cs
================
using ECS_MagicTile;
using ECS_MagicTile.Components;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class ScoreUISyncer : ArchetypeSyncer
    {
        public override EGameState GameStateToExecute => EGameState.All;

        protected override Archetype Archetype => Archetype.Registry.GameScore;

        private readonly Text scoreText;

        // Instead of creating UI, we receive references to existing UI elements
        public ScoreUISyncer(GlobalPoint globalPoint)
        {
            this.scoreText = globalPoint.scoreText;
        }

        public override void Update(float deltaTime)
        {
            // Get score data from storage
            ScoreComponent scoreComponent = DedicatedStorage.GetComponents<ScoreComponent>()[0];

            // Update UI
            scoreText.text = $"Score: {scoreComponent.TotalScore}";
        }
    }
}

================
File: ECS_Principled/Syncers/ScoreUISyncer.cs.meta
================
fileFormatVersion: 2
guid: 3a2ef7a4a601b9a45a648bd1a5870c32
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/StartingNoteSyncer.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class StartingNoteSyncer : ArchetypeSyncer
    {
        protected override Archetype Archetype => Archetype.Registry.StartingNote;

        public override EGameState GameStateToExecute => EGameState.All;

        private readonly EntityViewFactory startingNoteFactory;

        ActiveStateComponent[] startingNoteActiveStateComponents;
        TransformComponent[] startingNoteTransformComponents;

        private GameObject startingNoteViewObject;

        public StartingNoteSyncer(GlobalPoint globalPoint)
        {
            startingNoteFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.startingNotePrefab,
                globalPoint.transform
            );
        }

        public override void Initialize()
        {
            base.Initialize();
            IsEnabled = true;

            startingNoteActiveStateComponents =
                DedicatedStorage.GetComponents<ActiveStateComponent>();

            startingNoteTransformComponents = DedicatedStorage.GetComponents<TransformComponent>();

            int entityId_ = DedicatedStorage.EntityIds[0];

            startingNoteViewObject = startingNoteFactory.GetOrCreateView(entityId_, "StartingNote");
            startingNoteViewObject.transform.localScale = startingNoteTransformComponents[0].Size;
        }

        public override void Update(float deltaTime)
        {
            startingNoteViewObject.SetActive(startingNoteActiveStateComponents[0].isActive);
            // if (!startingNoteViewObject.activeSelf)
            // {
            //     IsEnabled = false;
            // }

            startingNoteViewObject.transform.position = startingNoteTransformComponents[0].Position;
            startingNoteViewObject.transform.localScale = startingNoteTransformComponents[0].Size;
        }
    }
}

================
File: ECS_Principled/Syncers/StartingNoteSyncer.cs.meta
================
fileFormatVersion: 2
guid: c69681375b44edd44bf95aec281d01af
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/StartingNoteSyncTool.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class StartingNoteSyncTool : BaseSyncTool
    {
        public StartingNoteSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            startingNoteFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.startingNotePrefab,
                globalPoint.transform
            );
        }

        protected override Archetype Archetype => Archetype.Registry.StartingNote;

        private readonly EntityViewFactory startingNoteFactory;
        private GameObject startingNoteViewObject;

        public override void InitializeTool()
        {
            base.InitializeTool();
            int entityId_ = DedicatedStorage.EntityIds[0];

            startingNoteViewObject = startingNoteFactory.GetOrCreateView(entityId_, "StartingNote");
        }

        public void SyncStartNoteTransform(TransformComponent startNoteTransform)
        {
            startingNoteViewObject.transform.position = startNoteTransform.Position;
            startingNoteViewObject.transform.localScale = startNoteTransform.Size;
        }

        public void SyncStartNoteState(ActiveStateComponent startNoteState)
        {
            startingNoteViewObject.SetActive(startNoteState.isActive);
        }
    }
}

================
File: ECS_Principled/Syncers/StartingNoteSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 59c15b38042c74518a09fc378d320993
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems.meta
================
fileFormatVersion: 2
guid: c822eec9dba9f4d4b88020ce8c3090ef
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/GameStateSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class GameStateSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.All;

        private readonly IntEventChannel OnGameStartChannel;

        ArchetypeStorage startingNoteStorage;
        ActiveStateComponent[] startingNoteActiveState;
        private StartingNoteSyncTool startingNoteSyncTool;

        public GameStateSystem(GlobalPoint globalPoint)
        {
            OnGameStartChannel = globalPoint.OnGameStartChannel;

            startingNoteSyncTool = globalPoint.startingNoteSyncTool;
        }

        public void Cleanup()
        {
            //
        }

        public void Initialize()
        {
            startingNoteStorage = World.GetStorage(Archetype.Registry.StartingNote);

            startingNoteActiveState = startingNoteStorage.GetComponents<ActiveStateComponent>();

            OnGameStartChannel.Subscribe(OnStartNoteInteraction);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            //
        }

        private void OnStartNoteInteraction(int startNoteId)
        {
            SystemRegistry.SetGameState(EGameState.Ingame);
            startingNoteActiveState[0].isActive = false;
            startingNoteSyncTool.SyncStartNoteState(startingNoteActiveState[0]);
        }
    }
}

================
File: ECS_Principled/Systems/GameStateSystem.cs.meta
================
fileFormatVersion: 2
guid: 01ad329a4e8ba17448b524ad53b02f01
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/InputCollisionSystem.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class InputCollisionSystem : IGameSystem
    {
        private const string LOG_PREFIX = "[Input Collision] ";
        private const int MAX_INPUTS = 2;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        private readonly GeneralGameSetting generalGameSetting;
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;

        ArchetypeStorage inputStorage;
        ArchetypeStorage musicNoteStorage;

        InputStateComponent[] inputStates;
        CornerComponent[] musicNoteCorners;
        MusicNoteInteractionComponent[] musicNoteInteractions;
        MusicNoteFillerComponent[] musicNoteFillers;
        MusicNoteComponent[] musicNotes;

        private readonly MusicNoteViewSyncTool musicNoteViewSyncTool;

        public InputCollisionSystem(GlobalPoint globalPoint)
        {
            this.generalGameSetting = globalPoint.generalGameSetting;
            musicNoteViewSyncTool = globalPoint.musicNoteViewSyncTool;
            musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);
            inputStorage = World.GetStorage(Archetype.Registry.Input);

            inputStates = inputStorage.GetComponents<InputStateComponent>();
            musicNoteCorners = musicNoteStorage.GetComponents<CornerComponent>();
            musicNoteInteractions = musicNoteStorage.GetComponents<MusicNoteInteractionComponent>();
            musicNoteFillers = musicNoteStorage.GetComponents<MusicNoteFillerComponent>();
            musicNotes = musicNoteStorage.GetComponents<MusicNoteComponent>();
        }

        public void Update(float deltaTime)
        {
            for (int inputIdx = 0; inputIdx < MAX_INPUTS; inputIdx++)
            {
                if (!inputStates[inputIdx].IsActive)
                    continue;

                for (int noteIdx = 0; noteIdx < musicNoteStorage.Count; noteIdx++)
                {
                    ProcessNoteCollision(
                        inputStates[inputIdx],
                        ref musicNoteCorners[noteIdx],
                        ref musicNoteInteractions[noteIdx],
                        ref musicNoteFillers[noteIdx],
                        musicNotes[noteIdx]
                    );
                }
            }

            musicNoteViewSyncTool.SyncNoteState(
                musicNoteInteractions,
                musicNoteFillers,
                musicNotes
            );
        }

        private void ProcessNoteCollision(
            InputStateComponent input,
            ref CornerComponent corners,
            ref MusicNoteInteractionComponent interaction,
            ref MusicNoteFillerComponent filler,
            MusicNoteComponent note
        )
        {
            // Skip completed notes
            if (interaction.State == MusicNoteInteractiveState.Completed)
                return;

            bool isInsideNote = IsPointInNote(
                input.Position,
                corners.TopLeft,
                corners.TopRight,
                corners.BottomLeft,
                corners.BottomRight
            );

            if (!isInsideNote)
                return;

            ProcessNoteInteraction(input, ref interaction, ref corners, ref filler, note);
        }

        private void ProcessNoteInteraction(
            InputStateComponent input,
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler,
            MusicNoteComponent note
        )
        {
            switch (input.State)
            {
                case InputState.JustPressed:
                    if (interaction.State == MusicNoteInteractiveState.Normal)
                    {
                        if (note.musicNoteType == MusicNoteType.ShortNote)
                        {
                            CompleteNote(ref interaction);
                        }
                        else
                        {
                            StartLongNote(input, ref interaction, ref corners, ref filler);
                        }
                    }
                    break;

                case InputState.Held:
                    if (note.musicNoteType == MusicNoteType.LongNote)
                    {
                        if (interaction.State == MusicNoteInteractiveState.Pressed)
                        {
                            interaction.State = MusicNoteInteractiveState.Hold;
                        }
                        else if (interaction.State == MusicNoteInteractiveState.Hold)
                        {
                            UpdateLongNoteFill(ref interaction, ref corners, ref filler);
                        }
                    }
                    break;

                case InputState.JustReleased:
                    if (
                        note.musicNoteType == MusicNoteType.LongNote
                        && (
                            interaction.State == MusicNoteInteractiveState.Pressed
                            || interaction.State == MusicNoteInteractiveState.Hold
                        )
                    )
                    {
                        CompleteNote(ref interaction);
                    }
                    break;
            }
        }

        private void CompleteNote(ref MusicNoteInteractionComponent interaction)
        {
            interaction.State = MusicNoteInteractiveState.Completed;
            Debug.Log($"{LOG_PREFIX} Note completed");
        }

        private void StartLongNote(
            InputStateComponent input,
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler
        )
        {
            interaction.State = MusicNoteInteractiveState.Pressed;
            filler.IsVisible = true;

            float sizeOfNote = corners.TopLeft.y - corners.BottomLeft.y;
            float fromTouchPositionToLowerOfNote = input.Position.y - corners.BottomLeft.y;
            float touchPercent = fromTouchPositionToLowerOfNote / sizeOfNote;
            filler.FillPercent = touchPercent + 0.1f;

            Debug.Log($"{LOG_PREFIX} Long note pressed");
        }

        private void UpdateLongNoteFill(
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler
        )
        {
            float gameSpeed = generalGameSetting.GameSpeed;
            if (musicNoteCreationSetting.UsePreciseNoteCalculation)
            {
                gameSpeed = generalGameSetting.PreciseGameSpeed;
            }
            float noteLength = corners.TopLeft.y - corners.BottomLeft.y;
            float fillSpeed = gameSpeed / noteLength;

            float nextFillPercent = filler.FillPercent + (fillSpeed * Time.deltaTime);
            nextFillPercent = Mathf.Min(nextFillPercent, 1f);

            filler.FillPercent = nextFillPercent;

            if (nextFillPercent >= 1f)
            {
                CompleteNote(ref interaction);
            }
        }

        private static bool IsPointInNote(
            Vector2 point,
            Vector2 topLeft,
            Vector2 topRight,
            Vector2 bottomLeft,
            Vector2 bottomRight
        )
        {
            int wn = 0; // Winding number

            Vector2[] vertices = { topLeft, topRight, bottomRight, bottomLeft };

            for (int i = 0; i < vertices.Length; i++)
            {
                Vector2 current = vertices[i];
                Vector2 next = vertices[(i + 1) % vertices.Length];

                if (current.y <= point.y)
                {
                    if (next.y > point.y && IsLeftOf(current, next, point) > 0)
                        wn++;
                }
                else
                {
                    if (next.y <= point.y && IsLeftOf(current, next, point) < 0)
                        wn--;
                }
            }

            return wn != 0;
        }

        private static float IsLeftOf(Vector2 a, Vector2 b, Vector2 point)
        {
            return (b.x - a.x) * (point.y - a.y) - (point.x - a.x) * (b.y - a.y);
        }

        public void Cleanup() { }
    }
}

================
File: ECS_Principled/Systems/InputCollisionSystem.cs.meta
================
fileFormatVersion: 2
guid: a0d38e0610e6340709395f4e4d69e409
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/InputSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class InputSystem : IGameSystem
    {
        private const int MAX_INPUTS = 2;
        private const string LOG_PREFIX = "[Input System] ";
        private bool wasMousePressed;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            // Create input entities
            for (int i = 0; i < MAX_INPUTS; i++)
            {
                var inputComponent = new InputStateComponent
                {
                    IsActive = false,
                    Position = Vector2.zero,
                    PreviousPosition = Vector2.zero,
                    State = InputState.None,
                    FrameCount = 0,
                };

                World.CreateEntityWithComponents(
                    Archetype.Registry.Input,
                    new object[] { inputComponent }
                );
            }
        }

        public void Update(float deltaTime)
        {
            ArchetypeStorage inputStorage = World.GetStorage(Archetype.Registry.Input);
            var inputStates = inputStorage.GetComponents<InputStateComponent>();

            // Update previous states
            UpdatePreviousStates(inputStates);

            // Process new input
            if (Input.touchCount > 0)
            {
                ProcessTouchInput(inputStates);
            }
            else
            {
                ProcessMouseInput(inputStates);
            }
        }

        private void UpdatePreviousStates(InputStateComponent[] inputStates)
        {
            for (int i = 0; i < MAX_INPUTS; i++)
            {
                if (inputStates[i].State == InputState.JustReleased)
                {
                    inputStates[i].State = InputState.None;
                    inputStates[i].FrameCount = 0;
                    inputStates[i].IsActive = false;
                }
                else if (inputStates[i].State == InputState.JustPressed)
                {
                    inputStates[i].State = InputState.Held;
                }
            }
        }

        private void ProcessMouseInput(InputStateComponent[] inputStates)
        {
            bool isCurrentlyPressed = Input.GetMouseButton(0);
            Vector2 worldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);

            ref var currentState = ref inputStates[0];
            InputState newState = DetermineNewInputState(isCurrentlyPressed, wasMousePressed);

            // Only update if state changed or position changed
            if (newState != currentState.State || worldPos != currentState.Position)
            {
                UpdateInputState(ref currentState, worldPos, newState);
            }

            wasMousePressed = isCurrentlyPressed;
        }

        private void ProcessTouchInput(InputStateComponent[] inputStates)
        {
            int touchCount = Mathf.Min(Input.touchCount, MAX_INPUTS);

            // Reset unused input slots
            for (int i = touchCount; i < MAX_INPUTS; i++)
            {
                if (inputStates[i].IsActive)
                {
                    inputStates[i].State = InputState.None;
                    inputStates[i].IsActive = false;
                }
            }

            // Process active touches
            for (int i = 0; i < touchCount; i++)
            {
                Touch touch = Input.GetTouch(i);
                Vector2 worldPos = Camera.main.ScreenToWorldPoint(touch.position);

                InputState newState = touch.phase switch
                {
                    TouchPhase.Began => InputState.JustPressed,
                    TouchPhase.Moved => InputState.Held,
                    TouchPhase.Stationary => InputState.Held,
                    TouchPhase.Ended => InputState.JustReleased,
                    TouchPhase.Canceled => InputState.JustReleased,
                    _ => InputState.None,
                };

                UpdateInputState(ref inputStates[i], worldPos, newState);
            }
        }

        private void UpdateInputState(
            ref InputStateComponent state,
            Vector2 position,
            InputState newState
        )
        {
            state.PreviousPosition = state.Position;
            state.Position = position;
            state.State = newState;
            state.IsActive = newState != InputState.None;

            if (newState != state.State)
            {
                state.FrameCount = 0;
            }
            state.FrameCount++;
        }

        private InputState DetermineNewInputState(bool isPressed, bool wasPressed)
        {
            if (isPressed && !wasPressed)
                return InputState.JustPressed;
            if (!isPressed && wasPressed)
                return InputState.JustReleased;
            if (isPressed)
                return InputState.Held;
            return InputState.None;
        }

        public void Cleanup()
        {
            // Nothing to cleanup for now
        }
    }
}

================
File: ECS_Principled/Systems/InputSystem.cs.meta
================
fileFormatVersion: 2
guid: 3a7c2b94a0f5a416c8d8401ea289c387
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/LaneLineSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using Unity.VisualScripting;
using UnityEngine;

namespace ECS_MagicTile
{
    public class LaneLineSystem : IGameSystem
    {
        public LaneLineSystem(GlobalPoint globalPoint)
        {
            onOrientationChangedChannel = globalPoint.OnOrientationChangedChannel;
            laneLineSyncTool = globalPoint.laneLineSyncTool;
            laneLineSettings = globalPoint.laneLineSettings;
            targetCamera = globalPoint.mainCamera;
        }

        public bool IsEnabled { get; set; }
        public World World { get; set; }

        private BoolEventChannel onOrientationChangedChannel;
        private Camera targetCamera;

        public EGameState GameStateToExecute => EGameState.WaitingToStart;

        ArchetypeStorage perfectLineStorage;
        CornerComponent[] perfectLineCorners;

        ArchetypeStorage laneLineStorage;
        TransformComponent[] laneLineTransforms;

        private LaneLineSyncTool laneLineSyncTool;
        private LaneLineSettings laneLineSettings;

        public void Cleanup() { }

        public void Initialize()
        {
            CreateLaneLines();
            laneLineSyncTool.InitializeTool();
            perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);
            laneLineStorage = World.GetStorage(Archetype.Registry.LaneLines);

            laneLineTransforms = laneLineStorage.GetComponents<TransformComponent>();
            perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>();

            AdjustLaneLines();

            onOrientationChangedChannel.Subscribe(OnOrientationChanged);

            laneLineSettings.laneLineWidth.Subscribe(OnLaneLineSettingsAdjustInInpector);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime) { }

        private void CreateLaneLines()
        {
            for (int i = 0; i < 5; i++)
            {
                var LaneLinesComponents = new object[] { new TransformComponent() };
                World.CreateEntityWithComponents(Archetype.Registry.LaneLines, LaneLinesComponents);
            }
        }

        private void OnOrientationChanged(bool isPortrait)
        {
            AdjustLaneLines();
        }

        private void OnLaneLineSettingsAdjustInInpector(float value)
        {
            AdjustLaneLines();
        }

        private void AdjustLaneLines()
        {
            ref CornerComponent perfectLineCorner = ref perfectLineCorners[0];

            // Calculate lane width once
            float totalWidth = perfectLineCorner.TopRight.x - perfectLineCorner.TopLeft.x;
            float laneWidth = totalWidth / 4;

            for (int i = 0; i < laneLineStorage.Count; i++)
            {
                float spawnX = i * laneWidth + perfectLineCorner.TopLeft.x;
                float spawnY = CameraViewUtils.GetPositionYInCameraView(targetCamera, .5f);

                laneLineTransforms[i].Position = new Vector3(spawnX, spawnY, 0);
                laneLineTransforms[i].Size = SpriteUtility.ResizeInCameraView(
                    laneLineSyncTool.LaneLineSprites[i],
                    targetCamera,
                    laneLineSettings.laneLineWidth.Value,
                    1,
                    false
                );
            }

            laneLineSyncTool.SyncLaneLineTransform(laneLineTransforms);
        }
    }
}

================
File: ECS_Principled/Systems/LaneLineSystem.cs.meta
================
fileFormatVersion: 2
guid: 36b27db23e135449bb2d06e40f049e10
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/MovingNoteSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MovingNoteSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        private readonly GeneralGameSetting generalGameSetting;
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;

        ArchetypeStorage musicNoteStorage;

        TransformComponent[] musicNoteTransforms;
        CornerComponent[] musicNoteCornsers;
        MusicNoteComponent[] musicNoteComponents;

        private readonly MusicNoteViewSyncTool musicNoteViewSyncTool;

        public MovingNoteSystem(GlobalPoint globalPoint)
        {
            this.generalGameSetting = globalPoint.generalGameSetting;
            this.musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
            musicNoteViewSyncTool = globalPoint.musicNoteViewSyncTool;
        }

        public void Cleanup() { }

        public void Initialize()
        {
            musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            musicNoteTransforms = musicNoteStorage.GetComponents<TransformComponent>();
            musicNoteCornsers = musicNoteStorage.GetComponents<CornerComponent>();
            musicNoteComponents = musicNoteStorage.GetComponents<MusicNoteComponent>();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            float gameSpeed;

            if (musicNoteCreationSetting.UsePreciseNoteCalculation)
            {
                gameSpeed = generalGameSetting.PreciseGameSpeed;
            }
            else
            {
                gameSpeed = generalGameSetting.GameSpeed;
            }

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                if (
                    musicNoteComponents[i].musicNotePositionState
                    == MusicNotePositionState.OutOfScreen
                )
                {
                    continue;
                }

                // Update position
                Vector2 newPos = musicNoteTransforms[i].Position;
                newPos.y -= gameSpeed * Time.deltaTime;
                musicNoteTransforms[i].Position = newPos;

                // Update corners based on new position and size
                Vector2 halfSize = musicNoteTransforms[i].Size * 0.5f;
                musicNoteCornsers[i].TopLeft = new Vector2(
                    newPos.x - halfSize.x,
                    newPos.y + halfSize.y
                );
                musicNoteCornsers[i].TopRight = new Vector2(
                    newPos.x + halfSize.x,
                    newPos.y + halfSize.y
                );
                musicNoteCornsers[i].BottomLeft = new Vector2(
                    newPos.x - halfSize.x,
                    newPos.y - halfSize.y
                );
                musicNoteCornsers[i].BottomRight = new Vector2(
                    newPos.x + halfSize.x,
                    newPos.y - halfSize.y
                );

                if (
                    CameraViewUtils.IsPositionOutOfBounds(
                        Camera.main,
                        musicNoteCornsers[i].TopLeft,
                        CameraViewUtils.CameraBoundCheck.Bottom
                    )
                )
                {
                    musicNoteComponents[i].musicNotePositionState =
                        MusicNotePositionState.OutOfScreen;
                }
            }

            musicNoteViewSyncTool.SyncNoteTransforms(musicNoteTransforms, musicNoteComponents);

            //SystemRegistry.SetGameState(EGameState.Outro);
        }
    }
}

================
File: ECS_Principled/Systems/MovingNoteSystem.cs.meta
================
fileFormatVersion: 2
guid: 23e31434417084f63bbc9efc34471f1f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/MusicNoteCreationSystem.cs
================
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteCreationSystem : IGameSystem
    {
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;
        private readonly GeneralGameSetting generalGameSetting;
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.WaitingToStart;

        MusicNoteMidiData musicNoteMidiData;

        ArchetypeStorage perfectLineStorage;
        PerfectLineTagComponent[] perfectLineTag;
        CornerComponent[] perfectLineCorners;

        ArchetypeStorage musicNoteStorage;
        TransformComponent[] musicNoteTransforms;
        MusicNoteComponent[] musicNotes;

        ArchetypeStorage worldStateStorage;
        WorldStateComponent[] worldStates;

        Camera targetCamera;

        float lastPerfectLineTopLeftY;
        float lastPerfectLineTopLeftX;

        public MusicNoteCreationSystem(GlobalPoint globalPoint)
        {
            this.musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
            this.generalGameSetting = globalPoint.generalGameSetting;
            targetCamera = globalPoint.mainCamera;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Initialize()
        {
            musicNoteMidiData = MidiNoteParser.ParseFromText(
                musicNoteCreationSetting.MidiContent.text
            );

            perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);
            perfectLineTag = perfectLineStorage.GetComponents<PerfectLineTagComponent>();
            perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>();

            worldStateStorage = World.GetStorage(Archetype.Registry.WorldState);
            worldStates = worldStateStorage.GetComponents<WorldStateComponent>();

            var noteCount = musicNoteMidiData.TotalNotes;
            var durations = musicNoteMidiData.Durations;
            var positionIds = musicNoteMidiData.PositionIds;
            var timeAppears = musicNoteMidiData.TimeAppears;
            var minDuration = musicNoteMidiData.MinDuration;

            var componentsList = new List<object[]>(noteCount);

            for (int i = 0; i < noteCount; i++)
            {
                var musicNoteType =
                    durations[i] > minDuration ? MusicNoteType.LongNote : MusicNoteType.ShortNote;

                componentsList.Add(
                    new object[]
                    {
                        new TransformComponent(),
                        new MusicNoteComponent
                        {
                            Duration = durations[i],
                            PostionId = positionIds[i],
                            TimeAppear = timeAppears[i],
                            musicNoteType = musicNoteType,
                            musicNotePositionState = MusicNotePositionState.AbovePerfectLine,
                        },
                        new CornerComponent(),
                        new MusicNoteInteractionComponent(),
                        new MusicNoteFillerComponent(),
                        new ScoreStateComponent { HasBeenScored = false },
                    }
                );
            }

            foreach (var components in componentsList)
            {
                World.CreateEntityWithComponents(Archetype.Registry.MusicNote, components);
            }

            musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            musicNoteTransforms = musicNoteStorage.GetComponents<TransformComponent>();
            musicNotes = musicNoteStorage.GetComponents<MusicNoteComponent>();
        }

        public void Update(float deltaTime)
        {
            if (
                lastPerfectLineTopLeftY != perfectLineCorners[0].TopLeft.y
                || lastPerfectLineTopLeftX != perfectLineCorners[0].TopLeft.x
            )
            {
                lastPerfectLineTopLeftY = perfectLineCorners[0].TopLeft.y;
                lastPerfectLineTopLeftX = perfectLineCorners[0].TopLeft.x;

                if (musicNoteCreationSetting.UsePreciseNoteCalculation)
                {
                    CalculateMusicNoteDataPrecisely();
                }
                else
                {
                    CalculateMusicNoteData();
                }
            }
        }

        public void Cleanup()
        {
            //
        }

        private void CalculateMusicNoteData()
        {
            ref CornerComponent perfectLineCorner = ref perfectLineCorners[0];

            // Calculate lane width and half lane width
            float totalWidth = perfectLineCorner.TopRight.x - perfectLineCorner.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            // Calculate Short and Long Note scale factors
            float shortNoteScaleYFactor = MagicTileHelper.CalculateScaleY(
                musicNoteCreationSetting.ShortNoteScaleYFactor,
                perfectLineTag[0].PerfectLineWidth / 4
            );
            float longNoteScaleYFactor = MagicTileHelper.CalculateScaleY(
                musicNoteCreationSetting.LongNoteScaleYFactor,
                perfectLineTag[0].PerfectLineWidth / 4
            );

            // Set all music note positions and sizes
            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                float spawnX =
                    perfectLineCorner.TopLeft.x
                    + (musicNoteMidiData.PositionIds[i] * laneWidth)
                    + halfLaneWidth;

                float spawnY =
                    perfectLineCorner.TopLeft.y
                    + (musicNoteMidiData.TimeAppears[i] * generalGameSetting.GameSpeed)
                    + (
                        musicNotes[i].musicNoteType == MusicNoteType.ShortNote
                            ? shortNoteScaleYFactor
                            : longNoteScaleYFactor
                    );

                musicNoteTransforms[i].Position = new Vector2(spawnX, spawnY);

                musicNoteTransforms[i].Size = new Vector2(
                    perfectLineTag[0].PerfectLineWidth / 4,
                    musicNotes[i].musicNoteType == MusicNoteType.ShortNote
                        ? shortNoteScaleYFactor
                        : longNoteScaleYFactor
                );
            }
        }

        private void CalculateMusicNoteDataPrecisely()
        {
            float[] noteSizes = PreciseNoteCalculator.CalculateNoteSizes(
                musicNoteMidiData,
                musicNoteCreationSetting.ShortNoteScaleYFactor
            );
            float[] positions = PreciseNoteCalculator.CalculateInitialPositions(
                musicNoteMidiData,
                perfectLineCorners[0].TopLeft.y,
                noteSizes,
                musicNoteCreationSetting.ShortNoteScaleYFactor
            );

            worldStates[0].FirstNotePositionToTriggerSong = positions[0];

            ref CornerComponent perfectLineCorner = ref perfectLineCorners[0];

            float totalWidth = perfectLineCorner.TopRight.x - perfectLineCorner.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            float cameraBoundYOffset = CameraViewUtils.GetPositionYInCameraView(targetCamera, 1);

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                float spawnX =
                    perfectLineCorner.TopLeft.x
                    + (musicNoteMidiData.PositionIds[i] * laneWidth)
                    + halfLaneWidth;

                musicNoteTransforms[i].Position = new Vector2(
                    spawnX,
                    positions[i] + (cameraBoundYOffset - perfectLineCorner.TopLeft.y)
                );
                musicNoteTransforms[i].Size = new Vector2(
                    perfectLineTag[0].PerfectLineWidth / 4,
                    noteSizes[i]
                );
            }

            float totalTime = PreciseNoteCalculator.CalculateTotalSongDuration(musicNoteMidiData);
            float roadLength = PreciseNoteCalculator.CalculateRoadLength(
                noteSizes,
                musicNoteMidiData
            );

            generalGameSetting.PreciseGameSpeed = PreciseNoteCalculator.CalculateRequiredVelocity(
                totalTime,
                roadLength
            );
        }
    }
}

================
File: ECS_Principled/Systems/MusicNoteCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: 27223b00486847b4b86f21b0b74f2e53
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/PerfectLineSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class PerfectLineSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        //Storage and Data arrays
        ArchetypeStorage perfectLineStorage;
        PerfectLineTagComponent[] perfectLineTagComponents;
        CornerComponent[] perfectLineCorners;
        TransformComponent[] perfectLineTransforms;

        //SO settings
        PerfectLineSetting perfectLineSetting;

        //Event Channels
        private BoolEventChannel OnOrientationChangedChannel;

        //Game object refs
        SpriteRenderer perfectLineSprite;
        Camera mainCamera;

        SpriteUtility.SpriteCorners perfectLineCornersInCamSpace;

        private PerfectLineSyncTool perfectLineSyncTool;

        public PerfectLineSystem(GlobalPoint globalPoint)
        {
            perfectLineSprite = globalPoint.perfectLineObject.GetComponent<SpriteRenderer>();
            perfectLineSetting = globalPoint.perfectLineSetting;
            mainCamera = globalPoint.mainCamera;
            OnOrientationChangedChannel = globalPoint.OnOrientationChangedChannel;

            perfectLineSyncTool = globalPoint.perfectLineSyncTool;
        }

        public EGameState GameStateToExecute => EGameState.All;

        public void Initialize()
        {
            perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            perfectLineTagComponents = perfectLineStorage.GetComponents<PerfectLineTagComponent>();
            perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>();
            perfectLineTransforms = perfectLineStorage.GetComponents<TransformComponent>();

            //
            perfectLineSetting.portraitNormalizedPos.normalizedX.Subscribe(UpdatePerfectLinePos);
            perfectLineSetting.portraitNormalizedPos.normalizedY.Subscribe(UpdatePerfectLinePos);

            //
            perfectLineSetting.landscapeNormalizedPos.normalizedX.Subscribe(UpdatePerfectLinePos);
            perfectLineSetting.landscapeNormalizedPos.normalizedY.Subscribe(UpdatePerfectLinePos);

            //
            perfectLineSetting.portraitNormalizedSize.normalizedX.Subscribe(
                UpdatePerfectLineSizeData
            );
            perfectLineSetting.portraitNormalizedSize.normalizedY.Subscribe(
                UpdatePerfectLineSizeData
            );

            //
            perfectLineSetting.landscapeNormalizedSize.normalizedX.Subscribe(
                UpdatePerfectLineSizeData
            );
            perfectLineSetting.landscapeNormalizedSize.normalizedY.Subscribe(
                UpdatePerfectLineSizeData
            );

            OnOrientationChangedChannel.Subscribe(OnOrientationChanged);
        }

        public void Cleanup() { }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime) { }

        private void UpdatePerfectLinePos(float value)
        {
            if (ScreenManager.Instance.IsPortrait)
            {
                perfectLineTransforms[0].Position = CameraViewUtils.GetPositionInCameraView(
                    mainCamera,
                    perfectLineSetting.portraitNormalizedPos.normalizedX.Value,
                    perfectLineSetting.portraitNormalizedPos.normalizedY.Value
                );
            }
            else
            {
                perfectLineTransforms[0].Position = CameraViewUtils.GetPositionInCameraView(
                    mainCamera,
                    perfectLineSetting.landscapeNormalizedPos.normalizedX.Value,
                    perfectLineSetting.landscapeNormalizedPos.normalizedY.Value
                );
            }

            perfectLineSyncTool.SyncPerfectLineTransform(perfectLineTransforms[0]);

            UpdatePerfectLineCornersData();
        }

        private void UpdatePerfectLineSizeData(float value)
        {
            if (ScreenManager.Instance.IsPortrait)
            {
                perfectLineTransforms[0].Size = SpriteUtility.ResizeInCameraView(
                    perfectLineSprite,
                    mainCamera,
                    perfectLineSetting.portraitNormalizedSize.normalizedX.Value,
                    perfectLineSetting.portraitNormalizedSize.normalizedY.Value,
                    false
                );
            }
            else
            {
                perfectLineTransforms[0].Size = SpriteUtility.ResizeInCameraView(
                    perfectLineSprite,
                    mainCamera,
                    perfectLineSetting.landscapeNormalizedSize.normalizedX.Value,
                    perfectLineSetting.landscapeNormalizedSize.normalizedY.Value,
                    false
                );
            }

            perfectLineSyncTool.SyncPerfectLineTransform(perfectLineTransforms[0]);

            UpdatePerfectLineCornersData();
        }

        private void UpdatePerfectLineCornersData()
        {
            perfectLineCornersInCamSpace = SpriteUtility.GetSpriteCorners(perfectLineSprite);

            perfectLineCorners[0].TopLeft = perfectLineCornersInCamSpace.TopLeft;
            perfectLineCorners[0].TopRight = perfectLineCornersInCamSpace.TopRight;
            perfectLineCorners[0].BottomLeft = perfectLineCornersInCamSpace.BottomLeft;
            perfectLineCorners[0].BottomRight = perfectLineCornersInCamSpace.BottomRight;

            perfectLineTagComponents[0].PerfectLineWidth = Mathf.Abs(
                perfectLineCornersInCamSpace.TopLeft.x - perfectLineCornersInCamSpace.TopRight.x
            );
        }

        private void OnOrientationChanged(bool isPortrait)
        {
            if (isPortrait)
            {
                UpdatePerfectLinePos(0f);
            }
            else
            {
                UpdatePerfectLinePos(0f);
            }
            UpdatePerfectLineSizeData(0f);
        }
    }
}

================
File: ECS_Principled/Systems/PerfectLineSystem.cs.meta
================
fileFormatVersion: 2
guid: 1b10a060d587046339f5da333963b154
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/ProgressSystem.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ProgressSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        private BoolEventChannel scoreEventChannel;

        private ProgressSyncTool progressSyncTool;

        public ProgressSystem(GlobalPoint globalPoint)
        {
            this.scoreEventChannel = globalPoint.OnScoreHitChannel;
            progressSyncTool = globalPoint.progressSyncTool;
        }

        private ArchetypeStorage progressArchetype;

        public void Cleanup() { }

        public void Initialize()
        {
            progressArchetype = World.GetStorage(Archetype.Registry.SongProgress);

            scoreEventChannel.Subscribe(OnScoreEvent);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime) { }

        private void OnScoreEvent(bool isScore)
        {
            ref ProgressComponent progress =
                ref progressArchetype.GetComponents<ProgressComponent>()[0];
            progress.CurrentProgressRawValue++;
            progress.currentProgressPercent =
                progress.CurrentProgressRawValue / progress.MaxProgressRawValue;

            Debug.Log($"Current Progress: {progress.currentProgressPercent}");

            progressSyncTool.SycnProgress(progress);
        }
    }
}

================
File: ECS_Principled/Systems/ProgressSystem.cs.meta
================
fileFormatVersion: 2
guid: 48ac64d4224f142299e7f0d4888feaf5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/ScoringSystem.cs
================
using System;
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ScoringSystem : IGameSystem
    {
        private const int PERFECT_SCORE = 100;
        private const int GREAT_SCORE = 50;

        // How close to perfect line needed for perfect score (in units)
        private const float PERFECT_THRESHOLD = 0.1f;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        ArchetypeStorage noteStorage;
        ArchetypeStorage gameScoreStorage;
        ArchetypeStorage perfectLineStorage;

        MusicNoteInteractionComponent[] musicNoteInteractionComponents;
        TransformComponent[] musicNoteTransformComponents;
        ScoreStateComponent[] musicScoreStateComponents;
        MusicNoteComponent[] musicNoteComponents;

        BoolEventChannel scoreSignalEffectChannel;

        private GameScoreSyncTool gameScoreSyncTool;

        public ScoringSystem(GlobalPoint globalPoint)
        {
            this.scoreSignalEffectChannel = globalPoint.OnScoreHitChannel;
            this.gameScoreSyncTool = globalPoint.gameScoreSyncTool;
        }

        public void Cleanup()
        {
            //
        }

        public void Initialize()
        {
            noteStorage = World.GetStorage(Archetype.Registry.MusicNote);
            gameScoreStorage = World.GetStorage(Archetype.Registry.GameScore);
            perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            musicNoteComponents = noteStorage.GetComponents<MusicNoteComponent>();
            musicNoteInteractionComponents =
                noteStorage.GetComponents<MusicNoteInteractionComponent>();
            musicNoteTransformComponents = noteStorage.GetComponents<TransformComponent>();
            musicScoreStateComponents = noteStorage.GetComponents<ScoreStateComponent>();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            var perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>()[0];
            ref var gameScore = ref gameScoreStorage.GetComponents<ScoreComponent>()[0];

            //process note
            for (int i = 0; i < noteStorage.Count; i++)
            {
                // Only process notes that were just hit and haven't been scored
                if (musicScoreStateComponents[i].HasBeenScored)
                {
                    continue;
                }

                if (musicNoteComponents[i].musicNoteType == MusicNoteType.LongNote)
                {
                    if (
                        musicNoteInteractionComponents[i].State == MusicNoteInteractiveState.Pressed
                    )
                    {
                        ProcessNoteScore(
                            musicNoteTransformComponents[i],
                            perfectLineCorners,
                            ref gameScore,
                            ref musicScoreStateComponents[i]
                        );
                    }
                }
                else
                {
                    if (
                        musicNoteInteractionComponents[i].State == MusicNoteInteractiveState.Pressed
                        || musicNoteInteractionComponents[i].State
                            == MusicNoteInteractiveState.Completed
                    )
                    {
                        ProcessNoteScore(
                            musicNoteTransformComponents[i],
                            perfectLineCorners,
                            ref gameScore,
                            ref musicScoreStateComponents[i]
                        );
                    }
                }
            }
        }

        private void ProcessNoteScore(
            TransformComponent musicTransform,
            CornerComponent perfectLineCorners,
            ref ScoreComponent gameScore,
            ref ScoreStateComponent scoreStateComponent
        )
        {
            float distanceFromPerfect = Mathf.Abs(
                musicTransform.Position.y - perfectLineCorners.TopLeft.y
            );

            int scoreToAdd;

            if (distanceFromPerfect <= PERFECT_THRESHOLD)
            {
                scoreToAdd = PERFECT_SCORE;
                scoreSignalEffectChannel.RaiseEvent(true);
            }
            else
            {
                scoreToAdd = GREAT_SCORE;
                scoreSignalEffectChannel.RaiseEvent(false);
            }

            gameScore.TotalScore += scoreToAdd;
            scoreStateComponent.HasBeenScored = true;

            gameScoreSyncTool.SyncGameScore(gameScore);
        }
    }
}

================
File: ECS_Principled/Systems/ScoringSystem.cs.meta
================
fileFormatVersion: 2
guid: 8fca9e9bcd6671c42bc6b410aa575c9e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/SingletonCreationSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class SingletonCreationSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.WaitingToStart;

        private readonly MusicNoteCreationSetting musicNoteCreationSetting;
        private readonly PerfectLineSetting perfectLineSetting;

        private ArchetypeStorage perfectLineStorage;

        private SpriteRenderer perfectLineSprite;

        public SingletonCreationSystem(GlobalPoint globalPoint)
        {
            musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
            perfectLineSetting = globalPoint.perfectLineSetting;

            perfectLineSprite = globalPoint.perfectLineObject.GetComponent<SpriteRenderer>();
        }

        public void Cleanup()
        {
            //
        }

        public void Initialize()
        {
            CreatePerfectLine();
            CreateStartingNote();
            CreateGameScore();
            CreateProgress();
            CreateWorldStateComponent();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            //
        }

        private void CreatePerfectLine()
        {
            //The perfect line singleton
            var components = new object[]
            {
                new TransformComponent(),
                new PerfectLineTagComponent(),
                new CornerComponent(),
            };
            World.CreateEntityWithComponents(Archetype.Registry.PerfectLine, components);
        }

        private void CreateStartingNote()
        {
            var components = new object[]
            {
                new TransformComponent(),
                new ActiveStateComponent(),
                new StartingNoteTagComponent(),
            };
            World.CreateEntityWithComponents(Archetype.Registry.StartingNote, components);
        }

        private void CreateGameScore()
        {
            var components = new object[] { new ScoreComponent { TotalScore = 0 } };
            World.CreateEntityWithComponents(Archetype.Registry.GameScore, components);
        }

        private void CreateProgress()
        {
            MusicNoteMidiData musicNoteMidiData = MidiNoteParser.ParseFromText(
                musicNoteCreationSetting.MidiContent.text
            );
            var components = new object[]
            {
                new ProgressComponent
                {
                    CurrentProgressRawValue = 0,
                    currentProgressPercent = 0,
                    MaxProgressRawValue = musicNoteMidiData.TotalNotes,
                },
            };
            World.CreateEntityWithComponents(Archetype.Registry.SongProgress, components);
        }

        private void CreateWorldStateComponent()
        {
            var components = new object[] { new WorldStateComponent() };
            World.CreateEntityWithComponents(Archetype.Registry.WorldState, components);
        }
    }
}

================
File: ECS_Principled/Systems/SingletonCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: 0363a30a155e7de4492faa5045403325
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/StartingNoteSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class StartingNoteSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.All;

        private readonly MusicNoteCreationSetting musicNoteCreationSetting;

        private readonly StartingNoteSyncTool startingNoteSyncTool;

        private ArchetypeStorage startingNoteStorage;
        private ArchetypeStorage perfectLineStorage;

        private TransformComponent[] startingNoteTransforms;
        private CornerComponent[] perfectLineCorners;

        float lastPerfectLineTopLeftY;
        float lastPerfectLineTopLeftX;

        public StartingNoteSystem(GlobalPoint globalPoint)
        {
            musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
            startingNoteSyncTool = globalPoint.startingNoteSyncTool;
        }

        public void Cleanup() { }

        public void Initialize()
        {
            startingNoteSyncTool.InitializeTool();

            startingNoteStorage ??= World.GetStorage(Archetype.Registry.StartingNote);
            perfectLineStorage ??= World.GetStorage(Archetype.Registry.PerfectLine);

            perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>();
            startingNoteTransforms = startingNoteStorage.GetComponents<TransformComponent>();

            ref ActiveStateComponent activeState =
                ref startingNoteStorage.GetComponents<ActiveStateComponent>()[0];
            activeState.isActive = true;

            SetupStartingNote();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            if (
                lastPerfectLineTopLeftY != perfectLineCorners[0].TopLeft.y
                || lastPerfectLineTopLeftX != perfectLineCorners[0].TopLeft.x
            )
            {
                lastPerfectLineTopLeftY = perfectLineCorners[0].TopLeft.y;
                lastPerfectLineTopLeftX = perfectLineCorners[0].TopLeft.x;
                SetupStartingNote();
            }

            //Debug.Log($"PerfectLine Topleft: {perfectLineCorners[0].TopLeft.x}");
        }

        private void SetupStartingNote()
        {
            ref TransformComponent transform = ref startingNoteTransforms[0];

            ref CornerComponent perfectLineCorner = ref perfectLineCorners[0];

            // Calculate lane width
            float totalWidth = perfectLineCorner.TopRight.x - perfectLineCorner.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            // Calculate spawn position
            float spawnX = perfectLineCorner.TopLeft.x + (0 * laneWidth) + halfLaneWidth;
            float spawnY = perfectLineCorner.TopLeft.y;

            transform.Position = new Vector2(spawnX, spawnY);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            float scaleX = PerfectLine.PerfectLineWidth / 4;

            float scaleY = MagicTileHelper.CalculateScaleY(
                musicNoteCreationSetting.ShortNoteScaleYFactor,
                scaleX
            );

            transform.Size = new Vector2(scaleX, scaleY);

            startingNoteSyncTool.SyncStartNoteTransform(transform);
        }
    }
}

================
File: ECS_Principled/Systems/StartingNoteSystem.cs.meta
================
fileFormatVersion: 2
guid: bd30870514eee4c529701bd1bedca700
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/TraceNoteToTriggerSongSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class TraceNoteToTriggerSongSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.Ingame;

        ArchetypeStorage musicnNoteStorage;
        TransformComponent[] musicNoteTransforms;

        ArchetypeStorage worldStateStorage;
        WorldStateComponent[] worldStateComponents;

        EmptyEventChannel OnSongStartChannel;

        public TraceNoteToTriggerSongSystem(GlobalPoint globalPoint)
        {
            OnSongStartChannel = globalPoint.OnSongStartChannel;
        }

        public void Cleanup() { }

        public void Initialize()
        {
            worldStateStorage = World.GetStorage(Archetype.Registry.WorldState);
            worldStateComponents = worldStateStorage.GetComponents<WorldStateComponent>();

            musicnNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);
            musicNoteTransforms = musicnNoteStorage.GetComponents<TransformComponent>();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void Update(float deltaTime)
        {
            if (
                musicNoteTransforms[0].Position.y
                <= worldStateComponents[0].FirstNotePositionToTriggerSong
            )
            {
                OnSongStartChannel.RaiseEvent(new EmptyData());
                IsEnabled = false;
            }
        }
    }
}

================
File: ECS_Principled/Systems/TraceNoteToTriggerSongSystem.cs.meta
================
fileFormatVersion: 2
guid: 93c4845eb14e3064ea19d934433b14f2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
