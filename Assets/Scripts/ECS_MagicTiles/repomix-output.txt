This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-02T18:14:40.275Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
ECS_Principled.meta
ECS_Principled/Core.meta
ECS_Principled/Core/Archetype.cs
ECS_Principled/Core/Archetype.cs.meta
ECS_Principled/Core/ArchetypeStorage.cs
ECS_Principled/Core/ArchetypeStorage.cs.meta
ECS_Principled/Core/ArchetypeSyncer.cs
ECS_Principled/Core/ArchetypeSyncer.cs.meta
ECS_Principled/Core/BaseSyncTool.cs
ECS_Principled/Core/BaseSyncTool.cs.meta
ECS_Principled/Core/ComponentType.cs
ECS_Principled/Core/ComponentType.cs.meta
ECS_Principled/Core/EntityIdHolder.cs
ECS_Principled/Core/EntityIdHolder.cs.meta
ECS_Principled/Core/EntityViewFactory.cs
ECS_Principled/Core/EntityViewFactory.cs.meta
ECS_Principled/Core/EntityViewManager.cs
ECS_Principled/Core/EntityViewManager.cs.meta
ECS_Principled/Core/GlobalPoint.cs
ECS_Principled/Core/GlobalPoint.cs.meta
ECS_Principled/Core/IComponent.cs
ECS_Principled/Core/IComponent.cs.meta
ECS_Principled/Core/IEntityHolder.cs
ECS_Principled/Core/IEntityHolder.cs.meta
ECS_Principled/Core/IGameSystem.cs
ECS_Principled/Core/IGameSystem.cs.meta
ECS_Principled/Core/StorageManager.cs
ECS_Principled/Core/StorageManager.cs.meta
ECS_Principled/Core/SystemRegistry.cs
ECS_Principled/Core/SystemRegistry.cs.meta
ECS_Principled/Core/World.cs
ECS_Principled/Core/World.cs.meta
ECS_Principled/DataComponents.meta
ECS_Principled/DataComponents/ActiveStateComponent.cs
ECS_Principled/DataComponents/ActiveStateComponent.cs.meta
ECS_Principled/DataComponents/CornerComponent.cs
ECS_Principled/DataComponents/CornerComponent.cs.meta
ECS_Principled/DataComponents/GraphicComponent.cs
ECS_Principled/DataComponents/GraphicComponent.cs.meta
ECS_Principled/DataComponents/InputStateComponent.cs
ECS_Principled/DataComponents/InputStateComponent.cs.meta
ECS_Principled/DataComponents/LongNoteTagComponent.cs
ECS_Principled/DataComponents/LongNoteTagComponent.cs.meta
ECS_Principled/DataComponents/MusicNoteComponent.cs
ECS_Principled/DataComponents/MusicNoteComponent.cs.meta
ECS_Principled/DataComponents/MusicNoteFillerComponent.cs
ECS_Principled/DataComponents/MusicNoteFillerComponent.cs.meta
ECS_Principled/DataComponents/MusicNoteInteractionComponent.cs
ECS_Principled/DataComponents/MusicNoteInteractionComponent.cs.meta
ECS_Principled/DataComponents/PerfectLineTagComponent.cs
ECS_Principled/DataComponents/PerfectLineTagComponent.cs.meta
ECS_Principled/DataComponents/ProgressComponent.cs
ECS_Principled/DataComponents/ProgressComponent.cs.meta
ECS_Principled/DataComponents/ScoreComponent.cs
ECS_Principled/DataComponents/ScoreComponent.cs.meta
ECS_Principled/DataComponents/ScoreEffectComponent.cs
ECS_Principled/DataComponents/ScoreEffectComponent.cs.meta
ECS_Principled/DataComponents/ScoreStateComponent.cs
ECS_Principled/DataComponents/ScoreStateComponent.cs.meta
ECS_Principled/DataComponents/ShortNoteTagComponent.cs
ECS_Principled/DataComponents/ShortNoteTagComponent.cs.meta
ECS_Principled/DataComponents/StartingNoteTagComponent.cs
ECS_Principled/DataComponents/StartingNoteTagComponent.cs.meta
ECS_Principled/DataComponents/TransformComponent.cs
ECS_Principled/DataComponents/TransformComponent.cs.meta
ECS_Principled/DataComponents/WorldStateComponent.cs
ECS_Principled/DataComponents/WorldStateComponent.cs.meta
ECS_Principled/DTO.meta
ECS_Principled/DTO/MusicNoteMidiData.cs
ECS_Principled/DTO/MusicNoteMidiData.cs.meta
ECS_Principled/EGameState.cs
ECS_Principled/EGameState.cs.meta
ECS_Principled/EventChannels.meta
ECS_Principled/EventChannels/OnGameStartChannel.asset
ECS_Principled/EventChannels/OnGameStartChannel.asset.meta
ECS_Principled/EventChannels/OnOrientationChangeChannel.asset
ECS_Principled/EventChannels/OnOrientationChangeChannel.asset.meta
ECS_Principled/EventChannels/OnSongStartChannel.asset
ECS_Principled/EventChannels/OnSongStartChannel.asset.meta
ECS_Principled/EventChannels/SO_ScoreSignalEffectChannel.asset
ECS_Principled/EventChannels/SO_ScoreSignalEffectChannel.asset.meta
ECS_Principled/EventChannels/SOScripts.meta
ECS_Principled/EventChannels/SOScripts/BoolEventChannel.cs
ECS_Principled/EventChannels/SOScripts/BoolEventChannel.cs.meta
ECS_Principled/EventChannels/SOScripts/IntEventChannel.cs
ECS_Principled/EventChannels/SOScripts/IntEventChannel.cs.meta
ECS_Principled/Functions.meta
ECS_Principled/Functions/GameStateMachine.meta
ECS_Principled/Functions/GameStateMachine/GameSystemState.cs
ECS_Principled/Functions/GameStateMachine/GameSystemState.cs.meta
ECS_Principled/Functions/PreciseNoteCalculator.cs
ECS_Principled/Functions/PreciseNoteCalculator.cs.meta
ECS_Principled/MonoScripts.meta
ECS_Principled/MonoScripts/AudioManager.cs
ECS_Principled/MonoScripts/AudioManager.cs.meta
ECS_Principled/MonoScripts/BurstMovement.cs
ECS_Principled/MonoScripts/BurstMovement.cs.meta
ECS_Principled/MonoScripts/BurstMovementUIController.cs
ECS_Principled/MonoScripts/BurstMovementUIController.cs.meta
ECS_Principled/MonoScripts/CrownTween.cs
ECS_Principled/MonoScripts/CrownTween.cs.meta
ECS_Principled/MonoScripts/EffectOnProgress.cs
ECS_Principled/MonoScripts/EffectOnProgress.cs.meta
ECS_Principled/MonoScripts/ProgressEffectController.cs
ECS_Principled/MonoScripts/ProgressEffectController.cs.meta
ECS_Principled/MonoScripts/RaycastToObjects.cs
ECS_Principled/MonoScripts/RaycastToObjects.cs.meta
ECS_Principled/MonoScripts/ScoreEffectController.cs
ECS_Principled/MonoScripts/ScoreEffectController.cs.meta
ECS_Principled/MonoScripts/ScreenManager.cs
ECS_Principled/MonoScripts/ScreenManager.cs.meta
ECS_Principled/MonoScripts/StarTween.cs
ECS_Principled/MonoScripts/StarTween.cs.meta
ECS_Principled/MonoScripts/VerticalLineSetup.cs
ECS_Principled/MonoScripts/VerticalLineSetup.cs.meta
ECS_Principled/Settings.meta
ECS_Principled/Settings/GeneralGameSetting_SO.asset
ECS_Principled/Settings/GeneralGameSetting_SO.asset.meta
ECS_Principled/Settings/LaneLineSettings_SO.asset
ECS_Principled/Settings/LaneLineSettings_SO.asset.meta
ECS_Principled/Settings/MusicNoteCreationSetting_SO.asset
ECS_Principled/Settings/MusicNoteCreationSetting_SO.asset.meta
ECS_Principled/Settings/PerfectLineSetting_SO.asset
ECS_Principled/Settings/PerfectLineSetting_SO.asset.meta
ECS_Principled/Settings/ScoreEffectSettings_SO.asset
ECS_Principled/Settings/ScoreEffectSettings_SO.asset.meta
ECS_Principled/Settings/SO_InGameUIElementSetting.asset
ECS_Principled/Settings/SO_InGameUIElementSetting.asset.meta
ECS_Principled/Settings/SO_SCripts.meta
ECS_Principled/Settings/SO_SCripts/GeneralGameSetting.cs
ECS_Principled/Settings/SO_SCripts/GeneralGameSetting.cs.meta
ECS_Principled/Settings/SO_SCripts/InGameUIElementSetting.cs
ECS_Principled/Settings/SO_SCripts/InGameUIElementSetting.cs.meta
ECS_Principled/Settings/SO_SCripts/LaneLineSettings.cs
ECS_Principled/Settings/SO_SCripts/LaneLineSettings.cs.meta
ECS_Principled/Settings/SO_SCripts/MidiNoteParser.cs
ECS_Principled/Settings/SO_SCripts/MidiNoteParser.cs.meta
ECS_Principled/Settings/SO_SCripts/MusicNoteCreationSetting.cs
ECS_Principled/Settings/SO_SCripts/MusicNoteCreationSetting.cs.meta
ECS_Principled/Settings/SO_SCripts/PerfectLineSetting.cs
ECS_Principled/Settings/SO_SCripts/PerfectLineSetting.cs.meta
ECS_Principled/Settings/SO_SCripts/ScoreEffectSettings.cs
ECS_Principled/Settings/SO_SCripts/ScoreEffectSettings.cs.meta
ECS_Principled/Syncers.meta
ECS_Principled/Syncers/GameScoreSyncTool.cs
ECS_Principled/Syncers/GameScoreSyncTool.cs.meta
ECS_Principled/Syncers/LaneLineSyncTool.cs
ECS_Principled/Syncers/LaneLineSyncTool.cs.meta
ECS_Principled/Syncers/MusicNoteSyncer.cs
ECS_Principled/Syncers/MusicNoteSyncer.cs.meta
ECS_Principled/Syncers/MusicNoteViewSyncTool.cs
ECS_Principled/Syncers/MusicNoteViewSyncTool.cs.meta
ECS_Principled/Syncers/PerfectLineSyncTool.cs
ECS_Principled/Syncers/PerfectLineSyncTool.cs.meta
ECS_Principled/Syncers/ProgressSyncer.cs
ECS_Principled/Syncers/ProgressSyncer.cs.meta
ECS_Principled/Syncers/ProgressSyncTool.cs
ECS_Principled/Syncers/ProgressSyncTool.cs.meta
ECS_Principled/Syncers/ScoreUISyncer.cs
ECS_Principled/Syncers/ScoreUISyncer.cs.meta
ECS_Principled/Syncers/StartingNoteSyncer.cs
ECS_Principled/Syncers/StartingNoteSyncer.cs.meta
ECS_Principled/Syncers/StartingNoteSyncTool.cs
ECS_Principled/Syncers/StartingNoteSyncTool.cs.meta
ECS_Principled/Systems_Mono.meta
ECS_Principled/Systems_Mono/GameIntroSystem.cs
ECS_Principled/Systems_Mono/GameIntroSystem.cs.meta
ECS_Principled/Systems_Mono/InGameUIElementHandlerSystem.cs
ECS_Principled/Systems_Mono/InGameUIElementHandlerSystem.cs.meta
ECS_Principled/Systems_Mono/IntroUIElementHandlerSystem.cs
ECS_Principled/Systems_Mono/IntroUIElementHandlerSystem.cs.meta
ECS_Principled/Systems.meta
ECS_Principled/Systems/GameStateSystem.cs
ECS_Principled/Systems/GameStateSystem.cs.meta
ECS_Principled/Systems/InputCollisionSystem.cs
ECS_Principled/Systems/InputCollisionSystem.cs.meta
ECS_Principled/Systems/InputSystem.cs
ECS_Principled/Systems/InputSystem.cs.meta
ECS_Principled/Systems/LaneLineSystem.cs
ECS_Principled/Systems/LaneLineSystem.cs.meta
ECS_Principled/Systems/MovingNoteSystem.cs
ECS_Principled/Systems/MovingNoteSystem.cs.meta
ECS_Principled/Systems/MusicNoteCreationSystem.cs
ECS_Principled/Systems/MusicNoteCreationSystem.cs.meta
ECS_Principled/Systems/PerfectLineSystem.cs
ECS_Principled/Systems/PerfectLineSystem.cs.meta
ECS_Principled/Systems/ProgressSystem.cs
ECS_Principled/Systems/ProgressSystem.cs.meta
ECS_Principled/Systems/ScoringSystem.cs
ECS_Principled/Systems/ScoringSystem.cs.meta
ECS_Principled/Systems/SingletonCreationSystem.cs
ECS_Principled/Systems/SingletonCreationSystem.cs.meta
ECS_Principled/Systems/StartingNoteSystem.cs
ECS_Principled/Systems/StartingNoteSystem.cs.meta
ECS_Principled/Systems/TraceNoteToTriggerSongSystem.cs
ECS_Principled/Systems/TraceNoteToTriggerSongSystem.cs.meta

================================================================
Repository Files
================================================================

================
File: ECS_Principled.meta
================
fileFormatVersion: 2
guid: c7a632be4233831448c1261c82cae9ee
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core.meta
================
fileFormatVersion: 2
guid: b57c2d5fbb39b489e9c51a111e5e8e4f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/Archetype.cs
================
using System;
using System.Linq;

namespace ECS_MagicTile
{
    public class Archetype
    {
        private readonly ComponentType[] types;
        private readonly int hash;
        private readonly bool isAspect;

        public bool IsAspect => isAspect;

        private Archetype(ComponentType[] types, bool isAspect = false)
        {
            // Store types in a fixed order for consistent hashing
            this.types = types.OrderBy(t => t.Id).ToArray();
            this.hash = CalculateHash(this.types);
            this.isAspect = isAspect;
        }

        // Utility methods for archetype management
        public ComponentType[] GetTypes() => types;

        public int GetHash() => hash;

        private static int CalculateHash(ComponentType[] types)
        {
            // Simple but effective hash calculation for fixed component combinations
            int hash = 17;
            foreach (var type in types)
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        // Game-specific archetypes
        public static class Registry
        {
            // Note archetypes
            public static readonly Archetype MusicNote = new Archetype(
                new[]
                {
                    ComponentType.Registry.Transform,
                    ComponentType.Registry.MusicNote,
                    ComponentType.Registry.Corner, // Added CornerComponent
                    ComponentType.Registry.MusicNoteInteraction,
                    ComponentType.Registry.MusicNoteFiller,
                    ComponentType.Registry.NoteScoreState,
                }
            );

            // Game setup archetypes
            public static readonly Archetype PerfectLine = new Archetype(
                new[]
                {
                    ComponentType.Registry.Transform,
                    ComponentType.Registry.PerfectLine,
                    ComponentType.Registry.Corner,
                }
            );

            public static readonly Archetype Input = new Archetype(
                new[] { ComponentType.Registry.Input }
            );
            public static readonly Archetype StartingNote = new Archetype(
                new[]
                {
                    ComponentType.Registry.Transform,
                    ComponentType.Registry.ActiveState,
                    ComponentType.Registry.StartingNote,
                }
            );

            public static readonly Archetype GameScore = new Archetype(
                new[]
                {
                    ComponentType
                        .Registry
                        .GameScore // New score component
                    ,
                }
            );

            public static readonly Archetype SongProgress = new Archetype(
                new[] { ComponentType.Registry.Progress }
            );

            public static readonly Archetype LaneLines = new Archetype(
                new[] { ComponentType.Registry.Transform }
            );

            public static readonly Archetype WorldState = new Archetype(
                new[] { ComponentType.Registry.WorldState }
            );

            // Keep track of all archetypes for initialization
            private static readonly Archetype[] AllArchetypes =
            {
                MusicNote,
                PerfectLine,
                Input,
                StartingNote,
                GameScore,
                SongProgress,
                LaneLines,
                WorldState,
            };

            public static Archetype[] GetAllArchetypes() => AllArchetypes;
        }
    }
}

================
File: ECS_Principled/Core/Archetype.cs.meta
================
fileFormatVersion: 2
guid: 6a700f18bf185134ebcd378e0ebfe28f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/ArchetypeStorage.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_MagicTile
{
    public class ArchetypeStorage
    {
        // Store component arrays indexed by their ComponentType
        private readonly Dictionary<ComponentType, Array> componentArrays;
        private int[] entityIds; // Tracks which entities are in this storage
        private readonly Dictionary<int, int> entityToIndex = new Dictionary<int, int>();
        private int count; // Number of active entities

        private const int DEFAULT_CAPACITY = 64; // Starting size for our arrays
        private const float GROWTH_FACTOR = 2.0f; // How much to grow when we need more space

        public ArchetypeStorage(Archetype archetype, int initialCapacity = DEFAULT_CAPACITY)
        {
            componentArrays = new Dictionary<ComponentType, Array>();

            // Create typed arrays for each component in the archetype
            foreach (var componentType in archetype.GetTypes())
            {
                // Creates an array of the proper type with our initial capacity
                componentArrays[componentType] = Array.CreateInstance(
                    componentType.Type,
                    initialCapacity
                );
            }

            entityIds = new int[initialCapacity];

            count = 0;
        }

        // Provides type-safe access to component arrays
        public T[] GetComponents<T>()
            where T : struct
        {
            var componentType = ComponentType.Registry.GetComponentType<T>();
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {typeof(T)} not found in archetype"
                );
            }
            return (T[])array;
        }

        // Adds an entity with its components to this storage
        public void Add(int entityId, object[] components)
        {
            // Grow arrays if needed
            if (count >= entityIds.Length)
            {
                Grow();
            }

            // Add components to their respective arrays
            int componentIndex = 0;
            foreach (var array in componentArrays.Values)
            {
                Array.Copy(new[] { components[componentIndex] }, 0, array, count, 1);
                componentIndex++;
            }

            // Track the entity
            entityIds[count] = entityId;
            entityToIndex[entityId] = count;
            count++;
        }

        // Efficiently removes an entity by swapping with the last element
        public void Remove(int entityId)
        {
            // Find the entity's index
            int index = Array.IndexOf(entityIds, entityId, 0, count);
            if (index == -1)
                return;

            // If it's not the last element, swap with the last one
            int lastIndex = count - 1;
            if (index < lastIndex)
            {
                foreach (var array in componentArrays.Values)
                {
                    Array.Copy(array, lastIndex, array, index, 1);
                }
                entityIds[index] = entityIds[lastIndex];
                entityToIndex[entityIds[lastIndex]] = index;
            }

            entityToIndex.Remove(entityId);
            count--;
        }

        private void Grow()
        {
            int newCapacity = (int)(entityIds.Length * GROWTH_FACTOR);

            // Grow all component arrays
            foreach (var kvp in componentArrays.ToList())
            {
                var oldArray = kvp.Value;
                var newArray = Array.CreateInstance(kvp.Key.Type, newCapacity);
                Array.Copy(oldArray, 0, newArray, 0, count);
                componentArrays[kvp.Key] = newArray;
            }

            // Grow entity ID array
            Array.Resize(ref entityIds, newCapacity);
        }

        // And we need to add this method to ArchetypeStorage
        public Array GetComponentArrayRaw(ComponentType componentType)
        {
            if (!componentArrays.TryGetValue(componentType, out var array))
            {
                throw new InvalidOperationException(
                    $"Component type {componentType.Type.Name} not found in archetype"
                );
            }
            return array;
        }

        public int GetEntityIndex(int entityId)
        {
            return entityToIndex.TryGetValue(entityId, out int index) ? index : -1;
        }

        // Properties for accessing storage information
        public int Count => count;
        public int[] EntityIds => entityIds;
    }
}

================
File: ECS_Principled/Core/ArchetypeStorage.cs.meta
================
fileFormatVersion: 2
guid: 785407d53c9c26746adb34ba3d74b58d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/ArchetypeSyncer.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public abstract class ArchetypeSyncer : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        protected ArchetypeStorage DedicatedStorage => World.GetStorage(Archetype);
        protected abstract Archetype Archetype { get; }

        public abstract EGameState GameStateToExecute { get; }

        public void SetWorld(World world)
        {
            World = world;
        }

        public virtual void RunInitialize() { }

        public virtual void RunUpdate(float deltaTime) { }

        public virtual void RunCleanup() { }
    }
}

================
File: ECS_Principled/Core/ArchetypeSyncer.cs.meta
================
fileFormatVersion: 2
guid: 0df86895fba8144229e53825e79322a5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/BaseSyncTool.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public abstract class BaseSyncTool
    {
        protected World World;
        protected abstract Archetype Archetype { get; }
        protected ArchetypeStorage DedicatedStorage;

        public bool IsInitialized { get; set; }

        public BaseSyncTool(GlobalPoint globalPoint)
        {
            this.World = globalPoint.World;

            DedicatedStorage = World.GetStorage(Archetype);

            IsInitialized = false;
        }

        public virtual void InitializeTool()
        {
            if (IsInitialized)
                return;
            IsInitialized = true;
        }
    }
}

================
File: ECS_Principled/Core/BaseSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 5e44dbdf22074481cb483b4d3d14412b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/ComponentType.cs
================
using System;
using System.Collections.Generic;
using ECS_MagicTile.Components;

namespace ECS_MagicTile
{
    public readonly struct ComponentType
    {
        public readonly Type Type;
        public readonly int Id;

        // Private constructor ensures all types are created through registry
        private ComponentType(Type type, int id)
        {
            Type = type;
            Id = id;
        }

        // Static registry of all component types in our game
        public static class Registry
        {
            // Core Components
            public static readonly ComponentType Transform = new ComponentType(
                typeof(TransformComponent),
                0
            );
            public static readonly ComponentType MusicNote = new ComponentType(
                typeof(MusicNoteComponent),
                1
            );

            public static readonly ComponentType PerfectLine = new ComponentType(
                typeof(PerfectLineTagComponent),
                3
            );
            public static readonly ComponentType Corner = new ComponentType(
                typeof(CornerComponent),
                4
            );

            public static readonly ComponentType Input = new ComponentType(
                typeof(InputStateComponent),
                5
            );
            public static readonly ComponentType MusicNoteInteraction = new ComponentType(
                typeof(MusicNoteInteractionComponent),
                6
            );
            public static readonly ComponentType MusicNoteFiller = new ComponentType(
                typeof(MusicNoteFillerComponent),
                7
            );

            public static readonly ComponentType ActiveState = new ComponentType(
                typeof(ActiveStateComponent),
                8
            );
            public static readonly ComponentType StartingNote = new ComponentType(
                typeof(StartingNoteTagComponent),
                9
            );
            public static readonly ComponentType GameScore = new ComponentType(
                typeof(ScoreComponent),
                10
            );
            public static readonly ComponentType NoteScoreState = new ComponentType(
                typeof(ScoreStateComponent),
                11
            );

            public static readonly ComponentType TransformGroup = new ComponentType(
                typeof(TransformComponentGroup),
                12
            );

            public static readonly ComponentType Progress = new ComponentType(
                typeof(ProgressComponent),
                14
            );
            public static readonly ComponentType WorldState = new ComponentType(
                typeof(WorldStateComponent),
                15
            );

            // A lookup dictionary to quickly find ComponentType by Type
            private static readonly Dictionary<Type, ComponentType> typeToComponentType =
                new Dictionary<Type, ComponentType>
                {
                    { typeof(TransformComponent), Transform },
                    { typeof(MusicNoteComponent), MusicNote },
                    { typeof(PerfectLineTagComponent), PerfectLine },
                    { typeof(CornerComponent), Corner },
                    { typeof(InputStateComponent), Input },
                    { typeof(MusicNoteInteractionComponent), MusicNoteInteraction },
                    { typeof(MusicNoteFillerComponent), MusicNoteFiller },
                    { typeof(ActiveStateComponent), ActiveState },
                    { typeof(StartingNoteTagComponent), StartingNote },
                    { typeof(ScoreComponent), GameScore },
                    { typeof(ScoreStateComponent), NoteScoreState },
                    { typeof(TransformComponentGroup), TransformGroup },
                    { typeof(ProgressComponent), Progress },
                    { typeof(WorldStateComponent), WorldState },
                };

            // This is our new generic lookup method
            public static ComponentType GetComponentType<T>()
                where T : struct
            {
                var type = typeof(T);
                if (!typeToComponentType.TryGetValue(type, out var componentType))
                {
                    throw new InvalidOperationException(
                        $"Component type {type.Name} is not registered. "
                            + "Make sure to add it to the ComponentType.Registry."
                    );
                }
                return componentType;
            }

            // The existing methods remain the same
            public static ComponentType[] GetAllTypes() => AllTypes;

            private static readonly ComponentType[] AllTypes =
            {
                Transform,
                MusicNote,
                PerfectLine,
                Corner,
            };
        }
    }
}

================
File: ECS_Principled/Core/ComponentType.cs.meta
================
fileFormatVersion: 2
guid: 07d3246996a8eeb4ba2c5e2e4d0939c9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/EntityIdHolder.cs
================
using System.Linq;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EntityIdHolder : MonoBehaviour, IEntityHolder
    {
        public int EntityId { get; private set; }

        public void SetEntityId(int id)
        {
            EntityId = id;
            // Optional: Make the GameObject name more readable without losing the ID reference
            gameObject.name = $"{id}_{gameObject.name.Split('_').LastOrDefault() ?? "entity"}";
        }
    }
}

================
File: ECS_Principled/Core/EntityIdHolder.cs.meta
================
fileFormatVersion: 2
guid: 17dde60b87c53b14884d92c6a0f07c99
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/EntityViewFactory.cs
================
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EntityViewFactory
    {
        private readonly Dictionary<int, GameObject> entityViews =
            new Dictionary<int, GameObject>();
        private readonly GameObject prefabSource;
        private readonly Transform viewRoot;

        public EntityViewFactory() { }

        public EntityViewFactory(GameObject prefabSource, Transform viewRoot)
        {
            this.prefabSource = prefabSource;
            this.viewRoot = viewRoot;
        }

        public GameObject GetOrCreateView(int entityId, string nameOnCreation = "")
        {
            if (entityViews.TryGetValue(entityId, out var existing))
            {
                return existing;
            }

            var prefab = prefabSource;

            GameObject view = GameObject.Instantiate(prefab, viewRoot);
            EntityIdHolder viewEntityIdHolder = view.AddComponent<EntityIdHolder>();
            viewEntityIdHolder.SetEntityId(entityId);
            entityViews[entityId] = view;
            return view;
        }

        public GameObject GetView(int entityId)
        {
            return entityViews.TryGetValue(entityId, out var view) ? view : null;
        }
    }
}

================
File: ECS_Principled/Core/EntityViewFactory.cs.meta
================
fileFormatVersion: 2
guid: f36c2cdebdbc74a8db63bff96d758abd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/EntityViewManager.cs
================
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EntityViewManager : MonoBehaviour, IGameSystem
    {
        const int DEFAULT_FACTORY_COUNT = 8;
        private Dictionary<int, int> factoryIdToIndex = new Dictionary<int, int>();
        private EntityViewFactory[] entityViewFactories;
        Queue<int> holeIndicies = new Queue<int>();

        int highestIndex = 0;

        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.All;

        public void RegisterEntityViewFactory(int factoryId, EntityViewFactory factory)
        {
            if (holeIndicies.Count > 0)
            {
                int holeIndex = holeIndicies.Dequeue();
                entityViewFactories[holeIndex] = factory;
                factoryIdToIndex[factoryId] = holeIndex;
                return;
            }
            factoryIdToIndex[factoryId] = highestIndex;
            entityViewFactories[highestIndex] = factory;

            highestIndex++;
        }

        public void RemoveEntityViewFactory(int factoryId)
        {
            int factoryIndex = factoryIdToIndex[factoryId];
            entityViewFactories[factoryIndex] = null;
            factoryIdToIndex.Remove(factoryId);
            holeIndicies.Enqueue(factoryIndex);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunInitialize()
        {
            entityViewFactories = new EntityViewFactory[DEFAULT_FACTORY_COUNT];
        }

        public void RunUpdate(float deltaTime) { }

        public void RunCleanup() { }
    }
}

================
File: ECS_Principled/Core/EntityViewManager.cs.meta
================
fileFormatVersion: 2
guid: 766ae46cb5f1c4ce99ebcbf02b5b5a8b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/GlobalPoint.cs
================
using EventChannel;
using StateMachineChart;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class GlobalPoint : MonoBehaviour
    {
        [Header("Game Settings")]
        public GeneralGameSetting generalGameSetting;

        public MusicNoteCreationSetting musicNoteCreationSettings;

        public PerfectLineSetting perfectLineSetting;
        public LaneLineSettings laneLineSettings;

        [Header("Event Channel")]
        public IntEventChannel OnGameStartChannel;
        public BoolEventChannel OnScoreHitChannel;
        public BoolEventChannel OnOrientationChangedChannel;
        public EmptyEventChannel OnSongStartChannel;

        [Header("UI references")]
        public Text scoreText;
        public Slider progressSlider;

        [Header("Object references")]
        public GameObject perfectLineObject;
        public Camera mainCamera;

        [Header("Mono Settings")]
        public GameIntroSystem gameIntroSystem;
        public InGameUIElementHandlerSystem inGameUIElementHandlerSystem;
        private World world;

        public World World
        {
            get => world;
        }

        public MusicNoteViewSyncTool musicNoteViewSyncTool { get; private set; }
        public PerfectLineSyncTool perfectLineSyncTool { get; private set; }
        public StartingNoteSyncTool startingNoteSyncTool { get; private set; }
        public GameScoreSyncTool gameScoreSyncTool { get; private set; }
        public ProgressSyncTool progressSyncTool { get; private set; }
        public LaneLineSyncTool laneLineSyncTool { get; private set; }

        private StateChart stateChart;

        private void Awake()
        {
            // Initialize our ECS world
            world = new World();

            generalGameSetting.CurrentGameState = EGameState.Intro;

            SystemRegistry.Initialize(world);
            InitializeSyncTools();
            RegisterSystems();
            SetupStateChart();
        }

        private void InitializeSyncTools()
        {
            musicNoteViewSyncTool = new MusicNoteViewSyncTool(this);
            perfectLineSyncTool = new PerfectLineSyncTool(this);
            startingNoteSyncTool = new StartingNoteSyncTool(this);
            gameScoreSyncTool = new GameScoreSyncTool(this);
            progressSyncTool = new ProgressSyncTool(this);
            laneLineSyncTool = new LaneLineSyncTool(this);
        }

        private void SetupStateChart()
        {
            var rootState = new CompositeState();

            var introState = new GameSystemState(World, new IGameSystem[] { gameIntroSystem });
            var preStartState = new GameSystemState(
                World,
                new IGameSystem[]
                {
                    new StartingNoteSystem(this),
                    new PerfectLineSystem(this),
                    new LaneLineSystem(this),
                    inGameUIElementHandlerSystem,
                }
            );
            var ingameState = new GameSystemState(
                World,
                new IGameSystem[]
                {
                    new MusicNoteCreationSystem(this),
                    new MovingNoteSystem(this),
                    new TraceNoteToTriggerSongSystem(this),
                    new InputSystem(),
                    new InputCollisionSystem(this),
                    new ScoringSystem(this),
                    new ProgressSystem(this),
                }
            );

            rootState.AddSubstate(introState);
            rootState.AddSubstate(ingameState);

            stateChart = new StateChart(rootState);

            stateChart.AddTransition(
                introState,
                preStartState,
                () => generalGameSetting.CurrentGameState == EGameState.IngamePrestart
            );

            stateChart.AddTransition(
                preStartState,
                ingameState,
                () => generalGameSetting.CurrentGameState == EGameState.IngamePlaying
            );
        }

        private void RegisterSystems()
        {
            //Singleton Creation system
            SystemRegistry.AddSystem(new SingletonCreationSystem(this));

            // //Creation System
            // SystemRegistry.AddSystem(new PerfectLineSystem(this));
            // SystemRegistry.AddSystem(new MusicNoteCreationSystem(this));
            // SystemRegistry.AddSystem(new StartingNoteSystem(this));

            // //Handling Data system
            // SystemRegistry.AddSystem(new MovingNoteSystem(this));
            // SystemRegistry.AddSystem(new TraceNoteToTriggerSongSystem(this));
            // SystemRegistry.AddSystem(new InputSystem());
            // SystemRegistry.AddSystem(new InputCollisionSystem(this));
            // SystemRegistry.AddSystem(new ScoringSystem(this));
            // SystemRegistry.AddSystem(new ProgressSystem(this));
            // SystemRegistry.AddSystem(new LaneLineSystem(this));

            // //Game State system
            SystemRegistry.AddSystem(new GameStateSystem(this));
        }

        private void Update()
        {
            // Update all systems with current frame's delta time
            SystemRegistry.Update(Time.deltaTime);
            stateChart.Update();
        }
    }
}

================
File: ECS_Principled/Core/GlobalPoint.cs.meta
================
fileFormatVersion: 2
guid: a3234adf86578d14ca74bc8cc99f7901
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/IComponent.cs
================
namespace ECS_MagicTile
{
    public interface IComponent { }
}

================
File: ECS_Principled/Core/IComponent.cs.meta
================
fileFormatVersion: 2
guid: 5bfc30fb61b4b4792b8875b3f63c5a3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/IEntityHolder.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public interface IEntityHolder
    {
        int EntityId { get; }

        void SetEntityId(int id);
    }
}

================
File: ECS_Principled/Core/IEntityHolder.cs.meta
================
fileFormatVersion: 2
guid: 1049762c28d04a94da5cb9e99c65ebb4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/IGameSystem.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    // Interface that all our game systems will implement

    public interface IGameSystem
    {
        void SetWorld(World world);
        void RunInitialize(); // Called when system is first created
        void RunUpdate(float deltaTime); // Called every frame
        void RunCleanup();
        bool IsEnabled { get; set; } // Controls if system should be updated
        World World { get; set; }
    }
}

================
File: ECS_Principled/Core/IGameSystem.cs.meta
================
fileFormatVersion: 2
guid: 38d38b21b37a3cf4dbb318fce0f3efdf
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/StorageManager.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Manages all archetype storages in our game
    public class StorageManager
    {
        // Maps archetype hashes to their storage
        private readonly Dictionary<int, ArchetypeStorage> storages;
        private readonly Dictionary<int, List<ArchetypeStorage>> aspectStorages;

        public StorageManager()
        {
            storages = new Dictionary<int, ArchetypeStorage>();
            aspectStorages = new Dictionary<int, List<ArchetypeStorage>>();

            // First, create regular storages
            foreach (var archetype in Archetype.Registry.GetAllArchetypes())
            {
                if (!IsAspectArchetype(archetype))
                {
                    storages[archetype.GetHash()] = new ArchetypeStorage(archetype);
                }

                if (IsAspectArchetype(archetype))
                {
                    // Find all archetypes that contain these components
                    var matchingStorages = FindMatchingStorages(archetype);
                    aspectStorages[archetype.GetHash()] = matchingStorages;
                }
            }
        }

        private bool IsAspectArchetype(Archetype archetype)
        {
            // You could mark aspect archetypes explicitly, or use a naming convention,
            // or determine based on component count
            return archetype.IsAspect;
        }

        private List<ArchetypeStorage> FindMatchingStorages(Archetype aspectArchetype)
        {
            var matchingStorages = new List<ArchetypeStorage>();
            var requiredComponents = aspectArchetype.GetTypes();

            foreach (var storage in storages.Values)
            {
                // Check if this storage's archetype contains all required components
                bool matches = true;
                foreach (var component in requiredComponents)
                {
                    if (!HasComponent(storage, component))
                    {
                        matches = false;
                        break;
                    }
                }

                if (matches)
                {
                    matchingStorages.Add(storage);
                }
            }

            return matchingStorages;
        }

        // Get storage for a specific archetype
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            if (!storages.TryGetValue(archetype.GetHash(), out var storage))
            {
                throw new InvalidOperationException($"No storage found for archetype {archetype}");
            }
            return storage;
        }

        private bool HasComponent(ArchetypeStorage storage, ComponentType componentType)
        {
            try
            {
                // We try to get the component array - if it exists, the storage has this component
                Array componentArray = storage.GetComponentArrayRaw(componentType);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}

================
File: ECS_Principled/Core/StorageManager.cs.meta
================
fileFormatVersion: 2
guid: 6e34b51edd65cc54298a958d1e7db250
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/SystemRegistry.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_MagicTile
{
    // Our central system management class
    public static class SystemRegistry
    {
        // Store systems in order of execution priority
        private static readonly List<IGameSystem> updateSystems = new List<IGameSystem>();
        private static World world;
        private static bool isInitialized;
        private static EGameState currentGameState = EGameState.IngamePrestart;

        // Initialize our registry with a world reference
        public static void Initialize(World gameWorld)
        {
            // Prevent multiple initializations
            if (isInitialized)
            {
                Debug.LogWarning("SystemRegistry already initialized!");
                return;
            }

            world = gameWorld;
            isInitialized = true;
        }

        // Allow adding systems from GlobalPoint
        public static void AddSystem(IGameSystem system)
        {
            if (!isInitialized)
            {
                Debug.LogError("SystemRegistry not initialized! Call Initialize first.");
                return;
            }

            // Provide the system with world reference and initialize it
            system.SetWorld(world);
            system.RunInitialize();

            updateSystems.Add(system);

            Debug.Log($"Added system: {system.GetType().Name}");
        }

        public static void Update(float deltaTime)
        {
            if (!isInitialized)
                return;

            foreach (var system in updateSystems)
            {
                try
                {
                    system.RunUpdate(deltaTime);
                }
                catch (Exception e)
                {
                    Debug.LogError($"Error in system {system.GetType().Name}: {e}");
                }
            }
        }

        public static void Cleanup()
        {
            foreach (var system in updateSystems)
            {
                system.RunCleanup();
            }

            updateSystems.Clear();
            isInitialized = false;
            world = null;
        }

        public static void SetGameState(EGameState newState)
        {
            currentGameState = newState;
        }
    }
}

================
File: ECS_Principled/Core/SystemRegistry.cs.meta
================
fileFormatVersion: 2
guid: ae3ac3479b706d64f83a41cf766e7021
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Core/World.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    public class World
    {
        private readonly StorageManager storageManager;
        private int nextEntityId = 1000; // Starting from 1000 to leave room for special IDs

        public World()
        {
            storageManager = new StorageManager();
        }

        // Creates an entity of a specific archetype
        private int CreateEntity()
        {
            int entityId = nextEntityId++;
            return entityId;
        }

        // Gets a specific storage for systems to use
        public ArchetypeStorage GetStorage(Archetype archetype)
        {
            return storageManager.GetStorage(archetype);
        }

        // Helper method to create and set up an entity in one go
        public int CreateEntityWithComponents(Archetype archetype, object[] components)
        {
            int entityId = CreateEntity();
            ArchetypeStorage storage = GetStorage(archetype);
            storage.Add(entityId, components);
            return entityId;
        }
    }
}

================
File: ECS_Principled/Core/World.cs.meta
================
fileFormatVersion: 2
guid: 1df84a3b9711fcb41b790ef98664b125
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents.meta
================
fileFormatVersion: 2
guid: 401cb534838cf40049f69183b5206b9c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ActiveStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ActiveStateComponent : IComponent
    {
        public bool isActive;
    }
}

================
File: ECS_Principled/DataComponents/ActiveStateComponent.cs.meta
================
fileFormatVersion: 2
guid: a3c5cd13e343b874085a9dacaa62d089
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/CornerComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct CornerComponent : IComponent
    {
        public Vector2 TopLeft;
        public Vector2 TopRight;
        public Vector2 BottomLeft;
        public Vector2 BottomRight;
    }
}

================
File: ECS_Principled/DataComponents/CornerComponent.cs.meta
================
fileFormatVersion: 2
guid: b96e4a6c6cb604761b6ec117819be5b4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/GraphicComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct GraphicComponent : IComponent
    {
        public float Alpha;
    }
}

================
File: ECS_Principled/DataComponents/GraphicComponent.cs.meta
================
fileFormatVersion: 2
guid: 82ef7ef712a2447df8b498a1935315b2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/InputStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct InputStateComponent : IComponent
    {
        public bool IsActive;
        public Vector2 Position;
        public Vector2 PreviousPosition;
        public InputState State;
        public int FrameCount;
    }
}

================
File: ECS_Principled/DataComponents/InputStateComponent.cs.meta
================
fileFormatVersion: 2
guid: 97c04fe8669d4470d94eec98d4274ef1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/LongNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct LongNoteTagComponent : IComponent { }
}

================
File: ECS_Principled/DataComponents/LongNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 58353002a3593244d8bf12e61f349c98
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/MusicNoteComponent.cs
================
using ECS_MagicTile;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteComponent : IComponent
    {
        public int PostionId;
        public float TimeAppear;
        public float Duration;
        public MusicNoteType musicNoteType;
        public MusicNotePositionState musicNotePositionState;
    }
}

================
File: ECS_Principled/DataComponents/MusicNoteComponent.cs.meta
================
fileFormatVersion: 2
guid: e13eda0f52da940ceaec30f721998b78
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/MusicNoteFillerComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteFillerComponent : IComponent
    {
        public bool IsVisible;
        public float FillPercent;
    }
}

================
File: ECS_Principled/DataComponents/MusicNoteFillerComponent.cs.meta
================
fileFormatVersion: 2
guid: d7e3fc83bb7c04b7b9b06366cc8a2202
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/MusicNoteInteractionComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct MusicNoteInteractionComponent : IComponent
    {
        public MusicNoteInteractiveState State;
    }
}

================
File: ECS_Principled/DataComponents/MusicNoteInteractionComponent.cs.meta
================
fileFormatVersion: 2
guid: e6da2d26198754d3382d07b0e55fa2f1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/PerfectLineTagComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct PerfectLineTagComponent : IComponent
    {
        public float PerfectLineWidth;
    }
}

================
File: ECS_Principled/DataComponents/PerfectLineTagComponent.cs.meta
================
fileFormatVersion: 2
guid: e18089c9ed33d49f8b76960358f6a4d2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ProgressComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public struct ProgressComponent : IComponent
    {
        public float MaxProgressRawValue;
        public float CurrentProgressRawValue;
        public float currentProgressPercent;
    }
}

================
File: ECS_Principled/DataComponents/ProgressComponent.cs.meta
================
fileFormatVersion: 2
guid: 10aad573b13074bc9be17ec7cf91ad53
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ScoreComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ScoreComponent : IComponent
    {
        public int TotalScore;
    }
}

================
File: ECS_Principled/DataComponents/ScoreComponent.cs.meta
================
fileFormatVersion: 2
guid: fa68460c39b07454594ff59898fdcbbe
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ScoreEffectComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct TransformComponentGroup : IComponent
    {
        public TransformComponent[] satelliteEffects;
    }
}

================
File: ECS_Principled/DataComponents/ScoreEffectComponent.cs.meta
================
fileFormatVersion: 2
guid: 363408fdc911f4ec2b3d751d95811afb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ScoreStateComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile
{
    public struct ScoreStateComponent : IComponent
    {
        public bool HasBeenScored;
    }
}

================
File: ECS_Principled/DataComponents/ScoreStateComponent.cs.meta
================
fileFormatVersion: 2
guid: f7658e090bcd30d46b50748601faa672
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/ShortNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct ShortNoteTagComponent : IComponent { }
}

================
File: ECS_Principled/DataComponents/ShortNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 83c9ef9fdf039c843b9556bfba72a05a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/StartingNoteTagComponent.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct StartingNoteTagComponent : IComponent
    {
        public int initalLane;
    }
}

================
File: ECS_Principled/DataComponents/StartingNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 60788d363c63c884e898300f27bf2be1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/TransformComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct TransformComponent : IComponent
    {
        public Vector2 Position;
        public Vector2 Size;
        public Vector2 rotation;
    }
}

================
File: ECS_Principled/DataComponents/TransformComponent.cs.meta
================
fileFormatVersion: 2
guid: ff2e94255bc1f499a986a60df04d62ec
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DataComponents/WorldStateComponent.cs
================
using UnityEngine;

namespace ECS_MagicTile.Components
{
    public struct WorldStateComponent : IComponent
    {
        public float FirstNotePositionToTriggerSong;
    }
}

================
File: ECS_Principled/DataComponents/WorldStateComponent.cs.meta
================
fileFormatVersion: 2
guid: a5162f3c9a136cc41823dccde90295d3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DTO.meta
================
fileFormatVersion: 2
guid: c3e7f3ef03f524e6089d969eb175e299
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/DTO/MusicNoteMidiData.cs
================
using UnityEngine;

public struct MusicNoteMidiData : IDataComponent
{
    // Core data arrays
    public int[] Ids;
    public int[] NoteNumbers;
    public int[] PositionIds;
    public float[] TimeAppears;
    public float[] Timespans;
    public float[] Durations;
    public float[] Velocities;

    // Metadata
    public int TotalNotes;
    public float MinDuration;

    public MusicNoteMidiData(int capacity)
    {
        // Preallocate arrays with specified capacity
        Ids = new int[capacity];
        NoteNumbers = new int[capacity];
        TimeAppears = new float[capacity];
        Timespans = new float[capacity];
        Durations = new float[capacity];
        Velocities = new float[capacity];
        PositionIds = new int[capacity];

        TotalNotes = 0;
        MinDuration = float.MaxValue;
    }
}

================
File: ECS_Principled/DTO/MusicNoteMidiData.cs.meta
================
fileFormatVersion: 2
guid: 0772d691d2fae418b83ddb22ddc64cc6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EGameState.cs
================
namespace ECS_MagicTile
{
    public enum EGameState
    {
        Intro,
        IngamePrestart,
        IngamePlaying,
        Outro,
        All,
    }
}

================
File: ECS_Principled/EGameState.cs.meta
================
fileFormatVersion: 2
guid: ea96b7999d1692748b0c374877fef0d4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels.meta
================
fileFormatVersion: 2
guid: a808c7b858a7cf1459c4ba6cf1d5efe8
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/OnGameStartChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 84c124985c8ec984998e8fd8a7792f33, type: 3}
  m_Name: OnGameStartChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: ECS_Principled/EventChannels/OnGameStartChannel.asset.meta
================
fileFormatVersion: 2
guid: 44439b2ecef163c4e8e6b70a713339a8
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/OnOrientationChangeChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 20ec6d5789c44934380628f5b1389ae7, type: 3}
  m_Name: OnOrientationChangeChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: ECS_Principled/EventChannels/OnOrientationChangeChannel.asset.meta
================
fileFormatVersion: 2
guid: 2ceeecf601ad944f699e78a3f56a522e
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/OnSongStartChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a25d70a25c32e5b4b99a7e2929ad8cea, type: 3}
  m_Name: OnSongStartChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: ECS_Principled/EventChannels/OnSongStartChannel.asset.meta
================
fileFormatVersion: 2
guid: e44f33d26247cc141ae0b8696485f784
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/SO_ScoreSignalEffectChannel.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 20ec6d5789c44934380628f5b1389ae7, type: 3}
  m_Name: SO_ScoreSignalEffectChannel
  m_EditorClassIdentifier: 
  maxListeners: 8

================
File: ECS_Principled/EventChannels/SO_ScoreSignalEffectChannel.asset.meta
================
fileFormatVersion: 2
guid: ea0ef8d03bdeb4c4784bc02c8a47c318
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/SOScripts.meta
================
fileFormatVersion: 2
guid: 7b8aa6ae181e147d8af51b60d816fe7a
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/SOScripts/BoolEventChannel.cs
================
using UnityEngine;

namespace EventChannel
{
    [CreateAssetMenu(
        fileName = "sO_BoolEventChannel",
        menuName = "Event Channels/BoolEventChannel"
    )]
    public class BoolEventChannel : EventChannelSO<bool> { }
}

================
File: ECS_Principled/EventChannels/SOScripts/BoolEventChannel.cs.meta
================
fileFormatVersion: 2
guid: 20ec6d5789c44934380628f5b1389ae7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/EventChannels/SOScripts/IntEventChannel.cs
================
using UnityEngine;

namespace EventChannel
{
    [CreateAssetMenu(fileName = "IntEventChannel", menuName = "Event Channels/Int event channel")]
    public class IntEventChannel : EventChannelSO<int> { }
}

================
File: ECS_Principled/EventChannels/SOScripts/IntEventChannel.cs.meta
================
fileFormatVersion: 2
guid: 84c124985c8ec984998e8fd8a7792f33
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Functions.meta
================
fileFormatVersion: 2
guid: 640c8ae1ec4198a4e9afbf063ad8727d
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Functions/GameStateMachine.meta
================
fileFormatVersion: 2
guid: 222f31544d52ecd4eb1f08087b2f26d7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Functions/GameStateMachine/GameSystemState.cs
================
using System.Collections.Generic;
using StateMachineChart;
using UnityEngine;

namespace ECS_MagicTile
{
    public class GameSystemState : BaseState
    {
        protected IGameSystem[] systems;

        public GameSystemState(World world, IGameSystem[] systems)
        {
            this.systems = systems;

            foreach (var system in systems)
            {
                system.SetWorld(world);
            }
        }

        public override void Enter()
        {
            base.Enter();
            foreach (var system in systems)
            {
                system.RunInitialize();
            }
        }

        public override void Update()
        {
            base.Update();
            // Update all systems
            foreach (var system in systems)
            {
                if (system.IsEnabled)
                {
                    try
                    {
                        system.RunUpdate(Time.deltaTime);
                    }
                    catch (System.Exception e)
                    {
                        Debug.LogError($"Error in system {system.GetType().Name}: {e}");
                    }
                }
            }
        }

        public override void Exit()
        {
            // Clean up when leaving the state
            foreach (var system in systems)
            {
                system.RunCleanup();
            }
        }
    }
}

================
File: ECS_Principled/Functions/GameStateMachine/GameSystemState.cs.meta
================
fileFormatVersion: 2
guid: 70d840a9361baf046b6fc14875e496bf
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Functions/PreciseNoteCalculator.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    public static class PreciseNoteCalculator
    {
        /// <summary>
        /// Calculates the total song duration, in seconds, by summing the last
        /// note's appear time and duration.
        /// </summary>
        /// <param name="musicNoteMidiData">The parsed MIDI data to calculate the total duration from.</param>
        /// <returns>The total song duration, in seconds.</returns>
        ///
        public static float CalculateTotalSongDuration(MusicNoteMidiData musicNoteMidiData)
        {
            return musicNoteMidiData.TimeAppears[musicNoteMidiData.TotalNotes - 1]
                + musicNoteMidiData.Durations[musicNoteMidiData.TotalNotes - 1];
        }

        /// <summary>
        /// Finds the smallest note duration in the given MIDI data.
        /// </summary>
        /// <param name="musicNoteMidiData">The parsed MIDI data to find the smallest note duration from.</param>
        /// <param name="decimalPlaces">The number of decimal places to round the smallest duration to.</param>
        /// <returns>The smallest note duration, rounded to the specified number of decimal places.</returns>
        public static float FindSmallestNoteDuration(
            MusicNoteMidiData musicNoteMidiData,
            int decimalPlaces = 2
        )
        {
            if (musicNoteMidiData.TotalNotes == 0)
                return 0f;

            float smallestDuration = musicNoteMidiData.Durations[0];
            for (int i = 1; i < musicNoteMidiData.TotalNotes; i++)
            {
                smallestDuration = Mathf.Min(smallestDuration, musicNoteMidiData.Durations[i]);
            }

            return (float)Math.Round(smallestDuration, decimalPlaces);
        }

        /// <summary>
        /// Calculates the size of each note based on its duration compared to the smallest note duration.
        /// </summary>
        /// <param name="musicNoteMidiData">The parsed MIDI data to calculate the note sizes from.</param>
        /// <param name="baseSize">The base size of each note, to be scaled according to its duration.</param>
        /// <returns>An array of note sizes, where each size is relative to the smallest note duration.</returns>
        ///
        public static float[] CalculateNoteSizes(
            MusicNoteMidiData musicNoteMidiData,
            float baseSize = 2f
        )
        {
            float smallestDuration = FindSmallestNoteDuration(musicNoteMidiData, 2);
            float[] noteSizes = new float[musicNoteMidiData.TotalNotes];

            for (int i = 0; i < musicNoteMidiData.TotalNotes; i++)
            {
                noteSizes[i] = baseSize * (musicNoteMidiData.Durations[i] / smallestDuration);
            }

            return noteSizes;
        }

        public static float[] CalculateInitialPositions(
            MusicNoteMidiData midiData,
            float perfectLineY,
            float[] noteSizes,
            float baseSize = 2f
        )
        {
            float[] positions = new float[noteSizes.Length];
            if (noteSizes.Length == 0)
                return positions;

            // Position first note - add half its size to center point
            positions[0] = perfectLineY + (noteSizes[0] * 0.5f);
            float smallestDuration = FindSmallestNoteDuration(midiData, 2);

            // Position subsequent notes with proper gaps
            for (int i = 1; i < noteSizes.Length; i++)
            {
                // Start from previous note's center
                float pos = positions[i - 1];

                // Add half size of previous note (to get to its top)
                pos += noteSizes[i - 1] * 0.5f;

                // Calculate and add remaining gap space
                float remainingGap = midiData.Timespans[i] - midiData.Durations[i - 1];
                if (remainingGap > 0)
                {
                    // Convert time gap to space using velocity
                    float gapSpace = baseSize * (remainingGap / smallestDuration);
                    pos += gapSpace;
                }

                // Add half size of current note (to get to its center)
                pos += noteSizes[i] * 0.5f;

                positions[i] = pos;
            }

            return positions;
        }

        // Calculate road length from last note position and size
        public static float CalculateRoadLength(float[] noteSizes, MusicNoteMidiData midiData)
        {
            float totalLength = noteSizes[0]; // First note's size

            // Add subsequent notes' sizes and their gaps
            for (int i = 1; i < noteSizes.Length; i++)
            {
                // Add remaining gap space
                float remainingGap = midiData.Timespans[i] - midiData.Durations[i - 1];
                if (remainingGap > 0)
                {
                    // Estimate gap space relative to note sizes
                    float gapScale = remainingGap / midiData.Durations[i];
                    totalLength += noteSizes[i] * gapScale;
                }

                // Add current note's size
                totalLength += noteSizes[i];
            }

            return totalLength;
        }

        // Calculate velocity based on road length and total time
        public static float CalculateRequiredVelocity(float totalTime, float roadLength)
        {
            if (totalTime <= 0f)
                return 0f;
            return roadLength / totalTime;
        }
    }
}

================
File: ECS_Principled/Functions/PreciseNoteCalculator.cs.meta
================
fileFormatVersion: 2
guid: 0e15eb8261a3ad94583181063bec9b20
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts.meta
================
fileFormatVersion: 2
guid: eca84261f4209ea438546467839df383
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/AudioManager.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class AudioManager : MonoBehaviour
    {
        [SerializeField]
        private EmptyEventChannel onSongStartChannel;

        [SerializeField]
        private AudioClip audioClip;

        private AudioSource audioSource;

        void Start()
        {
            audioSource = GetComponent<AudioSource>();
            audioSource.clip = audioClip;
        }

        void OnEnable()
        {
            onSongStartChannel.Subscribe(OnGameStart);
        }

        private void OnGameStart(EmptyData data)
        {
            audioSource.PlayWithFadeIn(this, .8f);
        }
    }
}

================
File: ECS_Principled/MonoScripts/AudioManager.cs.meta
================
fileFormatVersion: 2
guid: 1a6eec2221ddc4ba2aadd917abe77374
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/BurstMovement.cs
================
using UnityEngine;

/// <summary>
/// Implements a customizable burst movement behavior where an object accelerates to a maximum speed,
/// maintains that speed for a configurable distance, then smoothly decelerates to a stop.
/// The movement uses exponential functions to create natural-feeling acceleration and deceleration.
/// </summary>
/// <remarks>
/// The movement is divided into two phases:
/// 1. Burst Phase: Object accelerates from initial speed to max speed using a smooth exponential curve
/// 2. Deceleration Phase: Object gradually slows down to a stop using natural exponential decay
///
/// Mathematical formulas used:
/// - Acceleration: speed = maxSpeed * (initialPercent + (1-initialPercent) * (1-e^(-aF * x)))
/// - Deceleration: speed = maxSpeed * e^(-dF * x)
/// Where:
/// - aF = acceleration factor
/// - dF = deceleration factor
/// - x = progress (0 to 1) in current phase
/// </remarks>
public class BurstMovement : MonoBehaviour
{
    [Header("Movement Properties")]
    [SerializeField]
    private Vector3 direction = Vector3.forward;

    [SerializeField]
    private float maxDistance = 10f;

    [Header("Speed Properties")]
    [SerializeField]
    private float maxSpeed = 10f;

    [SerializeField, Range(0.5f, 5f)]
    private float accelerationFactor = 2f;

    [SerializeField, Range(0.5f, 5f)]
    private float decelerationFactor = 1.5f;

    [Header("Burst Configuration")]
    [SerializeField, Range(0f, 100f)]
    private float burstEndPercentage = 50f;

    [SerializeField, Range(0f, 1f)]
    private float initialSpeedPercent = 0.1f;

    private Vector3 startPosition;
    private float currentSpeed;
    private bool hasStarted;

    /// <summary>
    /// Initializes the movement component by storing the starting position and normalizing the direction vector.
    /// </summary>
    private void Start()
    {
        startPosition = transform.position;
        direction = direction.normalized;
        hasStarted = true;

        Debug.Log(
            $"=== Initial Parameters ===\n"
                + $"Max Speed: {maxSpeed}\n"
                + $"Max Distance: {maxDistance}\n"
                + $"Acceleration Factor: {accelerationFactor}\n"
                + $"Deceleration Factor: {decelerationFactor}\n"
                + $"Direction: {direction}"
        );
    }

    /// <summary>
    /// Updates the object's position each frame based on the current movement phase and calculated speed.
    /// Handles progression through acceleration and deceleration phases until reaching the target distance.
    /// </summary>
    private void Update()
    {
        if (!hasStarted)
            return;

        float distanceTraveled = Vector3.Distance(transform.position, startPosition);
        float distancePercentage = (distanceTraveled / maxDistance) * 100f;

        if (distancePercentage >= 100f)
        {
            hasStarted = false;
            return;
        }

        currentSpeed = CalculateSpeed(distancePercentage);
        transform.position += direction * (currentSpeed * Time.deltaTime);
    }

    /// <summary>
    /// Calculates the current speed based on the percentage of total distance traveled.
    /// Uses different mathematical formulas for acceleration and deceleration phases.
    /// </summary>
    /// <param name="distancePercentage">Current distance traveled as a percentage (0-100) of total distance</param>
    /// <returns>The calculated speed for the current frame</returns>
    /// <remarks>
    /// During acceleration (0% to burstEndPercentage):
    /// - Starts at initialSpeedPercent of maxSpeed
    /// - Smoothly accelerates to maxSpeed using exponential approach
    ///
    /// During deceleration (burstEndPercentage to 100%):
    /// - Starts at maxSpeed
    /// - Exponentially decays to zero
    /// </remarks>
    private float CalculateSpeed(float distancePercentage)
    {
        // Acceleration phase
        if (distancePercentage <= burstEndPercentage)
        {
            float accelerationProgress = distancePercentage / burstEndPercentage;
            return maxSpeed
                * (
                    initialSpeedPercent
                    + (1f - initialSpeedPercent)
                        * (1f - Mathf.Exp(-accelerationFactor * accelerationProgress))
                );
        }
        // Deceleration phase
        else
        {
            float decelerationProgress =
                (distancePercentage - burstEndPercentage) / (100f - burstEndPercentage);
            return maxSpeed * Mathf.Exp(-decelerationFactor * decelerationProgress);
        }
    }

    /// <summary>
    /// Draws debug visualization in the Scene view to help understand the movement path and progress.
    /// </summary>
    private void OnDrawGizmos()
    {
        if (!Application.isPlaying)
            return;

        // Draw the full path
        Gizmos.color = Color.yellow;
        Gizmos.DrawLine(startPosition, startPosition + direction * maxDistance);

        // Draw burst end point
        Vector3 burstEndPoint =
            startPosition + direction * (maxDistance * burstEndPercentage / 100f);
        Gizmos.color = Color.blue;
        Gizmos.DrawWireSphere(burstEndPoint, 0.3f);

        // Draw current position
        Gizmos.color = Color.green;
        Gizmos.DrawWireSphere(transform.position, 0.2f);
    }
}

================
File: ECS_Principled/MonoScripts/BurstMovement.cs.meta
================
fileFormatVersion: 2
guid: 8e0f7f48d9c2e439db3417617e6b029a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/BurstMovementUIController.cs
================
using System.Linq;
using UnityEngine;

/// <summary>
/// A system-like controller that manages multiple UI elements with burst movement behavior.
/// This controller follows ECS principles by separating data (BurstMovementData) from behavior
/// while maintaining MonoBehaviour compatibility.
/// </summary>
/// <remarks>
/// The burst movement creates a dynamic motion effect where elements:
/// 1. Start with an initial speed
/// 2. Accelerate smoothly to maximum speed
/// 3. Maintain that speed for a configurable distance
/// 4. Decelerate naturally to a stop
///
/// The controller processes all movements in batches for better performance
/// and provides default values that can be overridden per element.
/// </remarks>
public class BurstMovementUIController : MonoBehaviour
{
    private BurstMovementElement[] movementElements;

    [Header("Default Values")]
    [SerializeField]
    private float defaultMaxSpeed = 500f;

    [SerializeField]
    private float defaultAccelerationFactor = 2f;

    [SerializeField]
    private float defaultDecelerationFactor = 1.5f;

    [SerializeField]
    private float defaultBurstEndPercentage = 50f;

    [SerializeField]
    private float defaultInitialSpeedPercent = 0.1f;

    private Vector2[] cachedStartPosition;

    /// <summary>
    /// Initializes all movement elements when the controller starts.
    /// Sets up initial positions and applies default values where needed.
    /// </summary>
    public void InitializeElement(BurstMovementElement[] burstMovementElements)
    {
        movementElements = burstMovementElements;
        cachedStartPosition = new Vector2[movementElements.Length];
        int index = 0;
        foreach (var element in movementElements)
        {
            // Store initial position and normalize direction for consistent movement
            element.data.startPosition = element.target.anchoredPosition;
            element.data.direction = element.data.direction.normalized;
            element.data.hasStarted = true;
            element.data.isFinished = false;
            cachedStartPosition[index] = element.target.anchoredPosition;
            index++;

            ApplyDefaultsIfNeeded(ref element.data);
        }
        //Make all elements not move at start
        StopAll();
    }

    /// <summary>
    /// Applies default values to any unset or invalid movement parameters.
    /// This ensures all elements have valid movement settings even if not explicitly configured.
    /// </summary>
    /// <param name="data">Reference to the movement data to validate and update</param>
    private void ApplyDefaultsIfNeeded(ref BurstMovementData data)
    {
        if (data.maxSpeed <= 0)
            data.maxSpeed = defaultMaxSpeed;
        if (data.accelerationFactor <= 0)
            data.accelerationFactor = defaultAccelerationFactor;
        if (data.decelerationFactor <= 0)
            data.decelerationFactor = defaultDecelerationFactor;
        if (data.burstEndPercentage <= 0)
            data.burstEndPercentage = defaultBurstEndPercentage;
        if (data.initialSpeedPercent <= 0)
            data.initialSpeedPercent = defaultInitialSpeedPercent;
    }

    /// <summary>
    /// Processes movement updates for all active elements each frame.
    /// Follows a system-like approach by batch processing all movements.
    /// </summary>
    private void Update()
    {
        if (movementElements.Length == 0)
            return;

        foreach (var element in movementElements)
        {
            if (!element.data.hasStarted || element.data.isFinished)
                continue;
            ProcessMovement(element);
        }
    }

    /// <summary>
    /// Updates the position of a single movement element based on its current state and configuration.
    /// </summary>
    /// <param name="element">The movement element to process</param>
    private void ProcessMovement(BurstMovementElement element)
    {
        // Calculate how far we've moved as a percentage of total distance
        float distanceTraveled = Vector2.Distance(
            element.target.anchoredPosition,
            element.data.startPosition
        );
        float distancePercentage = (distanceTraveled / element.data.maxDistance) * 100f;

        // Check if we've reached our destination
        if (distancePercentage >= 100f)
        {
            element.data.isFinished = true;
            return;
        }

        // Calculate and apply movement for this frame
        element.data.currentSpeed = CalculateSpeed(distancePercentage, element.data);
        Vector2 newPosition =
            (Vector2)element.target.anchoredPosition
            + element.data.direction * (element.data.currentSpeed * Time.deltaTime);

        element.target.anchoredPosition = newPosition;
    }

    /// <summary>
    /// Calculates the current speed based on distance percentage using exponential curves
    /// for smooth acceleration and deceleration.
    /// </summary>
    /// <param name="distancePercentage">Current distance as percentage of total (0-100)</param>
    /// <param name="data">Movement configuration data</param>
    /// <returns>The calculated speed for the current frame</returns>
    /// <remarks>
    /// The speed calculation uses two different exponential curves:
    /// - Acceleration: speed = maxSpeed * (initial + (1-initial) * (1-e^(-aF * x)))
    /// - Deceleration: speed = maxSpeed * e^(-dF * x)
    /// Where:
    /// - aF = acceleration factor
    /// - dF = deceleration factor
    /// - x = progress (0 to 1) in current phase
    /// </remarks>
    private float CalculateSpeed(float distancePercentage, BurstMovementData data)
    {
        // Acceleration phase
        if (distancePercentage <= data.burstEndPercentage)
        {
            float accelerationProgress = distancePercentage / data.burstEndPercentage;
            // Use exponential approach for smooth acceleration
            return data.maxSpeed
                * (
                    data.initialSpeedPercent
                    + (1f - data.initialSpeedPercent)
                        * (1f - Mathf.Exp(-data.accelerationFactor * accelerationProgress))
                );
        }
        // Deceleration phase
        else
        {
            float decelerationProgress =
                (distancePercentage - data.burstEndPercentage) / (100f - data.burstEndPercentage);
            // Use exponential decay for natural-feeling deceleration
            return data.maxSpeed * Mathf.Exp(-data.decelerationFactor * decelerationProgress);
        }
    }

    /// <summary>
    /// Starts movement for all elements in the controller.
    /// </summary>
    public void StartAll()
    {
        foreach (var element in movementElements)
        {
            element.data.hasStarted = true;
            element.data.isFinished = false;
        }
    }

    /// <summary>
    /// Stops movement for all elements in the controller.
    /// </summary>
    public void StopAll()
    {
        foreach (var element in movementElements)
        {
            element.data.hasStarted = false;
        }
    }

    public void ResetAll()
    {
        for (int i = 0; i < cachedStartPosition.Length; i++)
        {
            movementElements[i].target.anchoredPosition = cachedStartPosition[i];
        }
    }

    /// <summary>
    /// Represents the configuration and runtime data for a single burst movement.
    /// Separates data from behavior following ECS principles.
    /// </summary>
    [System.Serializable]
    public struct BurstMovementData
    {
        public Vector2 direction; // Movement direction (will be normalized)
        public float maxDistance; // Total distance to travel

        public float maxSpeed; // Maximum movement speed during burst

        [Range(0.5f, 5)]
        public float accelerationFactor; // Controls how quickly max speed is reached

        [Range(0.5f, 5)]
        public float decelerationFactor; // Controls how quickly speed reduces after burst

        [Range(0f, 70f)]
        public float burstEndPercentage; // When to transition from burst to deceleration (% of total distance)

        [Range(0, 1)]
        public float initialSpeedPercent; // Starting speed as percentage of max speed

        // Runtime data - hidden from inspector
        [HideInInspector]
        public Vector2 startPosition;

        [HideInInspector]
        public float currentSpeed;

        [HideInInspector]
        public bool hasStarted;

        [HideInInspector]
        public bool isFinished;
    }

    /// <summary>
    /// Combines a UI element target with its movement configuration.
    /// </summary>
    [System.Serializable]
    public class BurstMovementElement
    {
        public RectTransform target; // The UI element to move
        public BurstMovementData data; // Movement configuration and runtime data
    }
}

================
File: ECS_Principled/MonoScripts/BurstMovementUIController.cs.meta
================
fileFormatVersion: 2
guid: 16ca30dd2c053408ca1f8899ec5e4e9e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/CrownTween.cs
================
using Facade.Tweening;
// using PrimeTween;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class CrownTween : MonoBehaviour
    {
        // Helper method to convert PrimeTween.Ease values to our facade's EaseType
        private EaseType ConvertEase(int primeEase)
        {
            // Map the integer values from PrimeTween.Ease to our EaseType
            switch (primeEase)
            {
                case 1:
                    return EaseType.Linear;
                case 2:
                    return EaseType.InSine;
                case 3:
                    return EaseType.OutSine;
                case 4:
                    return EaseType.InOutSine;
                case 5:
                    return EaseType.InQuad;
                case 6:
                    return EaseType.OutQuad;
                case 7:
                    return EaseType.OutCubic;
                case 10:
                    return EaseType.InOutCubic;
                // Add more mappings as needed
                default:
                    return EaseType.Linear;
            }
        }

        [SerializeField]
        private CrownProperties defaultValue;
        private CrownProperties[] crowns;
        private CrownProperties currentCrown;
        private int currentCrownIndexToProcess;

        public void InitializeCrowns(CrownProperties[] crownProperties)
        {
            this.crowns = crownProperties;
            currentCrownIndexToProcess = 0;
            Color color;

            for (int i = 0; i < crowns.Length; i++)
            {
                color = crowns[i].crownAwakenedImg.color;
                color.a = 0;
                ;
                crowns[i].crownAwakenedImg.color = color;
            }
        }

        public void PlayEffect()
        {
            currentCrown = crowns[currentCrownIndexToProcess];

            // Create a sequence for all tweens
            ISequence sequence = Tweener.Sequence();

            // First phase - all animations in parallel
            var firstPhaseScale = Tweener
                .DoScale(
                    target: currentCrown.crownRect,
                    startValue: currentCrown.scaleStartValue,
                    endValue: currentCrown.scaleMidValue,
                    duration: currentCrown.firstPhaseDuration
                )
                .SetEase(ConvertEase(currentCrown.firstPhaseEase));

            var firstPhaseImageScale = Tweener
                .DoScale(
                    target: currentCrown.crownAwakenedImg.rectTransform,
                    startValue: currentCrown.awakenedScaleStart,
                    endValue: currentCrown.awakenedScaleMid,
                    duration: currentCrown.firstPhaseDuration
                )
                .SetEase(ConvertEase(currentCrown.firstPhaseEase));

            var firstPhaseAlpha = Tweener
                .DoFade(
                    target: currentCrown.crownAwakenedImg,
                    startValue: currentCrown.alphaStart,
                    endValue: currentCrown.alphaMid,
                    duration: currentCrown.firstPhaseDuration
                )
                .SetEase(ConvertEase(currentCrown.firstPhaseEase));

            // Add all first phase animations to sequence
            sequence.Chain(firstPhaseScale);
            sequence.Join(firstPhaseImageScale);
            sequence.Join(firstPhaseAlpha);

            // Second phase - all animations in parallel
            var secondPhaseScale = Tweener
                .DoScale(
                    target: currentCrown.crownRect,
                    endValue: currentCrown.scaleEndValue,
                    duration: currentCrown.secondPhaseDuration
                )
                .SetEase(ConvertEase(currentCrown.secondPhaseEase));

            var secondPhaseImageScale = Tweener
                .DoScale(
                    target: currentCrown.crownAwakenedImg.rectTransform,
                    endValue: currentCrown.awakenedScaleEnd,
                    duration: currentCrown.secondPhaseDuration
                )
                .SetEase(ConvertEase(currentCrown.secondPhaseEase));

            var secondPhaseAlpha = Tweener
                .DoFade(
                    target: currentCrown.crownAwakenedImg,
                    endValue: currentCrown.alphaEnd,
                    duration: currentCrown.secondPhaseDuration
                )
                .SetEase(ConvertEase(currentCrown.secondPhaseEase));

            // Add all second phase animations to sequence
            sequence.Chain(secondPhaseScale);
            sequence.Join(secondPhaseImageScale);
            sequence.Join(secondPhaseAlpha);

            currentCrownIndexToProcess++;
        }

        public bool IsAbleToPlay()
        {
            return currentCrownIndexToProcess < crowns.Length;
        }

        [System.Serializable]
        public class CrownProperties
        {
            [Header("Crown")]
            public RectTransform crownRect;
            public Image crownAwakenedImg;

            [Header("Scale properties")]
            public float scaleStartValue = 1f;
            public float scaleMidValue = 1.5f;
            public float scaleEndValue = 1f;

            [Header("Image awakened alpha properties")]
            public float awakenedScaleStart = 1f;
            public float awakenedScaleMid = 1.8f;
            public float awakenedScaleEnd = 1;
            public float alphaStart = 0;
            public float alphaMid = .5f;
            public float alphaEnd = 1f;

            [Header("Phase paremeters")]
            public float firstPhaseDuration = .4f;
            public int firstPhaseEase = 7; // Was Ease.OutCubic
            public float secondPhaseDuration = .2f;
            public int secondPhaseEase = 1; // Was Ease.Linear
        }
    }
}

================
File: ECS_Principled/MonoScripts/CrownTween.cs.meta
================
fileFormatVersion: 2
guid: 393ae28e0cc2e064691c4148f9fa023e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/EffectOnProgress.cs
================
using Facade.Tweening;
using UnityEngine;

namespace ECS_MagicTile
{
    public class EffectOnProgress : MonoBehaviour
    {
        [SerializeField]
        private Vector2 startScale;

        [SerializeField]
        private Vector2 endScale;

        [SerializeField]
        private float duration;
        private RectTransform rectTransform;

        void Awake()
        {
            rectTransform = GetComponent<RectTransform>();
        }

        void Start()
        {
            // Sequence
            //     .Create(cycles: -1)
            //     .Chain(
            //         Tween.Scale(
            //             target: rectTransform,
            //             startValue: startScale,
            //             endValue: endScale,
            //             duration: duration,
            //             ease: Ease.Linear
            //         )
            //     )
            //     .Chain(
            //         Tween.Scale(
            //             target: rectTransform,
            //             endValue: startScale,
            //             duration: duration,
            //             ease: Ease.Linear
            //         )
            //     );

            Tweener
                .Sequence()
                .Chain(
                    Tweener
                        .DoScale(rectTransform, startScale, endScale, duration)
                        .SetEase(EaseType.Linear)
                )
                .Chain(
                    Tweener.DoScale(rectTransform, startScale, duration).SetEase(EaseType.Linear)
                )
                .SetLoops(-1);
        }
    }
}

================
File: ECS_Principled/MonoScripts/EffectOnProgress.cs.meta
================
fileFormatVersion: 2
guid: 5bb97036fc31048bc8738dc49725bd85
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/ProgressEffectController.cs
================
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    [RequireComponent(typeof(StarTween))]
    [RequireComponent(typeof(CrownTween))]
    public class ProgressEffectController : MonoBehaviour
    {
        [SerializeField]
        private Slider progressSlider;

        [SerializeField]
        private RectTransform[] progressPoints;

        [SerializeField]
        private StarTween.StarProperties[] starPoints;

        [SerializeField]
        private CrownTween.CrownProperties[] crownPoints;

        private RectTransform progressSliderRect;

        private float[] segmentValues;

        private int currentPassedSegmentPoint;

        private StarTween starTween;
        private CrownTween crownTween;

        void Awake()
        {
            starTween = GetComponent<StarTween>();
            starTween.InitializeStars(starPoints);

            crownTween = GetComponent<CrownTween>();
            crownTween.InitializeCrowns(crownPoints);
        }

        void OnEnable()
        {
            progressSlider.onValueChanged.AddListener(OnProgressValueChanged);
        }

        void OnDisable()
        {
            progressSlider.onValueChanged.RemoveListener(OnProgressValueChanged);
        }

        void Start()
        {
            SetupPoints();
        }

        void OnValidate()
        {
            SetupPoints();
        }

        private void SetupPoints()
        {
            if (progressPoints.Length == 0 || progressSlider == null)
            {
                return;
            }

            if (progressSliderRect == null)
            {
                progressSliderRect = progressSlider.GetComponent<RectTransform>();
            }

            int pointCount = progressPoints.Length;
            float sliderWidth = progressSliderRect.sizeDelta.x;
            float segmentWidth = sliderWidth / pointCount;
            float baseSegmentValue = 1f / pointCount;

            segmentValues = new float[pointCount];

            for (int i = 0; i < progressPoints.Length; i++)
            {
                if (progressPoints[i] == null)
                    continue;
                progressPoints[i].anchoredPosition = new Vector2(
                    segmentWidth * (i + 1),
                    progressPoints[i].anchoredPosition.y
                );

                segmentValues[i] = (i + 1) * baseSegmentValue;
            }

            currentPassedSegmentPoint = 1;
        }

        private void OnProgressValueChanged(float value)
        {
            int index = currentPassedSegmentPoint - 1;

            if (value >= segmentValues[index])
            {
                if (starTween.IsAbleToPlay())
                {
                    starTween.PlayEffect();
                }
                else if (crownTween.IsAbleToPlay())
                {
                    crownTween.PlayEffect();
                }

                currentPassedSegmentPoint++;
            }
        }
    }
}

================
File: ECS_Principled/MonoScripts/ProgressEffectController.cs.meta
================
fileFormatVersion: 2
guid: 674545824a7a6ba4da646968bb607983
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/RaycastToObjects.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class RaycastToStartGame : MonoBehaviour
    {
        [SerializeField]
        private LayerMask targetLayer;

        [SerializeField]
        private IntEventChannel OnGameStartChannel;

        // Update is called once per frame
        void Update()
        {
            if (Input.GetMouseButtonDown(0))
            {
                FireRaycast();
            }
        }

        private void FireRaycast()
        {
            Vector2 mousePosition = Camera.main.ScreenToWorldPoint(Input.mousePosition);
            RaycastHit2D hit = Physics2D.Raycast(
                mousePosition,
                Vector2.zero,
                Mathf.Infinity,
                targetLayer
            );

            if (hit.collider != null)
            {
                if (hit.collider.tag == "StartNote")
                {
                    OnGameStartChannel?.RaiseEvent(
                        hit.collider.GetComponent<IEntityHolder>().EntityId
                    );
                }
            }
            else
            {
                Debug.Log("No object hit.");
            }
        }
    }
}

================
File: ECS_Principled/MonoScripts/RaycastToObjects.cs.meta
================
fileFormatVersion: 2
guid: 2b6518ec189777e4cbad7fdd60b44c76
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/ScoreEffectController.cs
================
using EventChannel;
using Facade.Tweening;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ScoreEffectController : MonoBehaviour
    {
        [Header("Event Channels")]
        [SerializeField]
        private BoolEventChannel scoreSignalEffectChannel;

        [Header("Main Effect components")]
        [SerializeField]
        private CanvasGroup perfectScorePrefab;

        [SerializeField]
        private CanvasGroup greatScorePrefab;

        [Header("Burst Movement Setup")]
        [SerializeField]
        private BurstMovementUIController burstMovementUIController;

        [SerializeField]
        private BurstMovementUIController.BurstMovementElement[] burstMovementElements;
        private ISequence effectSequence;

        void Awake()
        {
            burstMovementUIController.InitializeElement(burstMovementElements);
        }

        void OnEnable()
        {
            scoreSignalEffectChannel.Subscribe(PlayEffect);
        }

        void OnDisable()
        {
            scoreSignalEffectChannel.Unsubscribe(PlayEffect);
        }

        private void PlayEffect(bool isPerfect)
        {
            effectSequence?.Kill();
            effectSequence = Tweener.Sequence();

            burstMovementUIController?.ResetAll();
            burstMovementUIController?.StartAll();
            perfectScorePrefab.alpha = 1;

            for (int i = 1; i < burstMovementElements.Length; i++)
            {
                burstMovementElements[i].target.rotation = Quaternion.Euler(
                    0,
                    0,
                    UnityEngine.Random.Range(0, 360)
                );
            }

            // effectSequence = Tween
            //     .Scale(
            //         target: perfectScorePrefab.transform,
            //         startValue: Vector3.zero,
            //         endValue: Vector3.one,
            //         duration: 0.2f,
            //         ease: Ease.Linear
            //     )
            //     .Chain(
            //         Tween
            //             .Delay(duration: 0.5f)
            //             .Chain(
            //                 Tween
            //                     .Alpha(
            //                         target: perfectScorePrefab,
            //                         startValue: 1f,
            //                         endValue: 0f,
            //                         duration: 0.5f,
            //                         ease: Ease.Linear
            //                     )
            //                     .OnComplete(() =>
            //                     {
            //                         burstMovementUIController.StopAll();
            //                     })
            //             )
            //     );

            effectSequence
                .Chain(
                    Tweener
                        .DoScale(
                            target: perfectScorePrefab.transform,
                            startValue: Vector3.zero,
                            endValue: Vector3.one,
                            duration: 0.2f
                        )
                        .SetEase(EaseType.Linear)
                )
                .Delay(interval: .5f)
                .Chain(
                    Tweener
                        .DoFade(
                            target: perfectScorePrefab,
                            startValue: 1f,
                            endValue: 0f,
                            duration: 0.5f
                        )
                        .OnComplete(() =>
                        {
                            burstMovementUIController.StopAll();
                        })
                );
        }
    }
}

================
File: ECS_Principled/MonoScripts/ScoreEffectController.cs.meta
================
fileFormatVersion: 2
guid: 4c404b5dc2d1b3243807aa10259f386a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/ScreenManager.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ScreenManager : PersistentSingleton<ScreenManager>
    {
        [SerializeField]
        private BoolEventChannel OnOrientationChange;

        public bool IsPortrait { get; private set; }

        void Start()
        {
            IsPortrait = Screen.currentResolution.width > Screen.currentResolution.height;
        }

        private void Update()
        {
            if (Screen.currentResolution.width < Screen.currentResolution.height)
            {
                if (!IsPortrait)
                {
                    IsPortrait = true;
                    OnOrientationChange.RaiseEvent(true);
                }
            }
            else
            {
                if (IsPortrait)
                {
                    IsPortrait = false;
                    OnOrientationChange.RaiseEvent(false);
                }
            }
        }
    }
}

================
File: ECS_Principled/MonoScripts/ScreenManager.cs.meta
================
fileFormatVersion: 2
guid: b5f3dbf897bb5481aa2da1550e237f93
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/StarTween.cs
================
using System;
using Facade.Tweening;
// using PrimeTween;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class StarTween : MonoBehaviour
    {
        // Helper method to convert PrimeTween.Ease values to our facade's EaseType
        private EaseType ConvertEase(int primeEase)
        {
            // Map the integer values from PrimeTween.Ease to our EaseType
            switch (primeEase)
            {
                case 1:
                    return EaseType.Linear;
                case 2:
                    return EaseType.InSine;
                case 3:
                    return EaseType.OutSine;
                case 4:
                    return EaseType.InOutSine;
                case 5:
                    return EaseType.InQuad;
                case 6:
                    return EaseType.OutQuad;
                case 7:
                    return EaseType.OutCubic;
                case 10:
                    return EaseType.InOutCubic;
                // Add more mappings as needed
                default:
                    return EaseType.Linear;
            }
        }

        [SerializeField]
        private StarProperties defaultValue;
        private StarProperties[] stars;
        private int currentStarIndexToProcess;

        StarProperties currentStar;

        private ISequence sequence;

        public void InitializeStars(StarProperties[] stars)
        {
            this.stars = stars;
            currentStarIndexToProcess = 0;
            Color color;
            for (int i = 0; i < stars.Length; i++)
            {
                color = stars[i].starAwakenedImg.color;
                color.a = 0;
                ;
                stars[i].starAwakenedImg.color = color;
            }
        }

        public void PlayEffect()
        {
            sequence?.Kill();
            sequence = Tweener.Sequence();

            currentStar = stars[currentStarIndexToProcess];
            Debug.Log($"Play Effect of {currentStar.starAwakenedImg.name}");

            sequence
                .Chain(
                    Tweener
                        .DoScale(
                            target: currentStar.starRect,
                            startValue: currentStar.scaleStartValue,
                            endValue: currentStar.scaleMidValue,
                            duration: currentStar.firstPhaseDuration
                        )
                        .SetEase(currentStar.firstPhaseEase)
                )
                .Join(
                    Tweener
                        .DoRotate(
                            target: currentStar.starRect,
                            startValue: currentStar.rotationStartValue,
                            endValue: currentStar.rotationMidValue,
                            duration: currentStar.firstPhaseDuration
                        )
                        .SetEase(currentStar.firstPhaseEase)
                )
                .Join(
                    Tweener
                        .DoFade(
                            target: currentStar.starAwakenedImg,
                            startValue: currentStar.alphaStart,
                            endValue: currentStar.alphaMid,
                            duration: currentStar.firstPhaseDuration
                        )
                        .SetEase(currentStar.firstPhaseEase)
                )
                .Join(
                    Tweener
                        .DoScale(
                            target: currentStar.starAwakenedImg.rectTransform,
                            startValue: currentStar.awakenedScaleStart,
                            endValue: currentStar.awakenedScaleMid,
                            duration: currentStar.firstPhaseDuration
                        )
                        .SetEase(currentStar.firstPhaseEase)
                )
                .Chain(
                    Tweener
                        .DoScale(
                            target: currentStar.starRect,
                            endValue: currentStar.scaleEndValue,
                            duration: currentStar.secondPhaseDuration
                        )
                        .SetEase(currentStar.secondPhaseEase)
                )
                .Join(
                    Tweener
                        .DoRotate(
                            target: currentStar.starRect,
                            endValue: currentStar.rotationEndValue,
                            duration: currentStar.secondPhaseDuration
                        )
                        .SetEase(currentStar.secondPhaseEase)
                )
                .Join(
                    Tweener
                        .DoFade(
                            target: currentStar.starAwakenedImg,
                            endValue: currentStar.alphaEnd,
                            duration: currentStar.secondPhaseDuration
                        )
                        .SetEase(currentStar.secondPhaseEase)
                )
                .Join(
                    Tweener
                        .DoScale(
                            target: currentStar.starAwakenedImg.rectTransform,
                            endValue: currentStar.awakenedScaleEnd,
                            duration: currentStar.secondPhaseDuration
                        )
                        .SetEase(currentStar.secondPhaseEase)
                );

            currentStarIndexToProcess++;
        }

        public bool IsAbleToPlay()
        {
            return currentStarIndexToProcess < stars.Length;
        }

        [Serializable]
        public class StarProperties
        {
            [Header("Star")]
            public RectTransform starRect;
            public Image starAwakenedImg;

            [Header("Scale properties")]
            public float scaleStartValue = 1f;
            public float scaleMidValue = 1.5f;
            public float scaleEndValue = 1f;

            [Header("Rotation properties")]
            public Vector3 rotationStartValue = new Vector3(0, 0, -180);
            public Vector3 rotationMidValue = new Vector3(0, 0, -240);
            public Vector3 rotationEndValue = new Vector3(0, 0, -360);

            [Header("Image awakened alpha properties")]
            public float awakenedScaleStart = 1f;
            public float awakenedScaleMid = 1.8f;
            public float awakenedScaleEnd = 1;
            public float alphaStart = 0;
            public float alphaMid = .5f;
            public float alphaEnd = 1f;

            [Header("Phase paremeters")]
            public float firstPhaseDuration = .4f;
            public EaseType firstPhaseEase = EaseType.OutCubic; // Was Ease.OutCubic
            public float secondPhaseDuration = .2f;
            public EaseType secondPhaseEase = EaseType.Linear; // Was Ease.Linear
        }
    }
}

================
File: ECS_Principled/MonoScripts/StarTween.cs.meta
================
fileFormatVersion: 2
guid: 6510a45b25480bc44839f20bff11111d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/MonoScripts/VerticalLineSetup.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    public class VerticalLineSetup : MonoBehaviour
    {
        private RectTransform[] verticalLines;
    }
}

================
File: ECS_Principled/MonoScripts/VerticalLineSetup.cs.meta
================
fileFormatVersion: 2
guid: a2bf9baa3aab15a4da083e100b25e8d4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings.meta
================
fileFormatVersion: 2
guid: 27da12294979945e1b5cbf9800389eb4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/GeneralGameSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 24a2a689475a5aa4997e54b10cc3c33c, type: 3}
  m_Name: GeneralGameSetting_SO
  m_EditorClassIdentifier: 
  GameSpeed: 0

================
File: ECS_Principled/Settings/GeneralGameSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: cc747aeaca6f5864099880016a577e56
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/LaneLineSettings_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: bfcaf33992d1246beafffa977f1b7a56, type: 3}
  m_Name: LaneLineSettings_SO
  m_EditorClassIdentifier: 
  landLinePrefab: {fileID: 856688113385644598, guid: af74a368381e1114095acf0acae2ec78, type: 3}
  laneLineWidth:
    _value: 0.004

================
File: ECS_Principled/Settings/LaneLineSettings_SO.asset.meta
================
fileFormatVersion: 2
guid: 6a5958e8da5e84e76b82907765c02fbe
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/MusicNoteCreationSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a5af8e59dd796d941989a811a2c8754b, type: 3}
  m_Name: MusicNoteCreationSetting_SO
  m_EditorClassIdentifier: 
  UsePreciseNoteCalculation: 1
  MidiContent: {fileID: 4900000, guid: 5651cca0434e843a4af2569038996f88, type: 3}
  ShortNoteScaleYFactor: 2
  LongNoteScaleYFactor: 2.5
  startingNoteLane: 0
  LongTilePrefab: {fileID: 8137537297466452066, guid: 12f1ab7db8533406285c2148378e45d8, type: 3}
  ShortTilePrefab: {fileID: 8137537297466452066, guid: 8c1c272d019a341fa8cc13b90b199606, type: 3}
  startingNotePrefab: {fileID: 8137537297466452066, guid: 3ab92a42b30f7d440901bcd50afe0d58, type: 3}

================
File: ECS_Principled/Settings/MusicNoteCreationSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: 5d1ed20f8d24fbd4f95a64d2f692fb66
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/PerfectLineSetting_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 2794e685ab5b84c7299a27a309baa90b, type: 3}
  m_Name: PerfectLineSetting_SO
  m_EditorClassIdentifier: 
  portraitNormalizedPos:
    normalizedX:
      _value: 0.5
    normalizedY:
      _value: 0.3
  landscapeNormalizedPos:
    normalizedX:
      _value: 0.5
    normalizedY:
      _value: 0.3
  portraitNormalizedSize:
    normalizedX:
      _value: 1
    normalizedY:
      _value: 0.004
  landscapeNormalizedSize:
    normalizedX:
      _value: 0.5
    normalizedY:
      _value: 0.004

================
File: ECS_Principled/Settings/PerfectLineSetting_SO.asset.meta
================
fileFormatVersion: 2
guid: d1a21492714ea480f9449e5933a8acd1
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/ScoreEffectSettings_SO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 90b3ef9aef2e740baa6d7b0a8da6158d, type: 3}
  m_Name: ScoreEffectSettings_SO
  m_EditorClassIdentifier: 
  perfectScoreEffectPrefab: {fileID: 0}
  greatScoreEffectPrefab: {fileID: 0}

================
File: ECS_Principled/Settings/ScoreEffectSettings_SO.asset.meta
================
fileFormatVersion: 2
guid: 0fc1bf2a08ee74502af5a8c06e294b7f
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_InGameUIElementSetting.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 18fbe9db2a141f542a5dcf21799c3f95, type: 3}
  m_Name: SO_InGameUIElementSetting
  m_EditorClassIdentifier: 
  scoreUISettings:
    phonePortraitPos: {x: 0, y: -300}
    phoneLandscapePos: {x: 0, y: 0}
    tabletPortraitPos: {x: 0, y: 0}
    tabletLandscapePos: {x: 0, y: 0}
  songNameUISettings:
    songNameContent: Perfect
    phonePortraitPos: {x: 0, y: 0}
    phoneLandscapePos: {x: 0, y: 0}
    tabletPortraitPos: {x: 0, y: 0}
    tabletLandscapePos: {x: 0, y: 0}
  songAuthorUISettings:
    songAuthorContent: Ed Sheeran
    phonePortraitPos: {x: 0, y: 0}
    phoneLandscapePos: {x: 0, y: 0}
    tabletPortraitPos: {x: 0, y: 0}
    tabletLandscapePos: {x: 0, y: 0}
  highScoreUISettings:
    phonePortraitPos: {x: 0, y: 0}
    phoneLandscapePos: {x: 0, y: 0}
    tabletPortraitPos: {x: 0, y: 0}
    tabletLandscapePos: {x: 0, y: 0}
  decorationUISettings:
    phonePortraitPos: {x: 0, y: 0}
    phoneLandscapePos: {x: 0, y: 0}
    tabletPortraitPos: {x: 0, y: 0}
    tabletLandscapePos: {x: 0, y: 0}

================
File: ECS_Principled/Settings/SO_InGameUIElementSetting.asset.meta
================
fileFormatVersion: 2
guid: b34be04dc2a53ca40819dbccedcc6c2c
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts.meta
================
fileFormatVersion: 2
guid: ae204fe6d86024e5e910ea37c76036a1
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts/GeneralGameSetting.cs
================
using ECS_MagicTile;
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(fileName = "GeneralGameSetting_SO", menuName = "Settings/GeneralGameSetting")]
    public class GeneralGameSetting : ScriptableObject
    {
        public float GameSpeed;

        public float PreciseGameSpeed { get; set; }
        public EGameState CurrentGameState { get; set; } = EGameState.IngamePrestart;
    }
}

================
File: ECS_Principled/Settings/SO_SCripts/GeneralGameSetting.cs.meta
================
fileFormatVersion: 2
guid: 24a2a689475a5aa4997e54b10cc3c33c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts/InGameUIElementSetting.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(
        fileName = "SO_InGameUIElementSetting",
        menuName = "Settings/InGameUIElementSetting"
    )]
    public class InGameUIElementSetting : ScriptableObject
    {
        public ScoreUISettings scoreUISettings;
        public SongNameUISettings songNameUISettings;
        public SongAuthorUISettings songAuthorUISettings;
        public HighScoreUISettings highScoreUISettings;
        public DecorationUISettings decorationUISettings;

        [System.Serializable]
        public struct ScoreUISettings
        {
            public Vector2 phonePortraitPos;
            public Vector2 phoneLandscapePos;
            public Vector2 tabletPortraitPos;
            public Vector2 tabletLandscapePos;
        }

        [System.Serializable]
        public struct SongNameUISettings
        {
            public string songNameContent;
            public Vector2 phonePortraitPos;
            public Vector2 phoneLandscapePos;
            public Vector2 tabletPortraitPos;
            public Vector2 tabletLandscapePos;
        }

        [System.Serializable]
        public struct SongAuthorUISettings
        {
            public string songAuthorContent;
            public Vector2 phonePortraitPos;
            public Vector2 phoneLandscapePos;
            public Vector2 tabletPortraitPos;
            public Vector2 tabletLandscapePos;
        }

        [System.Serializable]
        public struct HighScoreUISettings
        {
            public Vector2 phonePortraitPos;
            public Vector2 phoneLandscapePos;
            public Vector2 tabletPortraitPos;
            public Vector2 tabletLandscapePos;
        }

        [System.Serializable]
        public struct DecorationUISettings
        {
            public Vector2 phonePortraitPos;
            public Vector2 phoneLandscapePos;
            public Vector2 tabletPortraitPos;
            public Vector2 tabletLandscapePos;
        }
    }
}

================
File: ECS_Principled/Settings/SO_SCripts/InGameUIElementSetting.cs.meta
================
fileFormatVersion: 2
guid: 18fbe9db2a141f542a5dcf21799c3f95

================
File: ECS_Principled/Settings/SO_SCripts/LaneLineSettings.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(fileName = "LaneLineSettings_SO", menuName = "Settings/LaneLineSettings")]
    public class LaneLineSettings : ScriptableObject
    {
        public GameObject landLinePrefab;

        public RangeReactiveFloat laneLineWidth;

        private void OnValidate()
        {
            laneLineWidth.OnChangeValidatedInInpsector();
        }
    }
}

================
File: ECS_Principled/Settings/SO_SCripts/LaneLineSettings.cs.meta
================
fileFormatVersion: 2
guid: bfcaf33992d1246beafffa977f1b7a56
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts/MidiNoteParser.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

public static class MidiNoteParser
{
    public static MusicNoteMidiData ParseFromText(string content)
    {
        if (string.IsNullOrEmpty(content))
            throw new MidiParseException("MIDI content cannot be empty");

        var entries = content.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

        if (entries.Length == 0)
            throw new MidiParseException("No valid MIDI entries found");

        // Split into note entries
        var data = new MusicNoteMidiData(entries.Length);

        for (int i = 0; i < entries.Length; i++)
        {
            try
            {
                ParseEntry(entries[i], i, ref data);
                data.TotalNotes++;
            }
            catch (Exception ex)
            {
                throw new MidiParseException($"Error parsing entry {i}: {ex.Message}");
            }
        }

        ValidateData(ref data);

        return data;
    }

    private static void ParseEntry(string entry, int index, ref MusicNoteMidiData data)
    {
        var properties = entry.Split('-');
        var requiredFields = new HashSet<string> { "id", "n", "ta", "ts", "d", "v", "pid" };
        var parsedFields = new HashSet<string>();

        foreach (var prop in properties)
        {
            var kv = prop.Split(':');
            if (kv.Length != 2)
                throw new MidiParseException($"Invalid property format: {prop}");

            if (!ParseProperty(kv[0], kv[1], index, ref data))
                throw new MidiParseException($"Failed to parse property: {kv[0]}");

            parsedFields.Add(kv[0]);
        }

        // Check for missing required fields
        requiredFields.ExceptWith(parsedFields);
        if (requiredFields.Count > 0)
            throw new MidiParseException(
                $"Missing required fields: {string.Join(", ", requiredFields)}"
            );
    }

    private static bool ParseProperty(
        string key,
        string value,
        int index,
        ref MusicNoteMidiData data
    )
    {
        try
        {
            switch (key)
            {
                case "id":
                    data.Ids[index] = int.Parse(value);
                    break;
                case "n":
                    data.NoteNumbers[index] = int.Parse(value);
                    break;
                case "ta":
                    data.TimeAppears[index] = float.Parse(value);
                    break;
                case "ts":
                    data.Timespans[index] = float.Parse(value);
                    break;
                case "d":
                    float duration = float.Parse(value);
                    data.Durations[index] = duration;
                    data.MinDuration = Mathf.Min(data.MinDuration, duration);
                    break;
                case "v":
                    data.Velocities[index] = float.Parse(value);
                    break;
                case "pid":
                    data.PositionIds[index] = int.Parse(value);
                    break;
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static void ValidateData(ref MusicNoteMidiData data)
    {
        if (data.MinDuration <= 0)
            throw new MidiParseException("Invalid minimum duration");

        if (data.TotalNotes <= 0)
            throw new MidiParseException("No valid notes parsed");
    }
}

public class MidiParseException : Exception
{
    public MidiParseException(string message)
        : base(message) { }
}

================
File: ECS_Principled/Settings/SO_SCripts/MidiNoteParser.cs.meta
================
fileFormatVersion: 2
guid: ccd8b8d0c202c4c46a3c94a768d54c37
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts/MusicNoteCreationSetting.cs
================
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(
        fileName = "MusicNoteCreationSetting_SO",
        menuName = "Settings/MusicNoteCreationSetting"
    )]
    public class MusicNoteCreationSetting : ScriptableObject
    {
        [Header("Note Calculation Mode")]
        public bool UsePreciseNoteCalculation;

        [Header("Song Data")]
        public TextAsset MidiContent;

        [Header("Note Configuration")]
        [Header("Portrait")]
        public float ShortNoteScaleYFactor;
        public float LongNoteScaleYFactor;
        public float startingNoteLane;

        [Header("Prefabs")]
        public GameObject LongTilePrefab;
        public GameObject ShortTilePrefab;
        public GameObject startingNotePrefab;
    }
}

================
File: ECS_Principled/Settings/SO_SCripts/MusicNoteCreationSetting.cs.meta
================
fileFormatVersion: 2
guid: a5af8e59dd796d941989a811a2c8754b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts/PerfectLineSetting.cs
================
using System;
using UnityEngine;

namespace ECS_MagicTile
{
    [CreateAssetMenu(
        fileName = "PerfectLineSetting_SO",
        menuName = "Settings/PerfectLineSetting_SO"
    )]
    public class PerfectLineSetting : ScriptableObject
    {
        [Header(" Normalize Positions")]
        public NormalizedFloatPreset portraitNormalizedPos;

        public NormalizedFloatPreset landscapeNormalizedPos;

        [Header("Normalized Size")]
        public NormalizedFloatPreset portraitNormalizedSize;

        public NormalizedFloatPreset landscapeNormalizedSize;

        [System.Serializable]
        public struct NormalizedFloatPreset
        {
            public RangeReactiveFloat normalizedX;

            public RangeReactiveFloat normalizedY;
        }

        private void OnValidate()
        {
            portraitNormalizedPos.normalizedX.OnChangeValidatedInInpsector();
            portraitNormalizedPos.normalizedY.OnChangeValidatedInInpsector();

            landscapeNormalizedPos.normalizedX.OnChangeValidatedInInpsector();
            landscapeNormalizedPos.normalizedY.OnChangeValidatedInInpsector();

            portraitNormalizedSize.normalizedX.OnChangeValidatedInInpsector();
            portraitNormalizedSize.normalizedY.OnChangeValidatedInInpsector();

            landscapeNormalizedSize.normalizedX.OnChangeValidatedInInpsector();
            landscapeNormalizedSize.normalizedY.OnChangeValidatedInInpsector();
        }
    }

    [Serializable]
    public class RangeReactiveFloat : ReactiveValue<float>
    {
        [Range(0, 1)]
        protected new float _value;
    }
}

================
File: ECS_Principled/Settings/SO_SCripts/PerfectLineSetting.cs.meta
================
fileFormatVersion: 2
guid: 2794e685ab5b84c7299a27a309baa90b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Settings/SO_SCripts/ScoreEffectSettings.cs
================
using UnityEngine;

namespace ECS_MagicTile.Settings
{
    [CreateAssetMenu(
        fileName = "ScoreEffectSettings_SO",
        menuName = "Settings/ScoreEffectSettings"
    )]
    public class ScoreEffectSettings : ScriptableObject
    {
        [Header("Perfect Score Effect")]
        public GameObject perfectScoreEffectPrefab;

        [Header("Great Score Prefab")]
        public GameObject greatScoreEffectPrefab;
    }
}

================
File: ECS_Principled/Settings/SO_SCripts/ScoreEffectSettings.cs.meta
================
fileFormatVersion: 2
guid: 90b3ef9aef2e740baa6d7b0a8da6158d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers.meta
================
fileFormatVersion: 2
guid: 200d0ba3dc7c04ac6920253abe6c74a4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/GameScoreSyncTool.cs
================
using ECS_MagicTile.Components;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class GameScoreSyncTool : BaseSyncTool
    {
        public GameScoreSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            scoreText = globalPoint.scoreText;
        }

        protected override Archetype Archetype => Archetype.Registry.GameScore;
        private readonly Text scoreText;

        public void SyncGameScore(ScoreComponent scoreComponent)
        {
            scoreText.text = $"Score: {scoreComponent.TotalScore}";
        }
    }
}

================
File: ECS_Principled/Syncers/GameScoreSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 0c8248051d057454891cb9aa519fe33f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/LaneLineSyncTool.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class LaneLineSyncTool : BaseSyncTool
    {
        public LaneLineSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            laneLineViewFactory = new EntityViewFactory(
                globalPoint.laneLineSettings.landLinePrefab,
                null
            );
        }

        protected override Archetype Archetype => Archetype.Registry.LaneLines;

        public SpriteRenderer[] LaneLineSprites => laneLineSprites;

        private readonly EntityViewFactory laneLineViewFactory;
        private SpriteRenderer[] laneLineSprites;

        public override void InitializeTool()
        {
            base.InitializeTool();
            laneLineSprites = new SpriteRenderer[DedicatedStorage.Count];

            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];
                laneLineSprites[i] = GetOrCreateLaneLineView(entityId)
                    .GetComponent<SpriteRenderer>();
            }
        }

        public void SyncLaneLineTransform(TransformComponent[] lanelineTransform)
        {
            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                laneLineSprites[i].transform.position = lanelineTransform[i].Position;
                laneLineSprites[i].transform.localScale = lanelineTransform[i].Size;
            }
        }

        private GameObject GetOrCreateLaneLineView(int entityId)
        {
            return laneLineViewFactory.GetOrCreateView(entityId);
        }
    }
}

================
File: ECS_Principled/Syncers/LaneLineSyncTool.cs.meta
================
fileFormatVersion: 2
guid: a6ae83dcdaff94f34bcae29a8ff8377d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/MusicNoteSyncer.cs
================
using System;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteSyncer : ArchetypeSyncer
    {
        protected override Archetype Archetype => Archetype.Registry.MusicNote;

        public override EGameState GameStateToExecute { get; } = EGameState.IngamePlaying;

        private readonly EntityViewFactory shortNoteViewFactory;
        private readonly EntityViewFactory longNoteViewFactory;

        // Cache component arrays to avoid getting them each frame
        private TransformComponent[] transforms;
        private MusicNoteComponent[] notes;
        private MusicNoteInteractionComponent[] interactions;
        private MusicNoteFillerComponent[] fillers;

        // Cache frequently accessed components
        private readonly Dictionary<int, SpriteRenderer> noteRenderers =
            new Dictionary<int, SpriteRenderer>();
        private readonly Dictionary<int, (GameObject obj, SpriteRenderer renderer)> fillerCache =
            new Dictionary<int, (GameObject obj, SpriteRenderer renderer)>();

        public MusicNoteSyncer(GlobalPoint globalPoint)
        {
            shortNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.ShortTilePrefab,
                globalPoint.transform
            );
            longNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.LongTilePrefab,
                globalPoint.transform
            );
        }

        public override void RunInitialize()
        {
            IsEnabled = true;

            // Initialize component array references
            transforms = DedicatedStorage.GetComponents<TransformComponent>();
            notes = DedicatedStorage.GetComponents<MusicNoteComponent>();
            interactions = DedicatedStorage.GetComponents<MusicNoteInteractionComponent>();
            fillers = DedicatedStorage.GetComponents<MusicNoteFillerComponent>();
        }

        public override void RunUpdate(float deltaTime)
        {
            // Process notes in batches for better cache utilization
            const int BATCH_SIZE = 64;
            int totalNotes = DedicatedStorage.Count;

            for (int batchStart = 0; batchStart < totalNotes; batchStart += BATCH_SIZE)
            {
                int batchEnd = Math.Min(batchStart + BATCH_SIZE, totalNotes);
                ProcessNoteBatch(batchStart, batchEnd);
            }
        }

        private void ProcessNoteBatch(int start, int end)
        {
            for (int i = start; i < end; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];

                // Get or create view based on note type
                GameObject view = GetOrCreateNoteView(entityId, notes[i].musicNoteType);

                view.transform.position = transforms[i].Position;
                view.transform.localScale = transforms[i].Size;

                SyncNoteState(entityId, view, notes[i], interactions[i], fillers[i]);
            }
        }

        private GameObject GetOrCreateNoteView(int entityId, MusicNoteType noteType)
        {
            return noteType == MusicNoteType.LongNote
                ? longNoteViewFactory.GetOrCreateView(entityId, "longNote")
                : shortNoteViewFactory.GetOrCreateView(entityId, "shortNote");
        }

        private void SyncNoteState(
            int entityId,
            GameObject view,
            MusicNoteComponent note,
            MusicNoteInteractionComponent interaction,
            MusicNoteFillerComponent filler
        )
        {
            // Get cached renderer or cache it
            if (!noteRenderers.TryGetValue(entityId, out var noteRenderer))
            {
                noteRenderer = view.GetComponent<SpriteRenderer>();
                noteRenderers[entityId] = noteRenderer;
            }

            // Update note color based on state
            UpdateNoteColor(noteRenderer, interaction.State);

            // Handle long note filler
            if (note.musicNoteType == MusicNoteType.LongNote)
            {
                SyncNoteFiller(entityId, view, filler);
            }
        }

        private static void UpdateNoteColor(
            SpriteRenderer renderer,
            MusicNoteInteractiveState state
        )
        {
            Color color;
            switch (state)
            {
                case MusicNoteInteractiveState.Normal:
                    color = Color.white;
                    break;
                case MusicNoteInteractiveState.Pressed:
                case MusicNoteInteractiveState.Hold:
                    color = Color.yellow;
                    break;
                case MusicNoteInteractiveState.Completed:
                    color = new Color(1, 1, 1, 0.5f);
                    break;
                default:
                    color = Color.white;
                    break;
            }
            renderer.color = color;
        }

        private void SyncNoteFiller(int entityId, GameObject view, MusicNoteFillerComponent filler)
        {
            if (!fillerCache.TryGetValue(entityId, out var fillerComponents))
            {
                var fillerObj = view.transform.Find("Filler")?.gameObject;
                if (fillerObj != null)
                {
                    fillerComponents = (fillerObj, fillerObj.GetComponent<SpriteRenderer>());
                    fillerCache[entityId] = fillerComponents;
                }
            }

            if (fillerComponents.obj != null)
            {
                fillerComponents.obj.SetActive(filler.IsVisible);
                if (filler.IsVisible)
                {
                    UpdateFillerVisuals(
                        fillerComponents.obj,
                        fillerComponents.renderer,
                        filler.FillPercent
                    );
                }
            }
        }

        private static void UpdateFillerVisuals(
            GameObject fillerObj,
            SpriteRenderer renderer,
            float fillPercent
        )
        {
            Vector3 scale = fillerObj.transform.localScale;
            scale.y = fillPercent;
            SpriteUtility.ScaleFromPivot(renderer, scale, SpriteUtility.PivotPointXY.Bottom);
            renderer.color = Color.Lerp(Color.yellow, Color.green, fillPercent);
        }
    }
}

================
File: ECS_Principled/Syncers/MusicNoteSyncer.cs.meta
================
fileFormatVersion: 2
guid: 541f4a77356ee45a381eacb214f2b6e2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/MusicNoteViewSyncTool.cs
================
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteViewSyncTool : BaseSyncTool
    {
        private readonly EntityViewFactory shortNoteViewFactory;
        private readonly EntityViewFactory longNoteViewFactory;
        protected override Archetype Archetype => Archetype.Registry.MusicNote;

        private readonly Dictionary<int, SpriteRenderer> noteRenderers =
            new Dictionary<int, SpriteRenderer>();
        private readonly Dictionary<int, (GameObject obj, SpriteRenderer renderer)> fillerCache =
            new Dictionary<int, (GameObject obj, SpriteRenderer renderer)>();

        public MusicNoteViewSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            shortNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.ShortTilePrefab,
                globalPoint.transform
            );
            longNoteViewFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.LongTilePrefab,
                globalPoint.transform
            );
        }

        private GameObject GetOrCreateNoteView(int entityId, MusicNoteType noteType)
        {
            return noteType == MusicNoteType.LongNote
                ? longNoteViewFactory.GetOrCreateView(entityId, "longNote")
                : shortNoteViewFactory.GetOrCreateView(entityId, "shortNote");
        }

        public void SyncNoteTransforms(TransformComponent[] transforms, MusicNoteComponent[] notes)
        {
            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];
                GameObject view = GetOrCreateNoteView(entityId, notes[i].musicNoteType);

                view.transform.position = transforms[i].Position;
                view.transform.localScale = transforms[i].Size;
            }
        }

        public void SyncNoteState(
            MusicNoteInteractionComponent[] interaction,
            MusicNoteFillerComponent[] fillers,
            MusicNoteComponent[] notes
        )
        {
            for (int i = 0; i < DedicatedStorage.Count; i++)
            {
                int entityId = DedicatedStorage.EntityIds[i];
                GameObject view = GetOrCreateNoteView(entityId, notes[i].musicNoteType);

                if (!noteRenderers.TryGetValue(entityId, out var noteRenderer))
                {
                    noteRenderer = view.GetComponent<SpriteRenderer>();
                    noteRenderers[entityId] = noteRenderer;
                }

                // Update note color based on state
                UpdateNoteColor(noteRenderer, interaction[i].State);

                // Handle long note filler
                if (notes[i].musicNoteType == MusicNoteType.LongNote)
                {
                    SyncNoteFiller(entityId, view, fillers[i]);
                }
            }
        }

        private static void UpdateNoteColor(
            SpriteRenderer renderer,
            MusicNoteInteractiveState state
        )
        {
            Color color;

            switch (state)
            {
                case MusicNoteInteractiveState.Normal:
                    color = Color.white;
                    break;
                case MusicNoteInteractiveState.Pressed:
                case MusicNoteInteractiveState.Hold:
                    color = Color.yellow;
                    break;
                case MusicNoteInteractiveState.Completed:
                    color = new Color(1, 1, 1, 0.5f);
                    break;
                default:
                    color = Color.white;
                    break;
            }

            renderer.color = color;
        }

        public void SyncNoteFiller(int entityId, GameObject view, MusicNoteFillerComponent filler)
        {
            if (!fillerCache.TryGetValue(entityId, out var fillerComponents))
            {
                var fillerObj = view.transform.Find("Filler")?.gameObject;
                if (fillerObj != null)
                {
                    fillerComponents = (fillerObj, fillerObj.GetComponent<SpriteRenderer>());
                    fillerCache[entityId] = fillerComponents;
                }
            }

            if (fillerComponents.obj != null)
            {
                fillerComponents.obj.SetActive(filler.IsVisible);
                if (filler.IsVisible)
                {
                    UpdateFillerVisuals(
                        fillerComponents.obj,
                        fillerComponents.renderer,
                        filler.FillPercent
                    );
                }
            }
        }

        private static void UpdateFillerVisuals(
            GameObject fillerObj,
            SpriteRenderer renderer,
            float fillPercent
        )
        {
            Vector3 scale = fillerObj.transform.localScale;
            scale.y = fillPercent;
            SpriteUtility.ScaleFromPivot(renderer, scale, SpriteUtility.PivotPointXY.Bottom);
            renderer.color = Color.Lerp(Color.yellow, Color.green, fillPercent);
        }
    }
}

================
File: ECS_Principled/Syncers/MusicNoteViewSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 22e852c0f8e864a82b2f0b4de5c0d491
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/PerfectLineSyncTool.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class PerfectLineSyncTool : BaseSyncTool
    {
        protected override Archetype Archetype => Archetype.Registry.PerfectLine;
        private SpriteRenderer perfectLineSprite;

        public PerfectLineSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            perfectLineSprite = globalPoint.perfectLineObject.GetComponent<SpriteRenderer>();
        }

        public void SyncPerfectLineTransform(TransformComponent perfectLineTransform)
        {
            perfectLineSprite.transform.position = perfectLineTransform.Position;
            perfectLineSprite.transform.localScale = perfectLineTransform.Size;
        }
    }
}

================
File: ECS_Principled/Syncers/PerfectLineSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 819e9d873fddd406b8d1b795f2309e15
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/ProgressSyncer.cs
================
using EventChannel;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class ProgressSyncer : ArchetypeSyncer
    {
        public override EGameState GameStateToExecute => EGameState.IngamePlaying;

        protected override Archetype Archetype => Archetype.Registry.SongProgress;

        private readonly BoolEventChannel scoreEventChannel;

        private readonly Slider progressSlider;

        private ProgressComponent[] progressComponents;

        public ProgressSyncer(GlobalPoint globalPoint)
        {
            scoreEventChannel = globalPoint.OnScoreHitChannel;
            progressSlider = globalPoint.progressSlider;
        }

        public override void RunInitialize()
        {
            IsEnabled = true;

            progressComponents = DedicatedStorage.GetComponents<ProgressComponent>();

            scoreEventChannel.Subscribe(SyncProgressToView);
        }

        private void SyncProgressToView(bool isPerfect)
        {
            ProgressComponent progressComponent = progressComponents[0];
            progressSlider.value = progressComponent.currentProgressPercent;
        }
    }
}

================
File: ECS_Principled/Syncers/ProgressSyncer.cs.meta
================
fileFormatVersion: 2
guid: 5cdfedb8ec59b493682499a649eefe39
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/ProgressSyncTool.cs
================
using ECS_MagicTile;
using UnityEngine.UI;

public class ProgressSyncTool : BaseSyncTool
{
    public ProgressSyncTool(GlobalPoint globalPoint)
        : base(globalPoint)
    {
        progressSlider = globalPoint.progressSlider;
    }

    protected override Archetype Archetype => Archetype.Registry.SongProgress;

    private readonly Slider progressSlider;

    public void SycnProgress(ProgressComponent progressComponent)
    {
        progressSlider.value = progressComponent.currentProgressPercent;
    }
}

================
File: ECS_Principled/Syncers/ProgressSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 993d5dc1edc4c46a1b6c416f877f7f11
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/ScoreUISyncer.cs
================
using ECS_MagicTile;
using ECS_MagicTile.Components;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class ScoreUISyncer : ArchetypeSyncer
    {
        public override EGameState GameStateToExecute => EGameState.All;

        protected override Archetype Archetype => Archetype.Registry.GameScore;

        private readonly Text scoreText;

        // Instead of creating UI, we receive references to existing UI elements
        public ScoreUISyncer(GlobalPoint globalPoint)
        {
            this.scoreText = globalPoint.scoreText;
        }

        public override void RunUpdate(float deltaTime)
        {
            // Get score data from storage
            ScoreComponent scoreComponent = DedicatedStorage.GetComponents<ScoreComponent>()[0];

            // Update UI
            scoreText.text = $"Score: {scoreComponent.TotalScore}";
        }
    }
}

================
File: ECS_Principled/Syncers/ScoreUISyncer.cs.meta
================
fileFormatVersion: 2
guid: 3a2ef7a4a601b9a45a648bd1a5870c32
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/StartingNoteSyncer.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class StartingNoteSyncer : ArchetypeSyncer
    {
        protected override Archetype Archetype => Archetype.Registry.StartingNote;

        public override EGameState GameStateToExecute => EGameState.All;

        private readonly EntityViewFactory startingNoteFactory;

        ActiveStateComponent[] startingNoteActiveStateComponents;
        TransformComponent[] startingNoteTransformComponents;

        private GameObject startingNoteViewObject;

        public StartingNoteSyncer(GlobalPoint globalPoint)
        {
            startingNoteFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.startingNotePrefab,
                globalPoint.transform
            );
        }

        public override void RunInitialize()
        {
            base.RunInitialize();
            IsEnabled = true;

            startingNoteActiveStateComponents =
                DedicatedStorage.GetComponents<ActiveStateComponent>();

            startingNoteTransformComponents = DedicatedStorage.GetComponents<TransformComponent>();

            int entityId_ = DedicatedStorage.EntityIds[0];

            startingNoteViewObject = startingNoteFactory.GetOrCreateView(entityId_, "StartingNote");
            startingNoteViewObject.transform.localScale = startingNoteTransformComponents[0].Size;
        }

        public override void RunUpdate(float deltaTime)
        {
            startingNoteViewObject.SetActive(startingNoteActiveStateComponents[0].isActive);
            // if (!startingNoteViewObject.activeSelf)
            // {
            //     IsEnabled = false;
            // }

            startingNoteViewObject.transform.position = startingNoteTransformComponents[0].Position;
            startingNoteViewObject.transform.localScale = startingNoteTransformComponents[0].Size;
        }
    }
}

================
File: ECS_Principled/Syncers/StartingNoteSyncer.cs.meta
================
fileFormatVersion: 2
guid: c69681375b44edd44bf95aec281d01af
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Syncers/StartingNoteSyncTool.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class StartingNoteSyncTool : BaseSyncTool
    {
        public StartingNoteSyncTool(GlobalPoint globalPoint)
            : base(globalPoint)
        {
            startingNoteFactory = new EntityViewFactory(
                globalPoint.musicNoteCreationSettings.startingNotePrefab,
                globalPoint.transform
            );
        }

        protected override Archetype Archetype => Archetype.Registry.StartingNote;

        private readonly EntityViewFactory startingNoteFactory;
        private GameObject startingNoteViewObject;

        public override void InitializeTool()
        {
            base.InitializeTool();
            int entityId_ = DedicatedStorage.EntityIds[0];

            startingNoteViewObject = startingNoteFactory.GetOrCreateView(entityId_, "StartingNote");
        }

        public void SyncStartNoteTransform(TransformComponent startNoteTransform)
        {
            startingNoteViewObject.transform.position = startNoteTransform.Position;
            startingNoteViewObject.transform.localScale = startNoteTransform.Size;
        }

        public void SyncStartNoteState(ActiveStateComponent startNoteState)
        {
            startingNoteViewObject.SetActive(startNoteState.isActive);
        }
    }
}

================
File: ECS_Principled/Syncers/StartingNoteSyncTool.cs.meta
================
fileFormatVersion: 2
guid: 59c15b38042c74518a09fc378d320993
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems_Mono.meta
================
fileFormatVersion: 2
guid: 94ba7c8cb61bb9d4da3688ae1d270b7d
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems_Mono/GameIntroSystem.cs
================
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class GameIntroSystem : MonoBehaviour, IGameSystem
    {
        [Header("Data")]
        [SerializeField]
        private GeneralGameSetting generalGameSetting;

        [Header("Component references")]
        [SerializeField]
        private Button startButton;

        [SerializeField]
        private GameObject introBlock;

        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public void RunCleanup()
        {
            startButton.onClick.RemoveAllListeners();
        }

        public void RunInitialize()
        {
            startButton.onClick.AddListener(() =>
            {
                generalGameSetting.CurrentGameState = EGameState.IngamePrestart;
                introBlock.SetActive(false);
            });
        }

        public void RunUpdate(float deltaTime) { }

        public void SetWorld(World world)
        {
            World = world;
        }
    }
}

================
File: ECS_Principled/Systems_Mono/GameIntroSystem.cs.meta
================
fileFormatVersion: 2
guid: 6932d242d8b49fb42b805fc8d04dde48
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems_Mono/InGameUIElementHandlerSystem.cs
================
using ComponentCache;
using UIBlock;
using UnityEngine;
using UnityEngine.UI;

namespace ECS_MagicTile
{
    public class InGameUIElementHandlerSystem : MonoBehaviour, IGameSystem
    {
        [Header("Settings Data")]
        public InGameUIElementSetting inGameUIElementSetting;

        [Header("UI Elements")]
        [SerializeField]
        private GameObject scoreUI;

        [SerializeField]
        private GameObject songNameUI;

        [SerializeField]
        private GameObject songAuthorUI;

        [SerializeField]
        private GameObject highScoreUI;

        [SerializeField]
        private GameObject decorationUI;
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        bool hasGetAllComponents = false;

        public void SetWorld(World world) { }

        public void RunInitialize()
        {
            if (hasGetAllComponents)
                return;

            hasGetAllComponents = true;

            scoreUI.RegisterComponent(scoreUI.GetComponent<RectTransform>());

            songNameUI.RegisterComponent(songNameUI.GetComponent<RectTransform>());
            songNameUI.RegisterComponent(songNameUI.GetComponent<Text>());

            songAuthorUI.RegisterComponent(songAuthorUI.GetComponent<RectTransform>());
            songAuthorUI.RegisterComponent(songAuthorUI.GetComponent<Text>());

            highScoreUI.RegisterComponent(highScoreUI.GetComponent<RectTransform>());

            decorationUI.RegisterComponent(decorationUI.GetComponent<RectTransform>());

            scoreUI
                .RectTransform()
                .RegisterBlock(
                    inGameUIElementSetting.scoreUISettings.phonePortraitPos,
                    inGameUIElementSetting.scoreUISettings.phoneLandscapePos,
                    inGameUIElementSetting.scoreUISettings.tabletPortraitPos,
                    inGameUIElementSetting.scoreUISettings.tabletPortraitPos
                );

            songNameUI
                .RectTransform()
                .RegisterBlock(
                    inGameUIElementSetting.songNameUISettings.phonePortraitPos,
                    inGameUIElementSetting.songNameUISettings.phoneLandscapePos,
                    inGameUIElementSetting.songNameUISettings.tabletPortraitPos,
                    inGameUIElementSetting.songNameUISettings.tabletPortraitPos
                );

            songAuthorUI
                .RectTransform()
                .RegisterBlock(
                    inGameUIElementSetting.songAuthorUISettings.phonePortraitPos,
                    inGameUIElementSetting.songAuthorUISettings.phoneLandscapePos,
                    inGameUIElementSetting.songAuthorUISettings.tabletPortraitPos,
                    inGameUIElementSetting.songAuthorUISettings.tabletPortraitPos
                );

            highScoreUI
                .RectTransform()
                .RegisterBlock(
                    inGameUIElementSetting.highScoreUISettings.phonePortraitPos,
                    inGameUIElementSetting.highScoreUISettings.phoneLandscapePos,
                    inGameUIElementSetting.highScoreUISettings.tabletPortraitPos,
                    inGameUIElementSetting.highScoreUISettings.tabletPortraitPos
                );

            decorationUI
                .RectTransform()
                .RegisterBlock(
                    inGameUIElementSetting.decorationUISettings.phonePortraitPos,
                    inGameUIElementSetting.decorationUISettings.phoneLandscapePos,
                    inGameUIElementSetting.decorationUISettings.tabletPortraitPos,
                    inGameUIElementSetting.decorationUISettings.tabletPortraitPos
                );

            songNameUI.Text().text = inGameUIElementSetting.songNameUISettings.songNameContent;
            songAuthorUI.Text().text = inGameUIElementSetting
                .songAuthorUISettings
                .songAuthorContent;
        }

        public void RunUpdate(float deltaTime) { }

        public void RunCleanup() { }
    }
}

================
File: ECS_Principled/Systems_Mono/InGameUIElementHandlerSystem.cs.meta
================
fileFormatVersion: 2
guid: 61b56e1d3ccb8dc44926724b9e72660d

================
File: ECS_Principled/Systems_Mono/IntroUIElementHandlerSystem.cs
================
using ComponentCache;
using UnityEngine;

namespace ECS_MagicTile
{
    public class IntroUIElementHandlerSystem : MonoBehaviour, IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunInitialize() { }

        public void RunUpdate(float deltaTime) { }

        public void RunCleanup() { }
    }
}

================
File: ECS_Principled/Systems_Mono/IntroUIElementHandlerSystem.cs.meta
================
fileFormatVersion: 2
guid: faf283fb0439481498bbb7ef7419d668

================
File: ECS_Principled/Systems.meta
================
fileFormatVersion: 2
guid: c822eec9dba9f4d4b88020ce8c3090ef
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/GameStateSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class GameStateSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.All;

        private readonly IntEventChannel OnGameStartChannel;

        ArchetypeStorage startingNoteStorage;
        ActiveStateComponent[] startingNoteActiveState;
        private StartingNoteSyncTool startingNoteSyncTool;

        private GeneralGameSetting generalGameSetting;

        public GameStateSystem(GlobalPoint globalPoint)
        {
            OnGameStartChannel = globalPoint.OnGameStartChannel;

            startingNoteSyncTool = globalPoint.startingNoteSyncTool;
            generalGameSetting = globalPoint.generalGameSetting;
        }

        public void RunCleanup()
        {
            //
        }

        public void RunInitialize()
        {
            startingNoteStorage = World.GetStorage(Archetype.Registry.StartingNote);

            startingNoteActiveState = startingNoteStorage.GetComponents<ActiveStateComponent>();

            OnGameStartChannel.Subscribe(OnStartNoteInteraction);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunUpdate(float deltaTime)
        {
            //
        }

        private void OnStartNoteInteraction(int startNoteId)
        {
            SystemRegistry.SetGameState(EGameState.IngamePlaying);
            startingNoteActiveState[0].isActive = false;
            startingNoteSyncTool.SyncStartNoteState(startingNoteActiveState[0]);
            generalGameSetting.CurrentGameState = EGameState.IngamePlaying;
        }
    }
}

================
File: ECS_Principled/Systems/GameStateSystem.cs.meta
================
fileFormatVersion: 2
guid: 01ad329a4e8ba17448b524ad53b02f01
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/InputCollisionSystem.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class InputCollisionSystem : IGameSystem
    {
        private const string LOG_PREFIX = "[Input Collision] ";
        private const int MAX_INPUTS = 2;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.IngamePlaying;

        private readonly GeneralGameSetting generalGameSetting;
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;

        ArchetypeStorage inputStorage;
        ArchetypeStorage musicNoteStorage;

        InputStateComponent[] inputStates;
        CornerComponent[] musicNoteCorners;
        MusicNoteInteractionComponent[] musicNoteInteractions;
        MusicNoteFillerComponent[] musicNoteFillers;
        MusicNoteComponent[] musicNotes;

        private readonly MusicNoteViewSyncTool musicNoteViewSyncTool;

        public InputCollisionSystem(GlobalPoint globalPoint)
        {
            this.generalGameSetting = globalPoint.generalGameSetting;
            musicNoteViewSyncTool = globalPoint.musicNoteViewSyncTool;
            musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunInitialize()
        {
            musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);
            inputStorage = World.GetStorage(Archetype.Registry.Input);

            inputStates = inputStorage.GetComponents<InputStateComponent>();
            musicNoteCorners = musicNoteStorage.GetComponents<CornerComponent>();
            musicNoteInteractions = musicNoteStorage.GetComponents<MusicNoteInteractionComponent>();
            musicNoteFillers = musicNoteStorage.GetComponents<MusicNoteFillerComponent>();
            musicNotes = musicNoteStorage.GetComponents<MusicNoteComponent>();
        }

        public void RunUpdate(float deltaTime)
        {
            for (int inputIdx = 0; inputIdx < MAX_INPUTS; inputIdx++)
            {
                if (!inputStates[inputIdx].IsActive)
                    continue;

                for (int noteIdx = 0; noteIdx < musicNoteStorage.Count; noteIdx++)
                {
                    ProcessNoteCollision(
                        inputStates[inputIdx],
                        ref musicNoteCorners[noteIdx],
                        ref musicNoteInteractions[noteIdx],
                        ref musicNoteFillers[noteIdx],
                        musicNotes[noteIdx]
                    );
                }
            }

            musicNoteViewSyncTool.SyncNoteState(
                musicNoteInteractions,
                musicNoteFillers,
                musicNotes
            );
        }

        private void ProcessNoteCollision(
            InputStateComponent input,
            ref CornerComponent corners,
            ref MusicNoteInteractionComponent interaction,
            ref MusicNoteFillerComponent filler,
            MusicNoteComponent note
        )
        {
            // Skip completed notes
            if (interaction.State == MusicNoteInteractiveState.Completed)
                return;

            bool isInsideNote = IsPointInNote(
                input.Position,
                corners.TopLeft,
                corners.TopRight,
                corners.BottomLeft,
                corners.BottomRight
            );

            if (!isInsideNote)
                return;

            ProcessNoteInteraction(input, ref interaction, ref corners, ref filler, note);
        }

        private void ProcessNoteInteraction(
            InputStateComponent input,
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler,
            MusicNoteComponent note
        )
        {
            switch (input.State)
            {
                case InputState.JustPressed:
                    if (interaction.State == MusicNoteInteractiveState.Normal)
                    {
                        if (note.musicNoteType == MusicNoteType.ShortNote)
                        {
                            CompleteNote(ref interaction);
                        }
                        else
                        {
                            StartLongNote(input, ref interaction, ref corners, ref filler);
                        }
                    }
                    break;

                case InputState.Held:
                    if (note.musicNoteType == MusicNoteType.LongNote)
                    {
                        if (interaction.State == MusicNoteInteractiveState.Pressed)
                        {
                            interaction.State = MusicNoteInteractiveState.Hold;
                        }
                        else if (interaction.State == MusicNoteInteractiveState.Hold)
                        {
                            UpdateLongNoteFill(ref interaction, ref corners, ref filler);
                        }
                    }
                    break;

                case InputState.JustReleased:
                    if (
                        note.musicNoteType == MusicNoteType.LongNote
                        && (
                            interaction.State == MusicNoteInteractiveState.Pressed
                            || interaction.State == MusicNoteInteractiveState.Hold
                        )
                    )
                    {
                        CompleteNote(ref interaction);
                    }
                    break;
            }
        }

        private void CompleteNote(ref MusicNoteInteractionComponent interaction)
        {
            interaction.State = MusicNoteInteractiveState.Completed;
            Debug.Log($"{LOG_PREFIX} Note completed");
        }

        private void StartLongNote(
            InputStateComponent input,
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler
        )
        {
            interaction.State = MusicNoteInteractiveState.Pressed;
            filler.IsVisible = true;

            float sizeOfNote = corners.TopLeft.y - corners.BottomLeft.y;
            float fromTouchPositionToLowerOfNote = input.Position.y - corners.BottomLeft.y;
            float touchPercent = fromTouchPositionToLowerOfNote / sizeOfNote;
            filler.FillPercent = touchPercent + 0.1f;

            Debug.Log($"{LOG_PREFIX} Long note pressed");
        }

        private void UpdateLongNoteFill(
            ref MusicNoteInteractionComponent interaction,
            ref CornerComponent corners,
            ref MusicNoteFillerComponent filler
        )
        {
            float gameSpeed = generalGameSetting.GameSpeed;
            if (musicNoteCreationSetting.UsePreciseNoteCalculation)
            {
                gameSpeed = generalGameSetting.PreciseGameSpeed;
            }
            float noteLength = corners.TopLeft.y - corners.BottomLeft.y;
            float fillSpeed = gameSpeed / noteLength;

            float nextFillPercent = filler.FillPercent + (fillSpeed * Time.deltaTime);
            nextFillPercent = Mathf.Min(nextFillPercent, 1f);

            filler.FillPercent = nextFillPercent;

            if (nextFillPercent >= 1f)
            {
                CompleteNote(ref interaction);
            }
        }

        private static bool IsPointInNote(
            Vector2 point,
            Vector2 topLeft,
            Vector2 topRight,
            Vector2 bottomLeft,
            Vector2 bottomRight
        )
        {
            int wn = 0; // Winding number

            Vector2[] vertices = { topLeft, topRight, bottomRight, bottomLeft };

            for (int i = 0; i < vertices.Length; i++)
            {
                Vector2 current = vertices[i];
                Vector2 next = vertices[(i + 1) % vertices.Length];

                if (current.y <= point.y)
                {
                    if (next.y > point.y && IsLeftOf(current, next, point) > 0)
                        wn++;
                }
                else
                {
                    if (next.y <= point.y && IsLeftOf(current, next, point) < 0)
                        wn--;
                }
            }

            return wn != 0;
        }

        private static float IsLeftOf(Vector2 a, Vector2 b, Vector2 point)
        {
            return (b.x - a.x) * (point.y - a.y) - (point.x - a.x) * (b.y - a.y);
        }

        public void RunCleanup() { }
    }
}

================
File: ECS_Principled/Systems/InputCollisionSystem.cs.meta
================
fileFormatVersion: 2
guid: a0d38e0610e6340709395f4e4d69e409
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/InputSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class InputSystem : IGameSystem
    {
        private const int MAX_INPUTS = 2;
        private const string LOG_PREFIX = "[Input System] ";
        private bool wasMousePressed;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.IngamePlaying;

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunInitialize()
        {
            // Create input entities
            for (int i = 0; i < MAX_INPUTS; i++)
            {
                var inputComponent = new InputStateComponent
                {
                    IsActive = false,
                    Position = Vector2.zero,
                    PreviousPosition = Vector2.zero,
                    State = InputState.None,
                    FrameCount = 0,
                };

                World.CreateEntityWithComponents(
                    Archetype.Registry.Input,
                    new object[] { inputComponent }
                );
            }
        }

        public void RunUpdate(float deltaTime)
        {
            ArchetypeStorage inputStorage = World.GetStorage(Archetype.Registry.Input);
            var inputStates = inputStorage.GetComponents<InputStateComponent>();

            // Update previous states
            UpdatePreviousStates(inputStates);

            // Process new input
            if (Input.touchCount > 0)
            {
                ProcessTouchInput(inputStates);
            }
            else
            {
                ProcessMouseInput(inputStates);
            }
        }

        private void UpdatePreviousStates(InputStateComponent[] inputStates)
        {
            for (int i = 0; i < MAX_INPUTS; i++)
            {
                if (inputStates[i].State == InputState.JustReleased)
                {
                    inputStates[i].State = InputState.None;
                    inputStates[i].FrameCount = 0;
                    inputStates[i].IsActive = false;
                }
                else if (inputStates[i].State == InputState.JustPressed)
                {
                    inputStates[i].State = InputState.Held;
                }
            }
        }

        private void ProcessMouseInput(InputStateComponent[] inputStates)
        {
            bool isCurrentlyPressed = Input.GetMouseButton(0);
            Vector2 worldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);

            ref var currentState = ref inputStates[0];
            InputState newState = DetermineNewInputState(isCurrentlyPressed, wasMousePressed);

            // Only update if state changed or position changed
            if (newState != currentState.State || worldPos != currentState.Position)
            {
                UpdateInputState(ref currentState, worldPos, newState);
            }

            wasMousePressed = isCurrentlyPressed;
        }

        private void ProcessTouchInput(InputStateComponent[] inputStates)
        {
            int touchCount = Mathf.Min(Input.touchCount, MAX_INPUTS);

            // Reset unused input slots
            for (int i = touchCount; i < MAX_INPUTS; i++)
            {
                if (inputStates[i].IsActive)
                {
                    inputStates[i].State = InputState.None;
                    inputStates[i].IsActive = false;
                }
            }

            // Process active touches
            for (int i = 0; i < touchCount; i++)
            {
                Touch touch = Input.GetTouch(i);
                Vector2 worldPos = Camera.main.ScreenToWorldPoint(touch.position);

                InputState newState;

                switch (touch.phase)
                {
                    case TouchPhase.Began:
                        newState = InputState.JustPressed;
                        break;
                    case TouchPhase.Moved:
                    case TouchPhase.Stationary:
                        newState = InputState.Held;
                        break;
                    case TouchPhase.Ended:
                    case TouchPhase.Canceled:
                        newState = InputState.JustReleased;
                        break;
                    default:
                        newState = InputState.None;
                        break;
                }

                UpdateInputState(ref inputStates[i], worldPos, newState);
            }
        }

        private void UpdateInputState(
            ref InputStateComponent state,
            Vector2 position,
            InputState newState
        )
        {
            state.PreviousPosition = state.Position;
            state.Position = position;
            state.State = newState;
            state.IsActive = newState != InputState.None;

            if (newState != state.State)
            {
                state.FrameCount = 0;
            }
            state.FrameCount++;
        }

        private InputState DetermineNewInputState(bool isPressed, bool wasPressed)
        {
            if (isPressed && !wasPressed)
                return InputState.JustPressed;
            if (!isPressed && wasPressed)
                return InputState.JustReleased;
            if (isPressed)
                return InputState.Held;
            return InputState.None;
        }

        public void RunCleanup()
        {
            // Nothing to cleanup for now
        }
    }
}

================
File: ECS_Principled/Systems/InputSystem.cs.meta
================
fileFormatVersion: 2
guid: 3a7c2b94a0f5a416c8d8401ea289c387
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/LaneLineSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class LaneLineSystem : IGameSystem
    {
        public LaneLineSystem(GlobalPoint globalPoint)
        {
            onOrientationChangedChannel = globalPoint.OnOrientationChangedChannel;
            laneLineSyncTool = globalPoint.laneLineSyncTool;
            laneLineSettings = globalPoint.laneLineSettings;
            targetCamera = globalPoint.mainCamera;
        }

        public bool IsEnabled { get; set; }
        public World World { get; set; }

        private BoolEventChannel onOrientationChangedChannel;
        private Camera targetCamera;

        public EGameState GameStateToExecute => EGameState.IngamePrestart;

        ArchetypeStorage perfectLineStorage;
        CornerComponent[] perfectLineCorners;

        ArchetypeStorage laneLineStorage;
        TransformComponent[] laneLineTransforms;

        private LaneLineSyncTool laneLineSyncTool;
        private LaneLineSettings laneLineSettings;

        public void RunCleanup() { }

        public void RunInitialize()
        {
            CreateLaneLines();
            laneLineSyncTool.InitializeTool();
            perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);
            laneLineStorage = World.GetStorage(Archetype.Registry.LaneLines);

            laneLineTransforms = laneLineStorage.GetComponents<TransformComponent>();
            perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>();

            AdjustLaneLines();

            onOrientationChangedChannel.Subscribe(OnOrientationChanged);

            laneLineSettings.laneLineWidth.Subscribe(OnLaneLineSettingsAdjustInInpector);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunUpdate(float deltaTime) { }

        private void CreateLaneLines()
        {
            for (int i = 0; i < 5; i++)
            {
                var LaneLinesComponents = new object[] { new TransformComponent() };
                World.CreateEntityWithComponents(Archetype.Registry.LaneLines, LaneLinesComponents);
            }
        }

        private void OnOrientationChanged(bool isPortrait)
        {
            AdjustLaneLines();
        }

        private void OnLaneLineSettingsAdjustInInpector(float value)
        {
            AdjustLaneLines();
        }

        private void AdjustLaneLines()
        {
            ref CornerComponent perfectLineCorner = ref perfectLineCorners[0];

            // Calculate lane width once
            float totalWidth = perfectLineCorner.TopRight.x - perfectLineCorner.TopLeft.x;
            float laneWidth = totalWidth / 4;

            for (int i = 0; i < laneLineStorage.Count; i++)
            {
                float spawnX = i * laneWidth + perfectLineCorner.TopLeft.x;
                float spawnY = CameraViewUtils.GetPositionYInCameraView(targetCamera, .5f);

                laneLineTransforms[i].Position = new Vector3(spawnX, spawnY, 0);
                laneLineTransforms[i].Size = SpriteUtility.ResizeInCameraView(
                    laneLineSyncTool.LaneLineSprites[i],
                    targetCamera,
                    laneLineSettings.laneLineWidth.Value,
                    1,
                    false
                );
            }

            laneLineSyncTool.SyncLaneLineTransform(laneLineTransforms);
        }
    }
}

================
File: ECS_Principled/Systems/LaneLineSystem.cs.meta
================
fileFormatVersion: 2
guid: 36b27db23e135449bb2d06e40f049e10
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/MovingNoteSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MovingNoteSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.IngamePlaying;

        private readonly GeneralGameSetting generalGameSetting;
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;

        ArchetypeStorage musicNoteStorage;

        TransformComponent[] musicNoteTransforms;
        CornerComponent[] musicNoteCornsers;
        MusicNoteComponent[] musicNoteComponents;

        private readonly MusicNoteViewSyncTool musicNoteViewSyncTool;

        public MovingNoteSystem(GlobalPoint globalPoint)
        {
            this.generalGameSetting = globalPoint.generalGameSetting;
            this.musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
            musicNoteViewSyncTool = globalPoint.musicNoteViewSyncTool;
        }

        public void RunCleanup() { }

        public void RunInitialize()
        {
            musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            musicNoteTransforms = musicNoteStorage.GetComponents<TransformComponent>();
            musicNoteCornsers = musicNoteStorage.GetComponents<CornerComponent>();
            musicNoteComponents = musicNoteStorage.GetComponents<MusicNoteComponent>();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunUpdate(float deltaTime)
        {
            float gameSpeed;

            if (musicNoteCreationSetting.UsePreciseNoteCalculation)
            {
                gameSpeed = generalGameSetting.PreciseGameSpeed;
            }
            else
            {
                gameSpeed = generalGameSetting.GameSpeed;
            }

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                if (
                    musicNoteComponents[i].musicNotePositionState
                    == MusicNotePositionState.OutOfScreen
                )
                {
                    continue;
                }

                // Update position
                Vector2 newPos = musicNoteTransforms[i].Position;
                newPos.y -= gameSpeed * Time.deltaTime;
                musicNoteTransforms[i].Position = newPos;

                // Update corners based on new position and size
                Vector2 halfSize = musicNoteTransforms[i].Size * 0.5f;
                musicNoteCornsers[i].TopLeft = new Vector2(
                    newPos.x - halfSize.x,
                    newPos.y + halfSize.y
                );
                musicNoteCornsers[i].TopRight = new Vector2(
                    newPos.x + halfSize.x,
                    newPos.y + halfSize.y
                );
                musicNoteCornsers[i].BottomLeft = new Vector2(
                    newPos.x - halfSize.x,
                    newPos.y - halfSize.y
                );
                musicNoteCornsers[i].BottomRight = new Vector2(
                    newPos.x + halfSize.x,
                    newPos.y - halfSize.y
                );

                if (
                    CameraViewUtils.IsPositionOutOfBounds(
                        Camera.main,
                        musicNoteCornsers[i].TopLeft,
                        CameraViewUtils.CameraBoundCheck.Bottom
                    )
                )
                {
                    musicNoteComponents[i].musicNotePositionState =
                        MusicNotePositionState.OutOfScreen;
                }
            }

            musicNoteViewSyncTool.SyncNoteTransforms(musicNoteTransforms, musicNoteComponents);

            //SystemRegistry.SetGameState(EGameState.Outro);
        }
    }
}

================
File: ECS_Principled/Systems/MovingNoteSystem.cs.meta
================
fileFormatVersion: 2
guid: 23e31434417084f63bbc9efc34471f1f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/MusicNoteCreationSystem.cs
================
using System.Collections.Generic;
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class MusicNoteCreationSystem : IGameSystem
    {
        private readonly MusicNoteCreationSetting musicNoteCreationSetting;
        private readonly GeneralGameSetting generalGameSetting;
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.IngamePrestart;

        MusicNoteMidiData musicNoteMidiData;

        ArchetypeStorage perfectLineStorage;
        PerfectLineTagComponent[] perfectLineTag;
        CornerComponent[] perfectLineCorners;

        ArchetypeStorage musicNoteStorage;
        TransformComponent[] musicNoteTransforms;
        MusicNoteComponent[] musicNotes;

        ArchetypeStorage worldStateStorage;
        WorldStateComponent[] worldStates;

        Camera targetCamera;

        float lastPerfectLineTopLeftY;
        float lastPerfectLineTopLeftX;

        public MusicNoteCreationSystem(GlobalPoint globalPoint)
        {
            this.musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
            this.generalGameSetting = globalPoint.generalGameSetting;
            targetCamera = globalPoint.mainCamera;
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunInitialize()
        {
            musicNoteMidiData = MidiNoteParser.ParseFromText(
                musicNoteCreationSetting.MidiContent.text
            );

            perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);
            perfectLineTag = perfectLineStorage.GetComponents<PerfectLineTagComponent>();
            perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>();

            worldStateStorage = World.GetStorage(Archetype.Registry.WorldState);
            worldStates = worldStateStorage.GetComponents<WorldStateComponent>();

            var noteCount = musicNoteMidiData.TotalNotes;
            var durations = musicNoteMidiData.Durations;
            var positionIds = musicNoteMidiData.PositionIds;
            var timeAppears = musicNoteMidiData.TimeAppears;
            var minDuration = musicNoteMidiData.MinDuration;

            var componentsList = new List<object[]>(noteCount);

            for (int i = 0; i < noteCount; i++)
            {
                var musicNoteType =
                    durations[i] > minDuration ? MusicNoteType.LongNote : MusicNoteType.ShortNote;

                componentsList.Add(
                    new object[]
                    {
                        new TransformComponent(),
                        new MusicNoteComponent
                        {
                            Duration = durations[i],
                            PostionId = positionIds[i],
                            TimeAppear = timeAppears[i],
                            musicNoteType = musicNoteType,
                            musicNotePositionState = MusicNotePositionState.AbovePerfectLine,
                        },
                        new CornerComponent(),
                        new MusicNoteInteractionComponent(),
                        new MusicNoteFillerComponent(),
                        new ScoreStateComponent { HasBeenScored = false },
                    }
                );
            }

            foreach (var components in componentsList)
            {
                World.CreateEntityWithComponents(Archetype.Registry.MusicNote, components);
            }

            musicNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);

            musicNoteTransforms = musicNoteStorage.GetComponents<TransformComponent>();
            musicNotes = musicNoteStorage.GetComponents<MusicNoteComponent>();
        }

        public void RunUpdate(float deltaTime)
        {
            if (
                lastPerfectLineTopLeftY != perfectLineCorners[0].TopLeft.y
                || lastPerfectLineTopLeftX != perfectLineCorners[0].TopLeft.x
            )
            {
                lastPerfectLineTopLeftY = perfectLineCorners[0].TopLeft.y;
                lastPerfectLineTopLeftX = perfectLineCorners[0].TopLeft.x;

                if (musicNoteCreationSetting.UsePreciseNoteCalculation)
                {
                    CalculateMusicNoteDataPrecisely();
                }
                else
                {
                    CalculateMusicNoteData();
                }
            }
        }

        public void RunCleanup()
        {
            //
        }

        private void CalculateMusicNoteData()
        {
            ref CornerComponent perfectLineCorner = ref perfectLineCorners[0];

            // Calculate lane width and half lane width
            float totalWidth = perfectLineCorner.TopRight.x - perfectLineCorner.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            // Calculate Short and Long Note scale factors
            float shortNoteScaleYFactor = MagicTileHelper.CalculateScaleY(
                musicNoteCreationSetting.ShortNoteScaleYFactor,
                perfectLineTag[0].PerfectLineWidth / 4
            );
            float longNoteScaleYFactor = MagicTileHelper.CalculateScaleY(
                musicNoteCreationSetting.LongNoteScaleYFactor,
                perfectLineTag[0].PerfectLineWidth / 4
            );

            // Set all music note positions and sizes
            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                float spawnX =
                    perfectLineCorner.TopLeft.x
                    + (musicNoteMidiData.PositionIds[i] * laneWidth)
                    + halfLaneWidth;

                float spawnY =
                    perfectLineCorner.TopLeft.y
                    + (musicNoteMidiData.TimeAppears[i] * generalGameSetting.GameSpeed)
                    + (
                        musicNotes[i].musicNoteType == MusicNoteType.ShortNote
                            ? shortNoteScaleYFactor
                            : longNoteScaleYFactor
                    );

                musicNoteTransforms[i].Position = new Vector2(spawnX, spawnY);

                musicNoteTransforms[i].Size = new Vector2(
                    perfectLineTag[0].PerfectLineWidth / 4,
                    musicNotes[i].musicNoteType == MusicNoteType.ShortNote
                        ? shortNoteScaleYFactor
                        : longNoteScaleYFactor
                );
            }
        }

        private void CalculateMusicNoteDataPrecisely()
        {
            float[] noteSizes = PreciseNoteCalculator.CalculateNoteSizes(
                musicNoteMidiData,
                musicNoteCreationSetting.ShortNoteScaleYFactor
            );
            float[] positions = PreciseNoteCalculator.CalculateInitialPositions(
                musicNoteMidiData,
                perfectLineCorners[0].TopLeft.y,
                noteSizes,
                musicNoteCreationSetting.ShortNoteScaleYFactor
            );

            worldStates[0].FirstNotePositionToTriggerSong = positions[0];

            ref CornerComponent perfectLineCorner = ref perfectLineCorners[0];

            float totalWidth = perfectLineCorner.TopRight.x - perfectLineCorner.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            float cameraBoundYOffset = CameraViewUtils.GetPositionYInCameraView(targetCamera, 1);

            for (int i = 0; i < musicNoteStorage.Count; i++)
            {
                float spawnX =
                    perfectLineCorner.TopLeft.x
                    + (musicNoteMidiData.PositionIds[i] * laneWidth)
                    + halfLaneWidth;

                musicNoteTransforms[i].Position = new Vector2(
                    spawnX,
                    positions[i] + (cameraBoundYOffset - perfectLineCorner.TopLeft.y)
                );
                musicNoteTransforms[i].Size = new Vector2(
                    perfectLineTag[0].PerfectLineWidth / 4,
                    noteSizes[i]
                );
            }

            float totalTime = PreciseNoteCalculator.CalculateTotalSongDuration(musicNoteMidiData);
            float roadLength = PreciseNoteCalculator.CalculateRoadLength(
                noteSizes,
                musicNoteMidiData
            );

            generalGameSetting.PreciseGameSpeed = PreciseNoteCalculator.CalculateRequiredVelocity(
                totalTime,
                roadLength
            );
        }
    }
}

================
File: ECS_Principled/Systems/MusicNoteCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: 27223b00486847b4b86f21b0b74f2e53
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/PerfectLineSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class PerfectLineSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        //Storage and Data arrays
        ArchetypeStorage perfectLineStorage;
        PerfectLineTagComponent[] perfectLineTagComponents;
        CornerComponent[] perfectLineCorners;
        TransformComponent[] perfectLineTransforms;

        //SO settings
        PerfectLineSetting perfectLineSetting;

        //Event Channels
        private BoolEventChannel OnOrientationChangedChannel;

        //Game object refs
        SpriteRenderer perfectLineSprite;
        Camera mainCamera;

        SpriteUtility.SpriteCorners perfectLineCornersInCamSpace;

        private PerfectLineSyncTool perfectLineSyncTool;

        public PerfectLineSystem(GlobalPoint globalPoint)
        {
            perfectLineSprite = globalPoint.perfectLineObject.GetComponent<SpriteRenderer>();
            perfectLineSetting = globalPoint.perfectLineSetting;
            mainCamera = globalPoint.mainCamera;
            OnOrientationChangedChannel = globalPoint.OnOrientationChangedChannel;

            perfectLineSyncTool = globalPoint.perfectLineSyncTool;
        }

        public EGameState GameStateToExecute => EGameState.All;

        public void RunInitialize()
        {
            perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            perfectLineTagComponents = perfectLineStorage.GetComponents<PerfectLineTagComponent>();
            perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>();
            perfectLineTransforms = perfectLineStorage.GetComponents<TransformComponent>();

            //
            perfectLineSetting.portraitNormalizedPos.normalizedX.Subscribe(UpdatePerfectLinePos);
            perfectLineSetting.portraitNormalizedPos.normalizedY.Subscribe(UpdatePerfectLinePos);

            //
            perfectLineSetting.landscapeNormalizedPos.normalizedX.Subscribe(UpdatePerfectLinePos);
            perfectLineSetting.landscapeNormalizedPos.normalizedY.Subscribe(UpdatePerfectLinePos);

            //
            perfectLineSetting.portraitNormalizedSize.normalizedX.Subscribe(
                UpdatePerfectLineSizeData
            );
            perfectLineSetting.portraitNormalizedSize.normalizedY.Subscribe(
                UpdatePerfectLineSizeData
            );

            //
            perfectLineSetting.landscapeNormalizedSize.normalizedX.Subscribe(
                UpdatePerfectLineSizeData
            );
            perfectLineSetting.landscapeNormalizedSize.normalizedY.Subscribe(
                UpdatePerfectLineSizeData
            );

            OnOrientationChangedChannel.Subscribe(OnOrientationChanged);
        }

        public void RunCleanup() { }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunUpdate(float deltaTime) { }

        private void UpdatePerfectLinePos(float value)
        {
            if (ScreenManager.Instance.IsPortrait)
            {
                perfectLineTransforms[0].Position = CameraViewUtils.GetPositionInCameraView(
                    mainCamera,
                    perfectLineSetting.portraitNormalizedPos.normalizedX.Value,
                    perfectLineSetting.portraitNormalizedPos.normalizedY.Value
                );
            }
            else
            {
                perfectLineTransforms[0].Position = CameraViewUtils.GetPositionInCameraView(
                    mainCamera,
                    perfectLineSetting.landscapeNormalizedPos.normalizedX.Value,
                    perfectLineSetting.landscapeNormalizedPos.normalizedY.Value
                );
            }

            perfectLineSyncTool.SyncPerfectLineTransform(perfectLineTransforms[0]);

            UpdatePerfectLineCornersData();
        }

        private void UpdatePerfectLineSizeData(float value)
        {
            if (ScreenManager.Instance.IsPortrait)
            {
                perfectLineTransforms[0].Size = SpriteUtility.ResizeInCameraView(
                    perfectLineSprite,
                    mainCamera,
                    perfectLineSetting.portraitNormalizedSize.normalizedX.Value,
                    perfectLineSetting.portraitNormalizedSize.normalizedY.Value,
                    false
                );
            }
            else
            {
                perfectLineTransforms[0].Size = SpriteUtility.ResizeInCameraView(
                    perfectLineSprite,
                    mainCamera,
                    perfectLineSetting.landscapeNormalizedSize.normalizedX.Value,
                    perfectLineSetting.landscapeNormalizedSize.normalizedY.Value,
                    false
                );
            }

            perfectLineSyncTool.SyncPerfectLineTransform(perfectLineTransforms[0]);

            UpdatePerfectLineCornersData();
        }

        private void UpdatePerfectLineCornersData()
        {
            perfectLineCornersInCamSpace = SpriteUtility.GetSpriteCorners(perfectLineSprite);

            perfectLineCorners[0].TopLeft = perfectLineCornersInCamSpace.TopLeft;
            perfectLineCorners[0].TopRight = perfectLineCornersInCamSpace.TopRight;
            perfectLineCorners[0].BottomLeft = perfectLineCornersInCamSpace.BottomLeft;
            perfectLineCorners[0].BottomRight = perfectLineCornersInCamSpace.BottomRight;

            perfectLineTagComponents[0].PerfectLineWidth = Mathf.Abs(
                perfectLineCornersInCamSpace.TopLeft.x - perfectLineCornersInCamSpace.TopRight.x
            );
        }

        private void OnOrientationChanged(bool isPortrait)
        {
            if (isPortrait)
            {
                UpdatePerfectLinePos(0f);
            }
            else
            {
                UpdatePerfectLinePos(0f);
            }
            UpdatePerfectLineSizeData(0f);
        }
    }
}

================
File: ECS_Principled/Systems/PerfectLineSystem.cs.meta
================
fileFormatVersion: 2
guid: 1b10a060d587046339f5da333963b154
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/ProgressSystem.cs
================
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ProgressSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.IngamePlaying;

        private BoolEventChannel scoreEventChannel;

        private ProgressSyncTool progressSyncTool;

        public ProgressSystem(GlobalPoint globalPoint)
        {
            this.scoreEventChannel = globalPoint.OnScoreHitChannel;
            progressSyncTool = globalPoint.progressSyncTool;
        }

        private ArchetypeStorage progressArchetype;

        public void RunCleanup() { }

        public void RunInitialize()
        {
            progressArchetype = World.GetStorage(Archetype.Registry.SongProgress);

            scoreEventChannel.Subscribe(OnScoreEvent);
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunUpdate(float deltaTime) { }

        private void OnScoreEvent(bool isScore)
        {
            ref ProgressComponent progress =
                ref progressArchetype.GetComponents<ProgressComponent>()[0];
            progress.CurrentProgressRawValue++;
            progress.currentProgressPercent =
                progress.CurrentProgressRawValue / progress.MaxProgressRawValue;

            Debug.Log($"Current Progress: {progress.currentProgressPercent}");

            progressSyncTool.SycnProgress(progress);
        }
    }
}

================
File: ECS_Principled/Systems/ProgressSystem.cs.meta
================
fileFormatVersion: 2
guid: 48ac64d4224f142299e7f0d4888feaf5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/ScoringSystem.cs
================
using System;
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class ScoringSystem : IGameSystem
    {
        private const int PERFECT_SCORE = 100;
        private const int GREAT_SCORE = 50;

        // How close to perfect line needed for perfect score (in units)
        private const float PERFECT_THRESHOLD = 0.1f;

        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.IngamePlaying;

        ArchetypeStorage noteStorage;
        ArchetypeStorage gameScoreStorage;
        ArchetypeStorage perfectLineStorage;

        MusicNoteInteractionComponent[] musicNoteInteractionComponents;
        TransformComponent[] musicNoteTransformComponents;
        ScoreStateComponent[] musicScoreStateComponents;
        MusicNoteComponent[] musicNoteComponents;

        BoolEventChannel scoreSignalEffectChannel;

        private GameScoreSyncTool gameScoreSyncTool;

        public ScoringSystem(GlobalPoint globalPoint)
        {
            this.scoreSignalEffectChannel = globalPoint.OnScoreHitChannel;
            this.gameScoreSyncTool = globalPoint.gameScoreSyncTool;
        }

        public void RunCleanup()
        {
            //
        }

        public void RunInitialize()
        {
            noteStorage = World.GetStorage(Archetype.Registry.MusicNote);
            gameScoreStorage = World.GetStorage(Archetype.Registry.GameScore);
            perfectLineStorage = World.GetStorage(Archetype.Registry.PerfectLine);

            musicNoteComponents = noteStorage.GetComponents<MusicNoteComponent>();
            musicNoteInteractionComponents =
                noteStorage.GetComponents<MusicNoteInteractionComponent>();
            musicNoteTransformComponents = noteStorage.GetComponents<TransformComponent>();
            musicScoreStateComponents = noteStorage.GetComponents<ScoreStateComponent>();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunUpdate(float deltaTime)
        {
            var perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>()[0];
            ref var gameScore = ref gameScoreStorage.GetComponents<ScoreComponent>()[0];

            //process note
            for (int i = 0; i < noteStorage.Count; i++)
            {
                // Only process notes that were just hit and haven't been scored
                if (musicScoreStateComponents[i].HasBeenScored)
                {
                    continue;
                }

                if (musicNoteComponents[i].musicNoteType == MusicNoteType.LongNote)
                {
                    if (
                        musicNoteInteractionComponents[i].State == MusicNoteInteractiveState.Pressed
                    )
                    {
                        ProcessNoteScore(
                            musicNoteTransformComponents[i],
                            perfectLineCorners,
                            ref gameScore,
                            ref musicScoreStateComponents[i]
                        );
                    }
                }
                else
                {
                    if (
                        musicNoteInteractionComponents[i].State == MusicNoteInteractiveState.Pressed
                        || musicNoteInteractionComponents[i].State
                            == MusicNoteInteractiveState.Completed
                    )
                    {
                        ProcessNoteScore(
                            musicNoteTransformComponents[i],
                            perfectLineCorners,
                            ref gameScore,
                            ref musicScoreStateComponents[i]
                        );
                    }
                }
            }
        }

        private void ProcessNoteScore(
            TransformComponent musicTransform,
            CornerComponent perfectLineCorners,
            ref ScoreComponent gameScore,
            ref ScoreStateComponent scoreStateComponent
        )
        {
            float distanceFromPerfect = Mathf.Abs(
                musicTransform.Position.y - perfectLineCorners.TopLeft.y
            );

            int scoreToAdd;

            if (distanceFromPerfect <= PERFECT_THRESHOLD)
            {
                scoreToAdd = PERFECT_SCORE;
                scoreSignalEffectChannel.RaiseEvent(true);
            }
            else
            {
                scoreToAdd = GREAT_SCORE;
                scoreSignalEffectChannel.RaiseEvent(false);
            }

            gameScore.TotalScore += scoreToAdd;
            scoreStateComponent.HasBeenScored = true;

            gameScoreSyncTool.SyncGameScore(gameScore);
        }
    }
}

================
File: ECS_Principled/Systems/ScoringSystem.cs.meta
================
fileFormatVersion: 2
guid: 8fca9e9bcd6671c42bc6b410aa575c9e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/SingletonCreationSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class SingletonCreationSystem : IGameSystem
    {
        public bool IsEnabled { get; set; }
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.IngamePrestart;

        private readonly MusicNoteCreationSetting musicNoteCreationSetting;

        public SingletonCreationSystem(GlobalPoint globalPoint)
        {
            musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
        }

        public void RunCleanup()
        {
            //
        }

        public void RunInitialize()
        {
            CreatePerfectLine();
            CreateStartingNote();
            CreateGameScore();
            CreateProgress();
            CreateWorldStateComponent();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunUpdate(float deltaTime)
        {
            //
        }

        private void CreatePerfectLine()
        {
            //The perfect line singleton
            var components = new object[]
            {
                new TransformComponent(),
                new PerfectLineTagComponent(),
                new CornerComponent(),
            };
            World.CreateEntityWithComponents(Archetype.Registry.PerfectLine, components);
        }

        private void CreateStartingNote()
        {
            var components = new object[]
            {
                new TransformComponent(),
                new ActiveStateComponent(),
                new StartingNoteTagComponent(),
            };
            World.CreateEntityWithComponents(Archetype.Registry.StartingNote, components);
        }

        private void CreateGameScore()
        {
            var components = new object[] { new ScoreComponent { TotalScore = 0 } };
            World.CreateEntityWithComponents(Archetype.Registry.GameScore, components);
        }

        private void CreateProgress()
        {
            MusicNoteMidiData musicNoteMidiData = MidiNoteParser.ParseFromText(
                musicNoteCreationSetting.MidiContent.text
            );
            var components = new object[]
            {
                new ProgressComponent
                {
                    CurrentProgressRawValue = 0,
                    currentProgressPercent = 0,
                    MaxProgressRawValue = musicNoteMidiData.TotalNotes,
                },
            };
            World.CreateEntityWithComponents(Archetype.Registry.SongProgress, components);
        }

        private void CreateWorldStateComponent()
        {
            var components = new object[] { new WorldStateComponent() };
            World.CreateEntityWithComponents(Archetype.Registry.WorldState, components);
        }
    }
}

================
File: ECS_Principled/Systems/SingletonCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: 0363a30a155e7de4492faa5045403325
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/StartingNoteSystem.cs
================
using ECS_MagicTile.Components;
using UnityEngine;

namespace ECS_MagicTile
{
    public class StartingNoteSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.All;

        private readonly MusicNoteCreationSetting musicNoteCreationSetting;

        private readonly StartingNoteSyncTool startingNoteSyncTool;

        private ArchetypeStorage startingNoteStorage;
        private ArchetypeStorage perfectLineStorage;

        private TransformComponent[] startingNoteTransforms;
        private CornerComponent[] perfectLineCorners;

        float lastPerfectLineTopLeftY;
        float lastPerfectLineTopLeftX;

        public StartingNoteSystem(GlobalPoint globalPoint)
        {
            musicNoteCreationSetting = globalPoint.musicNoteCreationSettings;
            startingNoteSyncTool = globalPoint.startingNoteSyncTool;
        }

        public void RunCleanup() { }

        public void RunInitialize()
        {
            startingNoteSyncTool.InitializeTool();

            startingNoteStorage ??= World.GetStorage(Archetype.Registry.StartingNote);
            perfectLineStorage ??= World.GetStorage(Archetype.Registry.PerfectLine);

            perfectLineCorners = perfectLineStorage.GetComponents<CornerComponent>();
            startingNoteTransforms = startingNoteStorage.GetComponents<TransformComponent>();

            ref ActiveStateComponent activeState =
                ref startingNoteStorage.GetComponents<ActiveStateComponent>()[0];
            activeState.isActive = true;

            SetupStartingNote();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunUpdate(float deltaTime)
        {
            if (
                lastPerfectLineTopLeftY != perfectLineCorners[0].TopLeft.y
                || lastPerfectLineTopLeftX != perfectLineCorners[0].TopLeft.x
            )
            {
                lastPerfectLineTopLeftY = perfectLineCorners[0].TopLeft.y;
                lastPerfectLineTopLeftX = perfectLineCorners[0].TopLeft.x;
                SetupStartingNote();
            }

            //Debug.Log($"PerfectLine Topleft: {perfectLineCorners[0].TopLeft.x}");
        }

        private void SetupStartingNote()
        {
            ref TransformComponent transform = ref startingNoteTransforms[0];

            ref CornerComponent perfectLineCorner = ref perfectLineCorners[0];

            // Calculate lane width
            float totalWidth = perfectLineCorner.TopRight.x - perfectLineCorner.TopLeft.x;
            float laneWidth = totalWidth / 4;
            float halfLaneWidth = laneWidth / 2f;

            // Calculate spawn position
            float spawnX = perfectLineCorner.TopLeft.x + (0 * laneWidth) + halfLaneWidth;
            float spawnY = perfectLineCorner.TopLeft.y;

            transform.Position = new Vector2(spawnX, spawnY);

            ref PerfectLineTagComponent PerfectLine =
                ref perfectLineStorage.GetComponents<PerfectLineTagComponent>()[0];

            float scaleX = PerfectLine.PerfectLineWidth / 4;

            float scaleY = MagicTileHelper.CalculateScaleY(
                musicNoteCreationSetting.ShortNoteScaleYFactor,
                scaleX
            );

            transform.Size = new Vector2(scaleX, scaleY);

            startingNoteSyncTool.SyncStartNoteTransform(transform);
        }
    }
}

================
File: ECS_Principled/Systems/StartingNoteSystem.cs.meta
================
fileFormatVersion: 2
guid: bd30870514eee4c529701bd1bedca700
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Principled/Systems/TraceNoteToTriggerSongSystem.cs
================
using ECS_MagicTile.Components;
using EventChannel;
using UnityEngine;

namespace ECS_MagicTile
{
    public class TraceNoteToTriggerSongSystem : IGameSystem
    {
        public bool IsEnabled { get; set; } = true;
        public World World { get; set; }

        public EGameState GameStateToExecute => EGameState.IngamePlaying;

        ArchetypeStorage musicnNoteStorage;
        TransformComponent[] musicNoteTransforms;

        ArchetypeStorage worldStateStorage;
        WorldStateComponent[] worldStateComponents;

        EmptyEventChannel OnSongStartChannel;

        public TraceNoteToTriggerSongSystem(GlobalPoint globalPoint)
        {
            OnSongStartChannel = globalPoint.OnSongStartChannel;
        }

        public void RunCleanup() { }

        public void RunInitialize()
        {
            worldStateStorage = World.GetStorage(Archetype.Registry.WorldState);
            worldStateComponents = worldStateStorage.GetComponents<WorldStateComponent>();

            musicnNoteStorage = World.GetStorage(Archetype.Registry.MusicNote);
            musicNoteTransforms = musicnNoteStorage.GetComponents<TransformComponent>();
        }

        public void SetWorld(World world)
        {
            World = world;
        }

        public void RunUpdate(float deltaTime)
        {
            if (
                musicNoteTransforms[0].Position.y
                <= worldStateComponents[0].FirstNotePositionToTriggerSong
            )
            {
                OnSongStartChannel.RaiseEvent(new EmptyData());
                IsEnabled = false;
            }
        }
    }
}

================
File: ECS_Principled/Systems/TraceNoteToTriggerSongSystem.cs.meta
================
fileFormatVersion: 2
guid: 93c4845eb14e3064ea19d934433b14f2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
