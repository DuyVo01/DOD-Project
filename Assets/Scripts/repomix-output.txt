This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-29T10:57:48.689Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
ECS_Core.meta
ECS_Core/Archetype.cs
ECS_Core/Archetype.cs.meta
ECS_Core/ArchetypeManager.cs
ECS_Core/ArchetypeManager.cs.meta
ECS_Core/ComponentType.cs
ECS_Core/ComponentType.cs.meta
ECS_Core/IComponent.cs
ECS_Core/IComponent.cs.meta
ECS_Core/Mock.meta
ECS_Core/Mock/MockComponentData.cs
ECS_Core/Mock/MockComponentData.cs.meta
ECS_Core/Mock/MockDebugSystem.cs
ECS_Core/Mock/MockDebugSystem.cs.meta
ECS_Core/QueryDescription.cs
ECS_Core/QueryDescription.cs.meta
ECS_Core/repomix-output.txt
ECS_Core/repomix-output.txt.meta
ECS_Core/SystemManager.cs
ECS_Core/SystemManager.cs.meta
ECS_Core/World.cs
ECS_Core/World.cs.meta
ECS_MagicTiles.meta
ECS_MagicTiles/DataComponent.meta
ECS_MagicTiles/DataComponent/CornerComponent.cs
ECS_MagicTiles/DataComponent/CornerComponent.cs.meta
ECS_MagicTiles/DataComponent/LongNoteTagComponent.cs
ECS_MagicTiles/DataComponent/LongNoteTagComponent.cs.meta
ECS_MagicTiles/DataComponent/MusicNoteComponent.cs
ECS_MagicTiles/DataComponent/MusicNoteComponent.cs.meta
ECS_MagicTiles/DataComponent/PerfectLineTagComponent.cs
ECS_MagicTiles/DataComponent/PerfectLineTagComponent.cs.meta
ECS_MagicTiles/DataComponent/ShortNoteTagComponent.cs
ECS_MagicTiles/DataComponent/ShortNoteTagComponent.cs.meta
ECS_MagicTiles/DataComponent/TransformComponent.cs
ECS_MagicTiles/DataComponent/TransformComponent.cs.meta
ECS_MagicTiles/DTO.meta
ECS_MagicTiles/DTO/MusicNoteMidiData.cs
ECS_MagicTiles/DTO/MusicNoteMidiData.cs.meta
ECS_MagicTiles/GlobalPoint.cs
ECS_MagicTiles/GlobalPoint.cs.meta
ECS_MagicTiles/MidiNoteParser.cs
ECS_MagicTiles/MidiNoteParser.cs.meta
ECS_MagicTiles/PrefabSourceSO.cs
ECS_MagicTiles/PrefabSourceSO.cs.meta
ECS_MagicTiles/repomix-output.txt
ECS_MagicTiles/repomix-output.txt.meta
ECS_MagicTiles/SceneObjectSpawner.cs
ECS_MagicTiles/SceneObjectSpawner.cs.meta
ECS_MagicTiles/Systems.meta
ECS_MagicTiles/Systems/MusicNoteCreationSystem.cs
ECS_MagicTiles/Systems/MusicNoteCreationSystem.cs.meta
ExampleMIddiNote.txt
ExampleMIddiNote.txt.meta
MagicTiles.meta
MagicTiles/CustomEditor.meta
MagicTiles/CustomEditor/GlobalGameSettingEditor.cs
MagicTiles/CustomEditor/GlobalGameSettingEditor.cs.meta
MagicTiles/CustomLibrary.meta
MagicTiles/CustomLibrary/CameraViewUtils.cs
MagicTiles/CustomLibrary/CameraViewUtils.cs.meta
MagicTiles/CustomLibrary/ChunkArray.cs
MagicTiles/CustomLibrary/ChunkArray.cs.meta
MagicTiles/CustomLibrary/EventChannel.meta
MagicTiles/CustomLibrary/EventChannel/EventChannelSO.cs
MagicTiles/CustomLibrary/EventChannel/EventChannelSO.cs.meta
MagicTiles/CustomLibrary/EventChannel/IEventData.cs
MagicTiles/CustomLibrary/EventChannel/IEventData.cs.meta
MagicTiles/CustomLibrary/EventChannel/repomix-output.txt
MagicTiles/CustomLibrary/EventChannel/repomix-output.txt.meta
MagicTiles/CustomLibrary/HelperExtension.cs
MagicTiles/CustomLibrary/HelperExtension.cs.meta
MagicTiles/CustomLibrary/ManualDebug.meta
MagicTiles/CustomLibrary/ManualDebug/DebugHandler.cs
MagicTiles/CustomLibrary/ManualDebug/DebugHandler.cs.meta
MagicTiles/CustomLibrary/ManualDebug/ManualDebug.cs
MagicTiles/CustomLibrary/ManualDebug/ManualDebug.cs.meta
MagicTiles/CustomLibrary/NativeObjectPool.meta
MagicTiles/CustomLibrary/NativeObjectPool/INativePool.cs
MagicTiles/CustomLibrary/NativeObjectPool/INativePool.cs.meta
MagicTiles/CustomLibrary/NativeObjectPool/NativePool.cs
MagicTiles/CustomLibrary/NativeObjectPool/NativePool.cs.meta
MagicTiles/CustomLibrary/ObjectPool.meta
MagicTiles/CustomLibrary/ObjectPool/IObjectPool.cs
MagicTiles/CustomLibrary/ObjectPool/IObjectPool.cs.meta
MagicTiles/CustomLibrary/ObjectPool/ObjectPool.cs
MagicTiles/CustomLibrary/ObjectPool/ObjectPool.cs.meta
MagicTiles/CustomLibrary/PersistentSingleton.cs
MagicTiles/CustomLibrary/PersistentSingleton.cs.meta
MagicTiles/CustomLibrary/SpriteExtension.cs
MagicTiles/CustomLibrary/SpriteExtension.cs.meta
MagicTiles/DataComponent.meta
MagicTiles/DataComponent/InputDataComponent.cs
MagicTiles/DataComponent/InputDataComponent.cs.meta
MagicTiles/DataComponent/IntroNoteData.cs
MagicTiles/DataComponent/IntroNoteData.cs.meta
MagicTiles/DataComponent/LaneLineData.cs
MagicTiles/DataComponent/LaneLineData.cs.meta
MagicTiles/DataComponent/MusicNoteFillerData.cs
MagicTiles/DataComponent/MusicNoteFillerData.cs.meta
MagicTiles/DataComponent/MusicNoteStateData.cs
MagicTiles/DataComponent/MusicNoteStateData.cs.meta
MagicTiles/DataComponent/MusicNoteTransformData.cs
MagicTiles/DataComponent/MusicNoteTransformData.cs.meta
MagicTiles/DataComponent/PerfectLineData.cs
MagicTiles/DataComponent/PerfectLineData.cs.meta
MagicTiles/Enum.meta
MagicTiles/Enum/BridgeType.cs
MagicTiles/Enum/BridgeType.cs.meta
MagicTiles/Enum/DataComponentEnum.meta
MagicTiles/Enum/DataComponentEnum/LaneLineComponentType.cs
MagicTiles/Enum/DataComponentEnum/LaneLineComponentType.cs.meta
MagicTiles/Enum/DataComponentEnum/MusicNoteComponentType.cs
MagicTiles/Enum/DataComponentEnum/MusicNoteComponentType.cs.meta
MagicTiles/Enum/EntityType.cs
MagicTiles/Enum/EntityType.cs.meta
MagicTiles/Enum/PresenterManagerType.cs
MagicTiles/Enum/PresenterManagerType.cs.meta
MagicTiles/Enum/SingletonComponentType.cs
MagicTiles/Enum/SingletonComponentType.cs.meta
MagicTiles/Global.meta
MagicTiles/Global/EntityGroup.cs
MagicTiles/Global/EntityGroup.cs.meta
MagicTiles/Global/GlobalGameSetting.cs
MagicTiles/Global/GlobalGameSetting.cs.meta
MagicTiles/Global/MagicTileHelper.cs
MagicTiles/Global/MagicTileHelper.cs.meta
MagicTiles/Global/MusicTileManager.cs
MagicTiles/Global/MusicTileManager.cs.meta
MagicTiles/Global/PresenterManager.cs
MagicTiles/Global/PresenterManager.cs.meta
MagicTiles/Initializer.meta
MagicTiles/Initializer/LaneLineInitializer.cs
MagicTiles/Initializer/LaneLineInitializer.cs.meta
MagicTiles/Initializer/MusicNoteInitializer.cs
MagicTiles/Initializer/MusicNoteInitializer.cs.meta
MagicTiles/Interfaces.meta
MagicTiles/Interfaces/IBridge.cs
MagicTiles/Interfaces/IBridge.cs.meta
MagicTiles/Interfaces/IDataComponent.cs
MagicTiles/Interfaces/IDataComponent.cs.meta
MagicTiles/Interfaces/IEntityGroup.cs
MagicTiles/Interfaces/IEntityGroup.cs.meta
MagicTiles/Interfaces/IGameSystem.cs
MagicTiles/Interfaces/IGameSystem.cs.meta
MagicTiles/Interfaces/IPresenterManager.cs
MagicTiles/Interfaces/IPresenterManager.cs.meta
MagicTiles/Repositories.meta
MagicTiles/Repositories/BridgeRepository.cs
MagicTiles/Repositories/BridgeRepository.cs.meta
MagicTiles/Repositories/EntityRepository.cs
MagicTiles/Repositories/EntityRepository.cs.meta
MagicTiles/Repositories/PresenterManagerRepository.cs
MagicTiles/Repositories/PresenterManagerRepository.cs.meta
MagicTiles/Repositories/SingletonComponentRepository.cs
MagicTiles/Repositories/SingletonComponentRepository.cs.meta
MagicTiles/Repositories/SystemRepository.cs
MagicTiles/Repositories/SystemRepository.cs.meta
MagicTiles/Systems.meta
MagicTiles/Systems/InputCollisionSystem.cs
MagicTiles/Systems/InputCollisionSystem.cs.meta
MagicTiles/Systems/InputSystem.cs
MagicTiles/Systems/InputSystem.cs.meta
MagicTiles/Systems/IntroNoteInitSystem.cs
MagicTiles/Systems/IntroNoteInitSystem.cs.meta
MagicTiles/Systems/LaneLineSortingSystem.cs
MagicTiles/Systems/LaneLineSortingSystem.cs.meta
MagicTiles/Systems/MovingTileSystem.cs
MagicTiles/Systems/MovingTileSystem.cs.meta
MagicTiles/Systems/NoteCornerUpdateSystem.cs
MagicTiles/Systems/NoteCornerUpdateSystem.cs.meta
MagicTiles/Systems/NoteStateSystem.cs
MagicTiles/Systems/NoteStateSystem.cs.meta
MagicTiles/Systems/TileSpawnSystem.cs
MagicTiles/Systems/TileSpawnSystem.cs.meta
MagicTiles/Systems/TransformUpdateSystem.cs
MagicTiles/Systems/TransformUpdateSystem.cs.meta
MagicTiles/UnityBridge.meta
MagicTiles/UnityBridge/InputDebuggerBridge.cs
MagicTiles/UnityBridge/InputDebuggerBridge.cs.meta
MagicTiles/UnityBridge/IntroNoteTransformBridge.cs
MagicTiles/UnityBridge/IntroNoteTransformBridge.cs.meta
MagicTiles/UnityBridge/LaneLineBridge.cs
MagicTiles/UnityBridge/LaneLineBridge.cs.meta
MagicTiles/UnityBridge/MusicNoteTransformBridge.cs
MagicTiles/UnityBridge/MusicNoteTransformBridge.cs.meta
MagicTiles/World.meta
MagicTiles/World/LaneLineWorld.cs
MagicTiles/World/LaneLineWorld.cs.meta
MagicTiles/World/MusicTileWorld.cs
MagicTiles/World/MusicTileWorld.cs.meta
MonoDebug.meta
MonoDebug/CameraSpacePositionAdjuster.cs
MonoDebug/CameraSpacePositionAdjuster.cs.meta
MonoDebug/GizmoDebugger.cs
MonoDebug/GizmoDebugger.cs.meta
MonoDebug/SpriteCornerDebugger.cs
MonoDebug/SpriteCornerDebugger.cs.meta
MonoDebug/SpriteResizer.cs
MonoDebug/SpriteResizer.cs.meta
Prefabs.meta
Prefabs/IntroNotePrefab.prefab
Prefabs/IntroNotePrefab.prefab.meta
Prefabs/LaneLinePrefab.prefab
Prefabs/LaneLinePrefab.prefab.meta
Prefabs/LongTilePrefab.prefab
Prefabs/LongTilePrefab.prefab.meta
Prefabs/musicNoteDebugger.prefab
Prefabs/musicNoteDebugger.prefab.meta
Prefabs/ShortTilePrefab.prefab
Prefabs/ShortTilePrefab.prefab.meta
Settings.meta
Settings/DataSystemSetting.asset
Settings/DataSystemSetting.asset.meta
Settings/GeneralGameSettings.asset
Settings/GeneralGameSettings.asset.meta
Settings/IntroNoteSettingSO.asset
Settings/IntroNoteSettingSO.asset.meta
Settings/LaneLineSettingSO.asset
Settings/LaneLineSettingSO.asset.meta
Settings/MusicNoteSetting.asset
Settings/MusicNoteSetting.asset.meta
Settings/PerfectLineSetting.asset
Settings/PerfectLineSetting.asset.meta
Settings/PresenterSetting.asset
Settings/PresenterSetting.asset.meta
Settings/SO Scripts.meta
Settings/SO Scripts/DataSystemSettingSO.cs
Settings/SO Scripts/DataSystemSettingSO.cs.meta
Settings/SO Scripts/GeneralGameSettingSO.cs
Settings/SO Scripts/GeneralGameSettingSO.cs.meta
Settings/SO Scripts/IntroNoteSettingSO.cs
Settings/SO Scripts/IntroNoteSettingSO.cs.meta
Settings/SO Scripts/LaneLineSettingSO.cs
Settings/SO Scripts/LaneLineSettingSO.cs.meta
Settings/SO Scripts/MusicNoteSettingSO.cs
Settings/SO Scripts/MusicNoteSettingSO.cs.meta
Settings/SO Scripts/PerfectLineSettingSO.cs
Settings/SO Scripts/PerfectLineSettingSO.cs.meta
Settings/SO Scripts/PresenterSettingSO.cs
Settings/SO Scripts/PresenterSettingSO.cs.meta

================================================================
Repository Files
================================================================

================
File: ECS_Core.meta
================
fileFormatVersion: 2
guid: 6f382772a4026489083a300b3daf4d8e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/Archetype.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace ECS_Core
{
    public class Archetype
    {
        private const int DEFAULT_INITIAL_CAPACITY = 16;
        private const float GROWTH_FACTOR = 2.0f;
        private readonly HashSet<ComponentType> componentTypes = new();
        private readonly Dictionary<ComponentType, Array> componentArrays = new();
        private readonly List<int> entities = new();
        private readonly Dictionary<int, int> entityToIndex = new();
        private int count = 0;

        public Archetype(ComponentType[] types)
        {
            foreach (var type in types)
            {
                componentTypes.Add(type);
                componentArrays[type] = Array.CreateInstance(type.Type, DEFAULT_INITIAL_CAPACITY); // Initial capacity
            }
        }

        public bool HasComponent(ComponentType type) => componentTypes.Contains(type);

        public T[] GetComponentArray<T>()
            where T : struct, IComponent
        {
            var type = ComponentType.Of<T>();
            return (T[])componentArrays[type];
        }

        public void Add(int entityId, Dictionary<ComponentType, object> components)
        {
            if (count == componentArrays.First().Value.Length)
            {
                Grow();
            }

            entityToIndex[entityId] = count;
            entities.Add(entityId);

            foreach (var kvp in components)
            {
                var array = componentArrays[kvp.Key];
                Array.Copy(new[] { kvp.Value }, 0, array, count, 1);
            }

            count++;
        }

        // New overload for when components are already copied
        public void AddWithoutComponents(int entityId)
        {
            if (count == componentArrays.First().Value.Length)
            {
                Grow();
            }

            entityToIndex[entityId] = count;
            entities.Add(entityId);
            count++;
        }

        public void RemoveEntity(int entityId)
        {
            if (!entityToIndex.TryGetValue(entityId, out int indexToRemove))
                return;

            int lastIndex = count - 1;
            if (indexToRemove < lastIndex)
            {
                int lastEntityId = entities[lastIndex];

                foreach (var componentArray in componentArrays.Values)
                {
                    Array.Copy(componentArray, lastIndex, componentArray, indexToRemove, 1);
                }

                entityToIndex[lastEntityId] = indexToRemove;
                entities[indexToRemove] = lastEntityId;
            }

            entityToIndex.Remove(entityId);
            entities.RemoveAt(count - 1);
            count--;
        }

        private void Grow()
        {
            var newCapacity = (int)(componentArrays.First().Value.Length * GROWTH_FACTOR);
            foreach (var type in componentArrays.Keys.ToList())
            {
                var oldArray = componentArrays[type];
                var newArray = Array.CreateInstance(type.Type, newCapacity);

                // Use Array.Copy instead of Buffer.BlockCopy
                // This properly handles copying of value types (structs)
                Array.Copy(oldArray, 0, newArray, 0, count);

                componentArrays[type] = newArray;
            }
        }

        public bool HasEntity(int entityId) => entityToIndex.ContainsKey(entityId);

        public int Count => count;
        public IReadOnlyList<int> Entities => entities;

        public IEnumerable<ComponentType> ComponentTypes => componentTypes;

        public Array GetComponentArrayRaw(ComponentType type)
        {
            if (!componentArrays.TryGetValue(type, out var array))
                throw new ArgumentException(
                    $"ComponentType {type.Type.Name} not found in archetype."
                );

            return array;
        }

        public int GetEntityIndex(int entityId)
        {
            if (!entityToIndex.TryGetValue(entityId, out var index))
                throw new ArgumentException($"Entity {entityId} not found in archetype.");

            return index;
        }

        public void TransferEntityComponents(
            int entityId,
            Archetype targetArchetype,
            HashSet<ComponentType> componentTypesToTransfer
        )
        {
            // Get source entity index
            var sourceIndex = GetEntityIndex(entityId);
            if (sourceIndex == -1)
                throw new ArgumentException($"Entity {entityId} not found in source archetype.");

            foreach (var type in componentTypesToTransfer)
            {
                if (
                    !componentArrays.ContainsKey(type)
                    || !targetArchetype.componentArrays.ContainsKey(type)
                )
                    continue;

                var sourceArray = componentArrays[type];
                var targetArray = targetArchetype.componentArrays[type];
                var elementSize = Marshal.SizeOf(type.Type);

                // Ensure target has space
                if (targetArchetype.count >= targetArray.Length)
                    targetArchetype.Grow();

                // Direct memory copy for the component
                Buffer.BlockCopy(
                    sourceArray, // Source array
                    sourceIndex * elementSize, // Source offset
                    targetArray, // Target array
                    targetArchetype.count * elementSize, // Target offset
                    elementSize // How many bytes to copy
                );
            }
        }
    }
}

================
File: ECS_Core/Archetype.cs.meta
================
fileFormatVersion: 2
guid: b4381e7b77d7446289e01f3738e6d8dc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/ArchetypeManager.cs
================
using System.Collections.Generic;
using System.Linq;

namespace ECS_Core
{
    public class ArchetypeManager
    {
        private Dictionary<int, Archetype> archetypes = new();

        public Archetype GetOrCreateArchetype(ComponentType[] types)
        {
            int hash = CalculateArchetypeHash(types);
            if (!archetypes.TryGetValue(hash, out var archetype))
            {
                archetype = new Archetype(types);
                archetypes[hash] = archetype;
            }

            return archetype;
        }

        public IEnumerable<Archetype> GetArchetypesWithComponents(ComponentType[] types)
        {
            foreach (var archetype in archetypes.Values)
            {
                if (DoesArchetypeMatchQuery(archetype, types))
                {
                    yield return archetype;
                }
            }
        }

        private bool DoesArchetypeMatchQuery(Archetype archetype, ComponentType[] queryTypes)
        {
            foreach (var queryType in queryTypes)
            {
                if (!archetype.HasComponent(queryType))
                {
                    return false;
                }
            }
            return true;
        }

        private int CalculateArchetypeHash(ComponentType[] types)
        {
            int hash = 17;
            foreach (var type in types.OrderBy(t => t.Id))
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        public void CleanupEmptyArchetypes()
        {
            var emptyArchetypes = archetypes
                .Where(kvp => kvp.Value.Count == 0)
                .Select(kvp => kvp.Key)
                .ToList();

            foreach (var hash in emptyArchetypes)
            {
                archetypes.Remove(hash);
            }
        }
    }
}

================
File: ECS_Core/ArchetypeManager.cs.meta
================
fileFormatVersion: 2
guid: 5358525b5829c452d9abb4891f4431ba
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/ComponentType.cs
================
using System;
using System.Collections.Generic;

namespace ECS_Core
{
    public struct ComponentType
    {
        public readonly Type Type;
        public readonly int Id;
        private static int NextId = 0;
        private static Dictionary<Type, ComponentType> typeRegistry = new();

        private ComponentType(Type type)
        {
            Type = type;
            Id = NextId++;
        }

        public static ComponentType Of<T>()
            where T : struct, IComponent
        {
            var type = typeof(T);
            if (!typeRegistry.ContainsKey(type))
            {
                typeRegistry[type] = new ComponentType(type);
            }

            return typeRegistry[type];
        }
    }
}

================
File: ECS_Core/ComponentType.cs.meta
================
fileFormatVersion: 2
guid: 2e3cff646cf254dee8948a45e56ad066
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/IComponent.cs
================
namespace ECS_Core
{
    public interface IComponent { }
}

================
File: ECS_Core/IComponent.cs.meta
================
fileFormatVersion: 2
guid: 5bfc30fb61b4b4792b8875b3f63c5a3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/Mock.meta
================
fileFormatVersion: 2
guid: 5ca9bd3fd7f2d6f4dbea65f7c213d993
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/Mock/MockComponentData.cs
================
using ECS_Core;
using UnityEngine;

public struct MockComponentData : IComponent
{
    public int Value;
}

================
File: ECS_Core/Mock/MockComponentData.cs.meta
================
fileFormatVersion: 2
guid: c445691cf3452bf4f84afb339d70c9a4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/Mock/MockDebugSystem.cs
================
using ECS_Core;
using UnityEngine;

public struct MockDebugSystem : ECS_Core.IGameSystem
{
    public bool AutoUpdate { get; set; }
    public ArchetypeManager ArchetypeManager { get; set; }

    public void Cleanup()
    {
        //
    }

    public void Initialize()
    {
        AutoUpdate = true;
    }

    public void Start()
    {
        //
    }

    public void Update() { }
}

================
File: ECS_Core/Mock/MockDebugSystem.cs.meta
================
fileFormatVersion: 2
guid: 07a7f8a2f4cb6de4793b923993ed50c8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/QueryDescription.cs
================
namespace ECS_Core
{
    public delegate void ActionRef<T1>(ref T1 item);
    public delegate void ActionRef<T1, T2>(T1 index, ref T2 item);
    public delegate void ActionRef<T1, T2, T3>(T1 index, ref T2 item1, ref T3 item2);
    public delegate void ActionRef<T1, T2, T3, T4>(
        T1 index,
        ref T2 item1,
        ref T3 item2,
        ref T4 item3
    );
    public delegate void ActionRef<T1, T2, T3, T4, T5>(
        T1 index,
        ref T2 item1,
        ref T3 item2,
        ref T4 item3,
        ref T5 item4
    );

    public readonly struct QueryDescription<T1>
        where T1 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[] { ComponentType.Of<T1>() };

        public void ForEach(ArchetypeManager archetypeManager, ActionRef<int, T1> action)
        {
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(componentTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var component1Array = archetype.GetComponentArray<T1>();
                var entities = archetype.Entities;

                for (int i = 0; i < archetype.Count; i++)
                {
                    action(entities[i], ref component1Array[i]);
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
        };

        public void ForEach(ArchetypeManager archetypeManager, ActionRef<int, T1, T2> action)
        {
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(componentTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var component1Array = archetype.GetComponentArray<T1>();
                var component2Array = archetype.GetComponentArray<T2>();
                var entities = archetype.Entities;

                for (int i = 0; i < archetype.Count; i++)
                {
                    action(entities[i], ref component1Array[i], ref component2Array[i]);
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2, T3>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
        where T3 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
            ComponentType.Of<T3>(),
        };

        public void ForEach(ArchetypeManager archetypeManager, ActionRef<int, T1, T2, T3> action)
        {
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(componentTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var component1Array = archetype.GetComponentArray<T1>();
                var component2Array = archetype.GetComponentArray<T2>();
                var component3Array = archetype.GetComponentArray<T3>();
                var entities = archetype.Entities;

                for (int i = 0; i < archetype.Count; i++)
                {
                    action(
                        entities[i],
                        ref component1Array[i],
                        ref component2Array[i],
                        ref component3Array[i]
                    );
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2, T3, T4>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
        where T3 : struct, IComponent
        where T4 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
            ComponentType.Of<T3>(),
            ComponentType.Of<T4>(),
        };

        public void ForEach(
            ArchetypeManager archetypeManager,
            ActionRef<int, T1, T2, T3, T4> action
        )
        {
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(componentTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var component1Array = archetype.GetComponentArray<T1>();
                var component2Array = archetype.GetComponentArray<T2>();
                var component3Array = archetype.GetComponentArray<T3>();
                var component4Array = archetype.GetComponentArray<T4>();
                var entities = archetype.Entities;

                for (int i = 0; i < archetype.Count; i++)
                {
                    action(
                        entities[i],
                        ref component1Array[i],
                        ref component2Array[i],
                        ref component3Array[i],
                        ref component4Array[i]
                    );
                }
            }
        }
    }
}

================
File: ECS_Core/QueryDescription.cs.meta
================
fileFormatVersion: 2
guid: 88b70e4e0660742a3aef862f0ee483f7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-27T12:38:38.020Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
Mock/
  MockComponentData.cs
  MockComponentData.cs.meta
  MockDebugSystem.cs
  MockDebugSystem.cs.meta
Archetype.cs
Archetype.cs.meta
ArchetypeManager.cs
ArchetypeManager.cs.meta
ComponentType.cs
ComponentType.cs.meta
IComponent.cs
IComponent.cs.meta
Mock.meta
QueryDescription.cs
QueryDescription.cs.meta
SystemManager.cs
SystemManager.cs.meta
World.cs
World.cs.meta

================================================================
Repository Files
================================================================

================
File: Mock/MockComponentData.cs
================
using ECS_Core;
using UnityEngine;

public struct MockComponentData : IComponent
{
    public int Value;
}

================
File: Mock/MockComponentData.cs.meta
================
fileFormatVersion: 2
guid: c445691cf3452bf4f84afb339d70c9a4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Mock/MockDebugSystem.cs
================
using ECS_Core;
using UnityEngine;

public struct MockDebugSystem : ECS_Core.IGameSystem
{
    public bool AutoUpdate { get; set; }
    public ArchetypeManager ArchetypeManager { get; set; }

    public void Cleanup()
    {
        //
    }

    public void Initialize()
    {
        AutoUpdate = true;
    }

    public void Start()
    {
        //
    }

    public void Update() { }
}

================
File: Mock/MockDebugSystem.cs.meta
================
fileFormatVersion: 2
guid: 07a7f8a2f4cb6de4793b923993ed50c8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Archetype.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace ECS_Core
{
    public class Archetype
    {
        private const int DEFAULT_INITIAL_CAPACITY = 16;
        private const float GROWTH_FACTOR = 2.0f;
        private readonly HashSet<ComponentType> componentTypes = new();
        private readonly Dictionary<ComponentType, Array> componentArrays = new();
        private readonly List<int> entities = new();
        private readonly Dictionary<int, int> entityToIndex = new();
        private int count = 0;

        public Archetype(ComponentType[] types)
        {
            foreach (var type in types)
            {
                componentTypes.Add(type);
                componentArrays[type] = Array.CreateInstance(type.Type, DEFAULT_INITIAL_CAPACITY); // Initial capacity
            }
        }

        public bool HasComponent(ComponentType type) => componentTypes.Contains(type);

        public T[] GetComponentArray<T>()
            where T : struct, IComponent
        {
            var type = ComponentType.Of<T>();
            return (T[])componentArrays[type];
        }

        public void Add(int entityId, Dictionary<ComponentType, object> components)
        {
            if (count == componentArrays.First().Value.Length)
            {
                Grow();
            }

            entityToIndex[entityId] = count;
            entities.Add(entityId);

            foreach (var kvp in components)
            {
                var array = componentArrays[kvp.Key];
                Array.Copy(new[] { kvp.Value }, 0, array, count, 1);
            }

            count++;
        }

        // New overload for when components are already copied
        public void AddWithoutComponents(int entityId)
        {
            if (count == componentArrays.First().Value.Length)
            {
                Grow();
            }

            entityToIndex[entityId] = count;
            entities.Add(entityId);
            count++;
        }

        public void RemoveEntity(int entityId)
        {
            if (!entityToIndex.TryGetValue(entityId, out int indexToRemove))
                return;

            int lastIndex = count - 1;
            if (indexToRemove < lastIndex)
            {
                int lastEntityId = entities[lastIndex];

                foreach (var componentArray in componentArrays.Values)
                {
                    Array.Copy(componentArray, lastIndex, componentArray, indexToRemove, 1);
                }

                entityToIndex[lastEntityId] = indexToRemove;
                entities[indexToRemove] = lastEntityId;
            }

            entityToIndex.Remove(entityId);
            entities.RemoveAt(count - 1);
            count--;
        }

        private void Grow()
        {
            var newCapacity = (int)(componentArrays.First().Value.Length * GROWTH_FACTOR);
            foreach (var type in componentArrays.Keys.ToList())
            {
                var oldArray = componentArrays[type];
                var newArray = Array.CreateInstance(type.Type, newCapacity);

                // Use Array.Copy instead of Buffer.BlockCopy
                // This properly handles copying of value types (structs)
                Array.Copy(oldArray, 0, newArray, 0, count);

                componentArrays[type] = newArray;
            }
        }

        public bool HasEntity(int entityId) => entityToIndex.ContainsKey(entityId);

        public int Count => count;
        public IReadOnlyList<int> Entities => entities;

        public IEnumerable<ComponentType> ComponentTypes => componentTypes;

        public Array GetComponentArrayRaw(ComponentType type)
        {
            if (!componentArrays.TryGetValue(type, out var array))
                throw new ArgumentException(
                    $"ComponentType {type.Type.Name} not found in archetype."
                );

            return array;
        }

        public int GetEntityIndex(int entityId)
        {
            if (!entityToIndex.TryGetValue(entityId, out var index))
                throw new ArgumentException($"Entity {entityId} not found in archetype.");

            return index;
        }

        public void TransferEntityComponents(
            int entityId,
            Archetype targetArchetype,
            HashSet<ComponentType> componentTypesToTransfer
        )
        {
            // Get source entity index
            var sourceIndex = GetEntityIndex(entityId);
            if (sourceIndex == -1)
                throw new ArgumentException($"Entity {entityId} not found in source archetype.");

            foreach (var type in componentTypesToTransfer)
            {
                if (
                    !componentArrays.ContainsKey(type)
                    || !targetArchetype.componentArrays.ContainsKey(type)
                )
                    continue;

                var sourceArray = componentArrays[type];
                var targetArray = targetArchetype.componentArrays[type];
                var elementSize = Marshal.SizeOf(type.Type);

                // Ensure target has space
                if (targetArchetype.count >= targetArray.Length)
                    targetArchetype.Grow();

                // Direct memory copy for the component
                Buffer.BlockCopy(
                    sourceArray, // Source array
                    sourceIndex * elementSize, // Source offset
                    targetArray, // Target array
                    targetArchetype.count * elementSize, // Target offset
                    elementSize // How many bytes to copy
                );
            }
        }
    }
}

================
File: Archetype.cs.meta
================
fileFormatVersion: 2
guid: b4381e7b77d7446289e01f3738e6d8dc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ArchetypeManager.cs
================
using System.Collections.Generic;
using System.Linq;

namespace ECS_Core
{
    public class ArchetypeManager
    {
        private Dictionary<int, Archetype> archetypes = new();

        public Archetype GetOrCreateArchetype(ComponentType[] types)
        {
            int hash = CalculateArchetypeHash(types);
            if (!archetypes.TryGetValue(hash, out var archetype))
            {
                archetype = new Archetype(types);
                archetypes[hash] = archetype;
            }

            return archetype;
        }

        public IEnumerable<Archetype> GetArchetypesWithComponents(ComponentType[] types)
        {
            foreach (var archetype in archetypes.Values)
            {
                if (DoesArchetypeMatchQuery(archetype, types))
                {
                    yield return archetype;
                }
            }
        }

        private bool DoesArchetypeMatchQuery(Archetype archetype, ComponentType[] queryTypes)
        {
            foreach (var queryType in queryTypes)
            {
                if (!archetype.HasComponent(queryType))
                {
                    return false;
                }
            }
            return true;
        }

        private int CalculateArchetypeHash(ComponentType[] types)
        {
            int hash = 17;
            foreach (var type in types.OrderBy(t => t.Id))
            {
                hash = hash * 31 + type.Id;
            }
            return hash;
        }

        public void CleanupEmptyArchetypes()
        {
            var emptyArchetypes = archetypes
                .Where(kvp => kvp.Value.Count == 0)
                .Select(kvp => kvp.Key)
                .ToList();

            foreach (var hash in emptyArchetypes)
            {
                archetypes.Remove(hash);
            }
        }
    }
}

================
File: ArchetypeManager.cs.meta
================
fileFormatVersion: 2
guid: 5358525b5829c452d9abb4891f4431ba
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ComponentType.cs
================
using System;
using System.Collections.Generic;

namespace ECS_Core
{
    public struct ComponentType
    {
        public readonly Type Type;
        public readonly int Id;
        private static int NextId = 0;
        private static Dictionary<Type, ComponentType> typeRegistry = new();

        private ComponentType(Type type)
        {
            Type = type;
            Id = NextId++;
        }

        public static ComponentType Of<T>()
            where T : struct, IComponent
        {
            var type = typeof(T);
            if (!typeRegistry.ContainsKey(type))
            {
                typeRegistry[type] = new ComponentType(type);
            }

            return typeRegistry[type];
        }
    }
}

================
File: ComponentType.cs.meta
================
fileFormatVersion: 2
guid: 2e3cff646cf254dee8948a45e56ad066
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: IComponent.cs
================
namespace ECS_Core
{
    public interface IComponent { }
}

================
File: IComponent.cs.meta
================
fileFormatVersion: 2
guid: 5bfc30fb61b4b4792b8875b3f63c5a3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Mock.meta
================
fileFormatVersion: 2
guid: 5ca9bd3fd7f2d6f4dbea65f7c213d993
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: QueryDescription.cs
================
namespace ECS_Core
{
    public delegate void ActionRef<T1>(ref T1 item);
    public delegate void ActionRef<T1, T2>(T1 index, ref T2 item);
    public delegate void ActionRef<T1, T2, T3>(T1 index, ref T2 item1, ref T3 item2);
    public delegate void ActionRef<T1, T2, T3, T4>(
        T1 index,
        ref T2 item1,
        ref T3 item2,
        ref T4 item3
    );
    public delegate void ActionRef<T1, T2, T3, T4, T5>(
        T1 index,
        ref T2 item1,
        ref T3 item2,
        ref T4 item3,
        ref T5 item4
    );

    public readonly struct QueryDescription<T1>
        where T1 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[] { ComponentType.Of<T1>() };

        public void ForEach(ArchetypeManager archetypeManager, ActionRef<int, T1> action)
        {
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(componentTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var component1Array = archetype.GetComponentArray<T1>();
                var entities = archetype.Entities;

                for (int i = 0; i < archetype.Count; i++)
                {
                    action(entities[i], ref component1Array[i]);
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
        };

        public void ForEach(ArchetypeManager archetypeManager, ActionRef<int, T1, T2> action)
        {
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(componentTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var component1Array = archetype.GetComponentArray<T1>();
                var component2Array = archetype.GetComponentArray<T2>();
                var entities = archetype.Entities;

                for (int i = 0; i < archetype.Count; i++)
                {
                    action(entities[i], ref component1Array[i], ref component2Array[i]);
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2, T3>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
        where T3 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
            ComponentType.Of<T3>(),
        };

        public void ForEach(ArchetypeManager archetypeManager, ActionRef<int, T1, T2, T3> action)
        {
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(componentTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var component1Array = archetype.GetComponentArray<T1>();
                var component2Array = archetype.GetComponentArray<T2>();
                var component3Array = archetype.GetComponentArray<T3>();
                var entities = archetype.Entities;

                for (int i = 0; i < archetype.Count; i++)
                {
                    action(
                        entities[i],
                        ref component1Array[i],
                        ref component2Array[i],
                        ref component3Array[i]
                    );
                }
            }
        }
    }

    public readonly struct QueryDescription<T1, T2, T3, T4>
        where T1 : struct, IComponent
        where T2 : struct, IComponent
        where T3 : struct, IComponent
        where T4 : struct, IComponent
    {
        private static readonly ComponentType[] componentTypes = new[]
        {
            ComponentType.Of<T1>(),
            ComponentType.Of<T2>(),
            ComponentType.Of<T3>(),
            ComponentType.Of<T4>(),
        };

        public void ForEach(
            ArchetypeManager archetypeManager,
            ActionRef<int, T1, T2, T3, T4> action
        )
        {
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(componentTypes);
            foreach (var archetype in matchingArchetypes)
            {
                var component1Array = archetype.GetComponentArray<T1>();
                var component2Array = archetype.GetComponentArray<T2>();
                var component3Array = archetype.GetComponentArray<T3>();
                var component4Array = archetype.GetComponentArray<T4>();
                var entities = archetype.Entities;

                for (int i = 0; i < archetype.Count; i++)
                {
                    action(
                        entities[i],
                        ref component1Array[i],
                        ref component2Array[i],
                        ref component3Array[i],
                        ref component4Array[i]
                    );
                }
            }
        }
    }
}

================
File: QueryDescription.cs.meta
================
fileFormatVersion: 2
guid: 88b70e4e0660742a3aef862f0ee483f7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: SystemManager.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_Core
{
    public interface IGameSystem
    {
        void Initialize();
        void Start();
        void Update();
        void Cleanup();
        bool AutoUpdate { get; set; }
        ArchetypeManager ArchetypeManager { get; set; }
    }

    public static class SystemManager
    {
        private static Dictionary<Type, IGameSystem> systems = new();
        private static bool isInitialized;

        public static void RegisterSystem<T>(T system)
            where T : struct, IGameSystem
        {
            if (systems.ContainsKey(typeof(T)))
            {
                Debug.LogWarning($"System {typeof(T)} is already registered. Skipping.");
                return;
            }

            systems[typeof(T)] = new GameSystemWrapper<T>(system);
        }

        public static ref T GetSystem<T>()
            where T : struct, IGameSystem
        {
            if (systems.TryGetValue(typeof(T), out var wrapper))
            {
                return ref ((GameSystemWrapper<T>)wrapper).System;
            }
            throw new KeyNotFoundException($"System {typeof(T)} not registered");
        }

        public static void InitializeSystems(World world)
        {
            if (isInitialized)
            {
                Debug.LogWarning("Systems are already initialized.");
                return;
            }

            foreach (var system in systems.Values)
            {
                try
                {
                    system.ArchetypeManager = world.ArchetypeManager;
                    system.Initialize();
                }
                catch (Exception e)
                {
                    Debug.LogError($"Failed to initialize system {system.GetType()}: {e}");
                }
            }

            isInitialized = true;
        }

        public static void SystemStart()
        {
            if (!isInitialized)
            {
                Debug.LogError("Systems not initialized. Call InitializeSystems first.");
                return;
            }
            foreach (var system in systems.Values)
            {
                // Only update systems that are enabled AND marked for auto-update
                if (((ISystemState)system).Enabled)
                {
                    try
                    {
                        system.Start();
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error Starting system {system.GetType()}: {e}");
                    }
                }
            }
        }

        public static void UpdateSystems()
        {
            if (!isInitialized)
            {
                Debug.LogError("Systems not initialized. Call InitializeSystems first.");
                return;
            }

            foreach (var system in systems.Values)
            {
                // Only update systems that are enabled AND marked for auto-update
                if (((ISystemState)system).Enabled && system.AutoUpdate)
                {
                    try
                    {
                        system.Update();
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error updating system {system.GetType()}: {e}");
                    }
                }
            }
        }

        public static void EnableSystem<T>()
            where T : struct, IGameSystem
        {
            if (systems.TryGetValue(typeof(T), out var system))
            {
                ((ISystemState)system).Enabled = true;
            }
        }

        public static void DisableSystem<T>()
            where T : struct, IGameSystem
        {
            if (systems.TryGetValue(typeof(T), out var system))
            {
                ((ISystemState)system).Enabled = false;
            }
        }

        public static void Clear()
        {
            if (!isInitialized)
                return;

            foreach (var system in systems.Values)
            {
                try
                {
                    system.Cleanup();
                }
                catch (Exception e)
                {
                    Debug.LogError($"Error cleaning up system {system.GetType()}: {e}");
                }
            }

            systems.Clear();
            isInitialized = false;
        }

        private interface ISystemState
        {
            bool Enabled { get; set; }
        }

        private class GameSystemWrapper<T> : IGameSystem, ISystemState
            where T : IGameSystem
        {
            public T System;
            public bool Enabled { get; set; } = true;
            public bool AutoUpdate
            {
                get => System.AutoUpdate;
                set => System.AutoUpdate = value;
            }
            public ArchetypeManager ArchetypeManager
            {
                get => System.ArchetypeManager;
                set => System.ArchetypeManager = value;
            }

            public GameSystemWrapper(T system)
            {
                System = system;
            }

            public void Initialize() => System.Initialize();

            public void Update() => System.Update();

            public void Cleanup() => System.Cleanup();

            public void Start() => System.Start();
        }
    }
}

// Example usage:

================
File: SystemManager.cs.meta
================
fileFormatVersion: 2
guid: cce3b968c17691b4bb5a1a080cdc9340
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: World.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_Core
{
    public class World
    {
        private class SingletonCache
        {
            public Array[] ComponentArrays; // Array of component arrays for each type
            public int EntityIndex; // Index in the arrays where our singleton components live
            public int EntityId; // The singleton entity's ID
            public bool IsValid; // Cache validity flag
        }

        // Main cache storage - we use component type ID as the key for faster lookup
        private Dictionary<int, SingletonCache> singletonCaches = new();

        #region Static Access
        private static World activeWorld;
        public static World Active => activeWorld;

        public static void SetActiveWorld(World world) => activeWorld = world;
        #endregion

        #region Constants
        private const int CLEANUP_THRESHOLD = 100;
        private const int FIRST_NORMAL_ENTITY_ID = 1000;
        private const int OPERATIONS_PER_FRAME = 100;
        #endregion

        #region Fields
        private readonly ArchetypeManager archetypeManager = new();
        private readonly Dictionary<int, Archetype> entityArchetypes = new();
        private readonly Dictionary<int, Dictionary<ComponentType, object>> pendingComponents =
            new();
        private readonly Dictionary<string, Dictionary<ComponentType, object>> templates = new();
        private readonly Dictionary<string, Archetype> archetypeCache = new();
        private readonly Queue<int> pendingDestructions = new();
        private readonly HashSet<int> markedForDestruction = new();
        private readonly Queue<(string template, Action<int> modifier)> pendingCreations = new();

        private int nextEntityId = FIRST_NORMAL_ENTITY_ID;
        private int pendingOperationCount = 0;
        private int creationBatchSize = 0;
        #endregion

        public ArchetypeManager ArchetypeManager => archetypeManager;

        #region Entity Creation and Components

        public int CreateEntity()
        {
            var entityId = nextEntityId++;
            pendingComponents[entityId] = new Dictionary<ComponentType, object>();
            return entityId;
        }

        public void AddComponent<T>(int entityId, T component)
            where T : struct, IComponent
        {
            if (!pendingComponents.TryGetValue(entityId, out var components))
            {
                components = new Dictionary<ComponentType, object>();
                pendingComponents[entityId] = components;
            }

            components[ComponentType.Of<T>()] = component;
        }

        public void UpdateEntity(int entityId)
        {
            if (!pendingComponents.TryGetValue(entityId, out var components))
                return;

            // Check singleton uniqueness
            bool isSingleton = components.ContainsKey(ComponentType.Of<SingletonFlag>());
            if (isSingleton)
            {
                foreach (var componentType in components.Keys)
                {
                    if (componentType.Type == typeof(SingletonFlag))
                        continue;

                    bool singletonExists = false;
                    var query = new QueryDescription<SingletonFlag>();
                    query.ForEach(
                        archetypeManager,
                        (int existingId, ref SingletonFlag _) =>
                        {
                            if (!IsMarkedForDestruction(existingId))
                            {
                                var existingArchetype = entityArchetypes[existingId];
                                if (existingArchetype.HasComponent(componentType))
                                    singletonExists = true;
                            }
                        }
                    );

                    if (singletonExists)
                        throw new InvalidOperationException(
                            $"Singleton of type {componentType.Type.Name} already exists"
                        );
                }
            }

            var types = components.Keys.ToArray();
            var archetype = archetypeManager.GetOrCreateArchetype(types);
            archetype.Add(entityId, components);
            entityArchetypes[entityId] = archetype;
            pendingComponents.Remove(entityId);
        }

        public void UpdateEntities(IEnumerable<int> entityIds)
        {
            var entitiesByArchetype =
                new Dictionary<
                    string,
                    List<(int id, Dictionary<ComponentType, object> components)>
                >();

            foreach (var entityId in entityIds)
            {
                if (!pendingComponents.TryGetValue(entityId, out var components))
                    continue;

                var typeKey = string.Join(",", components.Keys.Select(t => t.Id).OrderBy(id => id));
                if (!entitiesByArchetype.TryGetValue(typeKey, out var list))
                {
                    list = new List<(int, Dictionary<ComponentType, object>)>();
                    entitiesByArchetype[typeKey] = list;
                }
                list.Add((entityId, components));
            }

            foreach (var group in entitiesByArchetype)
            {
                Archetype archetype;
                if (!archetypeCache.TryGetValue(group.Key, out archetype))
                {
                    var types = group.Value[0].components.Keys.ToArray();
                    archetype = archetypeManager.GetOrCreateArchetype(types);
                    archetypeCache[group.Key] = archetype;
                }

                foreach (var (entityId, components) in group.Value)
                {
                    archetype.Add(entityId, components);
                    entityArchetypes[entityId] = archetype;
                    pendingComponents.Remove(entityId);
                }
            }
        }
        #endregion

        #region Template System
        public void CreateTemplate(
            string templateName,
            Dictionary<ComponentType, object> components
        )
        {
            templates[templateName] = components;

            var types = components.Keys.ToArray();
            var typeKey = string.Join(",", types.Select(t => t.Id).OrderBy(id => id));
            if (!archetypeCache.ContainsKey(typeKey))
            {
                archetypeCache[typeKey] = archetypeManager.GetOrCreateArchetype(types);
            }
        }

        public int CreateEntityFromTemplate(string templateName)
        {
            if (!templates.TryGetValue(templateName, out var templateComponents))
                throw new ArgumentException($"Template {templateName} not found");

            var entityId = CreateEntity();
            var components = new Dictionary<ComponentType, object>(templateComponents);
            pendingComponents[entityId] = components;
            return entityId;
        }

        public void QueueEntityCreation(string templateName, Action<int> modifyComponents = null)
        {
            pendingCreations.Enqueue((templateName, modifyComponents));
            creationBatchSize++;
        }

        public void ModifyPendingComponent<T>(int entityId, ActionRef<T> modifier)
            where T : struct, IComponent
        {
            if (!pendingComponents.TryGetValue(entityId, out var components))
                return;

            var componentType = ComponentType.Of<T>();
            if (components.TryGetValue(componentType, out var component))
            {
                var typed = (T)component;
                modifier(ref typed);
                components[componentType] = typed;
            }
        }
        #endregion

        #region Entity Management
        public void DestroyEntityDeferred(int entityId)
        {
            if (!markedForDestruction.Contains(entityId))
            {
                pendingDestructions.Enqueue(entityId);
                markedForDestruction.Add(entityId);
            }
        }

        public bool EntityExists(int entityId)
        {
            return entityArchetypes.ContainsKey(entityId)
                && !markedForDestruction.Contains(entityId);
        }

        public bool IsMarkedForDestruction(int entityId) => markedForDestruction.Contains(entityId);
        #endregion

        #region Query System
        public QueryDescription<T1> Query<T1>()
            where T1 : struct, IComponent
        {
            return new QueryDescription<T1>();
        }

        public QueryDescription<T1, T2> Query<T1, T2>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            return new QueryDescription<T1, T2>();
        }

        public QueryDescription<T1, T2, T3> Query<T1, T2, T3>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            return new QueryDescription<T1, T2, T3>();
        }

        public QueryDescription<T1, T2, T3, T4> Query<T1, T2, T3, T4>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
            where T4 : struct, IComponent
        {
            return new QueryDescription<T1, T2, T3, T4>();
        }
        #endregion

        #region Singleton Access

        // Public API - TFlag is the singleton identifier, T1 is the component we want
        public void GetSingletonComponents<TFlag, T1>(out T1 component1)
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
        {
            var cache = GetOrCreateSingletonCache<TFlag, T1>();
            component1 = ((T1[])cache.ComponentArrays[0])[cache.EntityIndex];
        }

        // Overload for two components
        public void GetSingletonComponents<TFlag, T1, T2>(out T1 component1, out T2 component2)
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            var cache = GetOrCreateSingletonCache<TFlag, T1, T2>();
            component1 = ((T1[])cache.ComponentArrays[0])[cache.EntityIndex];
            component2 = ((T2[])cache.ComponentArrays[1])[cache.EntityIndex];
        }

        // Overload for three components
        public void GetSingletonComponents<TFlag, T1, T2, T3>(
            out T1 component1,
            out T2 component2,
            out T3 component3
        )
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            var cache = GetOrCreateSingletonCache<TFlag, T1, T2, T3>();
            component1 = ((T1[])cache.ComponentArrays[0])[cache.EntityIndex];
            component2 = ((T2[])cache.ComponentArrays[1])[cache.EntityIndex];
            component3 = ((T3[])cache.ComponentArrays[2])[cache.EntityIndex];
        }

        // Private helper for one component
        private SingletonCache GetOrCreateSingletonCache<TFlag, T1>()
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();

            // Check existing cache
            if (
                singletonCaches.TryGetValue(flagType.Id, out var cache)
                && cache.IsValid
                && EntityExists(cache.EntityId)
            )
            {
                return cache;
            }

            // Cache miss - find the singleton entity
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(
                new[] { ComponentType.Of<SingletonFlag>(), flagType, ComponentType.Of<T1>() }
            );

            foreach (var archetype in matchingArchetypes)
            {
                var entities = archetype.Entities;
                for (int i = 0; i < archetype.Count; i++)
                {
                    int entityId = entities[i];
                    if (!IsMarkedForDestruction(entityId))
                    {
                        // Create new cache entry
                        cache = new SingletonCache
                        {
                            ComponentArrays = new[] { archetype.GetComponentArray<T1>() },
                            EntityIndex = i,
                            EntityId = entityId,
                            IsValid = true,
                        };

                        singletonCaches[flagType.Id] = cache;
                        return cache;
                    }
                }
            }

            throw new InvalidOperationException(
                $"No singleton found with flag {typeof(TFlag).Name} and component {typeof(T1).Name}"
            );
        }

        // Private helper for one component
        private SingletonCache GetOrCreateSingletonCache<TFlag, T1, T2>()
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();

            // Check existing cache
            if (
                singletonCaches.TryGetValue(flagType.Id, out var cache)
                && cache.IsValid
                && EntityExists(cache.EntityId)
            )
            {
                if (cache.ComponentArrays.Length == 2)
                {
                    return cache;
                }
                cache.IsValid = false;
            }

            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(
                new[]
                {
                    ComponentType.Of<SingletonFlag>(),
                    flagType,
                    ComponentType.Of<T1>(),
                    ComponentType.Of<T2>(),
                }
            );

            foreach (var archetype in matchingArchetypes)
            {
                var entities = archetype.Entities;
                for (int i = 0; i < archetype.Count; i++)
                {
                    int entityId = entities[i];
                    if (!IsMarkedForDestruction(entityId))
                    {
                        // Explicitly create an Array array with the correct size
                        Array[] componentArrays = new Array[2];
                        componentArrays[0] = archetype.GetComponentArray<T1>();
                        componentArrays[1] = archetype.GetComponentArray<T2>();

                        cache = new SingletonCache
                        {
                            ComponentArrays = componentArrays,
                            EntityIndex = i,
                            EntityId = entityId,
                            IsValid = true,
                        };

                        singletonCaches[flagType.Id] = cache;
                        return cache;
                    }
                }
            }

            throw new InvalidOperationException(
                $"No singleton found with flag {typeof(TFlag).Name} "
                    + $"and components {typeof(T1).Name}, {typeof(T2).Name}"
            );
        }

        private SingletonCache GetOrCreateSingletonCache<TFlag, T1, T2, T3>()
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();

            if (
                singletonCaches.TryGetValue(flagType.Id, out var cache)
                && cache.IsValid
                && EntityExists(cache.EntityId)
            )
            {
                if (cache.ComponentArrays.Length == 3)
                {
                    return cache;
                }
                cache.IsValid = false;
            }

            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(
                new[]
                {
                    ComponentType.Of<SingletonFlag>(),
                    flagType,
                    ComponentType.Of<T1>(),
                    ComponentType.Of<T2>(),
                    ComponentType.Of<T3>(),
                }
            );

            foreach (var archetype in matchingArchetypes)
            {
                var entities = archetype.Entities;
                for (int i = 0; i < archetype.Count; i++)
                {
                    int entityId = entities[i];
                    if (!IsMarkedForDestruction(entityId))
                    {
                        // Explicitly create and fill the array
                        Array[] componentArrays = new Array[3];
                        componentArrays[0] = archetype.GetComponentArray<T1>();
                        componentArrays[1] = archetype.GetComponentArray<T2>();
                        componentArrays[2] = archetype.GetComponentArray<T3>();

                        cache = new SingletonCache
                        {
                            ComponentArrays = componentArrays,
                            EntityIndex = i,
                            EntityId = entityId,
                            IsValid = true,
                        };

                        singletonCaches[flagType.Id] = cache;
                        return cache;
                    }
                }
            }

            throw new InvalidOperationException(
                $"No singleton found with flag {typeof(TFlag).Name} "
                    + $"and components {typeof(T1).Name}, {typeof(T2).Name}, {typeof(T3).Name}"
            );
        }

        #endregion

        #region Update System
        public void Update()
        {
            ProcessPendingCreations();
            ProcessPendingDestructions();
        }

        private void ProcessPendingCreations()
        {
            if (creationBatchSize == 0)
                return;

            var entitiesToUpdate = new List<int>();
            var processCount = Math.Min(OPERATIONS_PER_FRAME, creationBatchSize);

            for (int i = 0; i < processCount; i++)
            {
                if (pendingCreations.Count == 0)
                    break;

                var (template, modifier) = pendingCreations.Dequeue();
                int entityId = CreateEntityFromTemplate(template);

                modifier?.Invoke(entityId);
                entitiesToUpdate.Add(entityId);
            }

            if (entitiesToUpdate.Count > 0)
            {
                UpdateEntities(entitiesToUpdate);
                creationBatchSize -= entitiesToUpdate.Count;
            }
        }

        private void ProcessPendingDestructions()
        {
            int processCount = Math.Min(OPERATIONS_PER_FRAME, pendingDestructions.Count);

            for (int i = 0; i < processCount; i++)
            {
                if (pendingDestructions.Count == 0)
                    break;

                int entityId = pendingDestructions.Dequeue();
                markedForDestruction.Remove(entityId);

                if (entityArchetypes.TryGetValue(entityId, out var archetype))
                {
                    archetype.RemoveEntity(entityId);
                    entityArchetypes.Remove(entityId);
                    pendingOperationCount++;
                }
            }

            if (pendingOperationCount >= CLEANUP_THRESHOLD)
            {
                archetypeManager.CleanupEmptyArchetypes();
                pendingOperationCount = 0;
            }
        }

        public (int creations, int destructions) GetPendingOperationCounts() =>
            (creationBatchSize, pendingDestructions.Count);
        #endregion
    }

    public struct SingletonFlag : IComponent { }
}

================
File: World.cs.meta
================
fileFormatVersion: 2
guid: 7af841868c71a4655bb50385d1c61ad1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/repomix-output.txt.meta
================
fileFormatVersion: 2
guid: b028166130eaf4141806f82ed23a9377
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/SystemManager.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

namespace ECS_Core
{
    public interface IGameSystem
    {
        void Initialize();
        void Start();
        void Update();
        void Cleanup();
        bool AutoUpdate { get; set; }
        ArchetypeManager ArchetypeManager { get; set; }
    }

    public static class SystemManager
    {
        private static Dictionary<Type, IGameSystem> systems = new();
        private static bool isInitialized;

        public static void RegisterSystem<T>(T system)
            where T : struct, IGameSystem
        {
            if (systems.ContainsKey(typeof(T)))
            {
                Debug.LogWarning($"System {typeof(T)} is already registered. Skipping.");
                return;
            }

            systems[typeof(T)] = new GameSystemWrapper<T>(system);
        }

        public static ref T GetSystem<T>()
            where T : struct, IGameSystem
        {
            if (systems.TryGetValue(typeof(T), out var wrapper))
            {
                return ref ((GameSystemWrapper<T>)wrapper).System;
            }
            throw new KeyNotFoundException($"System {typeof(T)} not registered");
        }

        public static void InitializeSystems(World world)
        {
            if (isInitialized)
            {
                Debug.LogWarning("Systems are already initialized.");
                return;
            }

            foreach (var system in systems.Values)
            {
                try
                {
                    system.ArchetypeManager = world.ArchetypeManager;
                    system.Initialize();
                }
                catch (Exception e)
                {
                    Debug.LogError($"Failed to initialize system {system.GetType()}: {e}");
                }
            }

            isInitialized = true;
        }

        public static void SystemStart()
        {
            if (!isInitialized)
            {
                Debug.LogError("Systems not initialized. Call InitializeSystems first.");
                return;
            }
            foreach (var system in systems.Values)
            {
                // Only update systems that are enabled AND marked for auto-update
                if (((ISystemState)system).Enabled)
                {
                    try
                    {
                        system.Start();
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error Starting system {system.GetType()}: {e}");
                    }
                }
            }
        }

        public static void UpdateSystems()
        {
            if (!isInitialized)
            {
                Debug.LogError("Systems not initialized. Call InitializeSystems first.");
                return;
            }

            foreach (var system in systems.Values)
            {
                // Only update systems that are enabled AND marked for auto-update
                if (((ISystemState)system).Enabled && system.AutoUpdate)
                {
                    try
                    {
                        system.Update();
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error updating system {system.GetType()}: {e}");
                    }
                }
            }
        }

        public static void EnableSystem<T>()
            where T : struct, IGameSystem
        {
            if (systems.TryGetValue(typeof(T), out var system))
            {
                ((ISystemState)system).Enabled = true;
            }
        }

        public static void DisableSystem<T>()
            where T : struct, IGameSystem
        {
            if (systems.TryGetValue(typeof(T), out var system))
            {
                ((ISystemState)system).Enabled = false;
            }
        }

        public static void Clear()
        {
            if (!isInitialized)
                return;

            foreach (var system in systems.Values)
            {
                try
                {
                    system.Cleanup();
                }
                catch (Exception e)
                {
                    Debug.LogError($"Error cleaning up system {system.GetType()}: {e}");
                }
            }

            systems.Clear();
            isInitialized = false;
        }

        private interface ISystemState
        {
            bool Enabled { get; set; }
        }

        private class GameSystemWrapper<T> : IGameSystem, ISystemState
            where T : IGameSystem
        {
            public T System;
            public bool Enabled { get; set; } = true;
            public bool AutoUpdate
            {
                get => System.AutoUpdate;
                set => System.AutoUpdate = value;
            }
            public ArchetypeManager ArchetypeManager
            {
                get => System.ArchetypeManager;
                set => System.ArchetypeManager = value;
            }

            public GameSystemWrapper(T system)
            {
                System = system;
            }

            public void Initialize() => System.Initialize();

            public void Update() => System.Update();

            public void Cleanup() => System.Cleanup();

            public void Start() => System.Start();
        }
    }
}

// Example usage:

================
File: ECS_Core/SystemManager.cs.meta
================
fileFormatVersion: 2
guid: cce3b968c17691b4bb5a1a080cdc9340
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_Core/World.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ECS_Core
{
    public class World
    {
        private class SingletonCache
        {
            public Array[] ComponentArrays; // Array of component arrays for each type
            public int EntityIndex; // Index in the arrays where our singleton components live
            public int EntityId; // The singleton entity's ID
            public bool IsValid; // Cache validity flag
        }

        // Main cache storage - we use component type ID as the key for faster lookup
        private Dictionary<int, SingletonCache> singletonCaches = new();

        #region Static Access
        private static World activeWorld;
        public static World Active => activeWorld;

        public static void SetActiveWorld(World world) => activeWorld = world;
        #endregion

        #region Constants
        private const int CLEANUP_THRESHOLD = 100;
        private const int FIRST_NORMAL_ENTITY_ID = 1000;
        private const int OPERATIONS_PER_FRAME = 100;
        #endregion

        #region Fields
        private readonly ArchetypeManager archetypeManager = new();
        private readonly Dictionary<int, Archetype> entityArchetypes = new();
        private readonly Dictionary<int, Dictionary<ComponentType, object>> pendingComponents =
            new();
        private readonly Dictionary<string, Dictionary<ComponentType, object>> templates = new();
        private readonly Dictionary<string, Archetype> archetypeCache = new();
        private readonly Queue<int> pendingDestructions = new();
        private readonly HashSet<int> markedForDestruction = new();
        private readonly Queue<(string template, Action<int> modifier)> pendingCreations = new();

        private int nextEntityId = FIRST_NORMAL_ENTITY_ID;
        private int pendingOperationCount = 0;
        private int creationBatchSize = 0;
        #endregion

        public ArchetypeManager ArchetypeManager => archetypeManager;

        #region Entity Creation and Components

        public int CreateEntity()
        {
            var entityId = nextEntityId++;
            pendingComponents[entityId] = new Dictionary<ComponentType, object>();
            return entityId;
        }

        public void AddComponent<T>(int entityId, T component)
            where T : struct, IComponent
        {
            if (!pendingComponents.TryGetValue(entityId, out var components))
            {
                components = new Dictionary<ComponentType, object>();
                pendingComponents[entityId] = components;
            }

            components[ComponentType.Of<T>()] = component;
        }

        public void UpdateEntity(int entityId)
        {
            if (!pendingComponents.TryGetValue(entityId, out var components))
                return;

            // Check singleton uniqueness
            bool isSingleton = components.ContainsKey(ComponentType.Of<SingletonFlag>());
            if (isSingleton)
            {
                foreach (var componentType in components.Keys)
                {
                    if (componentType.Type == typeof(SingletonFlag))
                        continue;

                    bool singletonExists = false;
                    var query = new QueryDescription<SingletonFlag>();
                    query.ForEach(
                        archetypeManager,
                        (int existingId, ref SingletonFlag _) =>
                        {
                            if (!IsMarkedForDestruction(existingId))
                            {
                                var existingArchetype = entityArchetypes[existingId];
                                if (existingArchetype.HasComponent(componentType))
                                    singletonExists = true;
                            }
                        }
                    );

                    if (singletonExists)
                        throw new InvalidOperationException(
                            $"Singleton of type {componentType.Type.Name} already exists"
                        );
                }
            }

            var types = components.Keys.ToArray();
            var archetype = archetypeManager.GetOrCreateArchetype(types);
            archetype.Add(entityId, components);
            entityArchetypes[entityId] = archetype;
            pendingComponents.Remove(entityId);
        }

        public void UpdateEntities(IEnumerable<int> entityIds)
        {
            var entitiesByArchetype =
                new Dictionary<
                    string,
                    List<(int id, Dictionary<ComponentType, object> components)>
                >();

            foreach (var entityId in entityIds)
            {
                if (!pendingComponents.TryGetValue(entityId, out var components))
                    continue;

                var typeKey = string.Join(",", components.Keys.Select(t => t.Id).OrderBy(id => id));
                if (!entitiesByArchetype.TryGetValue(typeKey, out var list))
                {
                    list = new List<(int, Dictionary<ComponentType, object>)>();
                    entitiesByArchetype[typeKey] = list;
                }
                list.Add((entityId, components));
            }

            foreach (var group in entitiesByArchetype)
            {
                Archetype archetype;
                if (!archetypeCache.TryGetValue(group.Key, out archetype))
                {
                    var types = group.Value[0].components.Keys.ToArray();
                    archetype = archetypeManager.GetOrCreateArchetype(types);
                    archetypeCache[group.Key] = archetype;
                }

                foreach (var (entityId, components) in group.Value)
                {
                    archetype.Add(entityId, components);
                    entityArchetypes[entityId] = archetype;
                    pendingComponents.Remove(entityId);
                }
            }
        }
        #endregion

        #region Template System
        public void CreateTemplate(
            string templateName,
            Dictionary<ComponentType, object> components
        )
        {
            templates[templateName] = components;

            var types = components.Keys.ToArray();
            var typeKey = string.Join(",", types.Select(t => t.Id).OrderBy(id => id));
            if (!archetypeCache.ContainsKey(typeKey))
            {
                archetypeCache[typeKey] = archetypeManager.GetOrCreateArchetype(types);
            }
        }

        public int CreateEntityFromTemplate(string templateName)
        {
            if (!templates.TryGetValue(templateName, out var templateComponents))
                throw new ArgumentException($"Template {templateName} not found");

            var entityId = CreateEntity();
            var components = new Dictionary<ComponentType, object>(templateComponents);
            pendingComponents[entityId] = components;
            return entityId;
        }

        public void QueueEntityCreation(string templateName, Action<int> modifyComponents = null)
        {
            pendingCreations.Enqueue((templateName, modifyComponents));
            creationBatchSize++;
        }

        public void ModifyPendingComponent<T>(int entityId, ActionRef<T> modifier)
            where T : struct, IComponent
        {
            if (!pendingComponents.TryGetValue(entityId, out var components))
                return;

            var componentType = ComponentType.Of<T>();
            if (components.TryGetValue(componentType, out var component))
            {
                var typed = (T)component;
                modifier(ref typed);
                components[componentType] = typed;
            }
        }
        #endregion

        #region Entity Management
        public void DestroyEntityDeferred(int entityId)
        {
            if (!markedForDestruction.Contains(entityId))
            {
                pendingDestructions.Enqueue(entityId);
                markedForDestruction.Add(entityId);
            }
        }

        public bool EntityExists(int entityId)
        {
            return entityArchetypes.ContainsKey(entityId)
                && !markedForDestruction.Contains(entityId);
        }

        public bool IsMarkedForDestruction(int entityId) => markedForDestruction.Contains(entityId);
        #endregion

        #region Query System
        public QueryDescription<T1> Query<T1>()
            where T1 : struct, IComponent
        {
            return new QueryDescription<T1>();
        }

        public QueryDescription<T1, T2> Query<T1, T2>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            return new QueryDescription<T1, T2>();
        }

        public QueryDescription<T1, T2, T3> Query<T1, T2, T3>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            return new QueryDescription<T1, T2, T3>();
        }

        public QueryDescription<T1, T2, T3, T4> Query<T1, T2, T3, T4>()
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
            where T4 : struct, IComponent
        {
            return new QueryDescription<T1, T2, T3, T4>();
        }
        #endregion

        #region Singleton Access

        // Public API - TFlag is the singleton identifier, T1 is the component we want
        public void GetSingletonComponents<TFlag, T1>(out T1 component1)
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
        {
            var cache = GetOrCreateSingletonCache<TFlag, T1>();
            component1 = ((T1[])cache.ComponentArrays[0])[cache.EntityIndex];
        }

        // Overload for two components
        public void GetSingletonComponents<TFlag, T1, T2>(out T1 component1, out T2 component2)
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            var cache = GetOrCreateSingletonCache<TFlag, T1, T2>();
            component1 = ((T1[])cache.ComponentArrays[0])[cache.EntityIndex];
            component2 = ((T2[])cache.ComponentArrays[1])[cache.EntityIndex];
        }

        // Overload for three components
        public void GetSingletonComponents<TFlag, T1, T2, T3>(
            out T1 component1,
            out T2 component2,
            out T3 component3
        )
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            var cache = GetOrCreateSingletonCache<TFlag, T1, T2, T3>();
            component1 = ((T1[])cache.ComponentArrays[0])[cache.EntityIndex];
            component2 = ((T2[])cache.ComponentArrays[1])[cache.EntityIndex];
            component3 = ((T3[])cache.ComponentArrays[2])[cache.EntityIndex];
        }

        // Private helper for one component
        private SingletonCache GetOrCreateSingletonCache<TFlag, T1>()
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();

            // Check existing cache
            if (
                singletonCaches.TryGetValue(flagType.Id, out var cache)
                && cache.IsValid
                && EntityExists(cache.EntityId)
            )
            {
                return cache;
            }

            // Cache miss - find the singleton entity
            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(
                new[] { ComponentType.Of<SingletonFlag>(), flagType, ComponentType.Of<T1>() }
            );

            foreach (var archetype in matchingArchetypes)
            {
                var entities = archetype.Entities;
                for (int i = 0; i < archetype.Count; i++)
                {
                    int entityId = entities[i];
                    if (!IsMarkedForDestruction(entityId))
                    {
                        // Create new cache entry
                        cache = new SingletonCache
                        {
                            ComponentArrays = new[] { archetype.GetComponentArray<T1>() },
                            EntityIndex = i,
                            EntityId = entityId,
                            IsValid = true,
                        };

                        singletonCaches[flagType.Id] = cache;
                        return cache;
                    }
                }
            }

            throw new InvalidOperationException(
                $"No singleton found with flag {typeof(TFlag).Name} and component {typeof(T1).Name}"
            );
        }

        // Private helper for one component
        private SingletonCache GetOrCreateSingletonCache<TFlag, T1, T2>()
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();

            // Check existing cache
            if (
                singletonCaches.TryGetValue(flagType.Id, out var cache)
                && cache.IsValid
                && EntityExists(cache.EntityId)
            )
            {
                if (cache.ComponentArrays.Length == 2)
                {
                    return cache;
                }
                cache.IsValid = false;
            }

            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(
                new[]
                {
                    ComponentType.Of<SingletonFlag>(),
                    flagType,
                    ComponentType.Of<T1>(),
                    ComponentType.Of<T2>(),
                }
            );

            foreach (var archetype in matchingArchetypes)
            {
                var entities = archetype.Entities;
                for (int i = 0; i < archetype.Count; i++)
                {
                    int entityId = entities[i];
                    if (!IsMarkedForDestruction(entityId))
                    {
                        // Explicitly create an Array array with the correct size
                        Array[] componentArrays = new Array[2];
                        componentArrays[0] = archetype.GetComponentArray<T1>();
                        componentArrays[1] = archetype.GetComponentArray<T2>();

                        cache = new SingletonCache
                        {
                            ComponentArrays = componentArrays,
                            EntityIndex = i,
                            EntityId = entityId,
                            IsValid = true,
                        };

                        singletonCaches[flagType.Id] = cache;
                        return cache;
                    }
                }
            }

            throw new InvalidOperationException(
                $"No singleton found with flag {typeof(TFlag).Name} "
                    + $"and components {typeof(T1).Name}, {typeof(T2).Name}"
            );
        }

        private SingletonCache GetOrCreateSingletonCache<TFlag, T1, T2, T3>()
            where TFlag : struct, IComponent
            where T1 : struct, IComponent
            where T2 : struct, IComponent
            where T3 : struct, IComponent
        {
            var flagType = ComponentType.Of<TFlag>();

            if (
                singletonCaches.TryGetValue(flagType.Id, out var cache)
                && cache.IsValid
                && EntityExists(cache.EntityId)
            )
            {
                if (cache.ComponentArrays.Length == 3)
                {
                    return cache;
                }
                cache.IsValid = false;
            }

            var matchingArchetypes = archetypeManager.GetArchetypesWithComponents(
                new[]
                {
                    ComponentType.Of<SingletonFlag>(),
                    flagType,
                    ComponentType.Of<T1>(),
                    ComponentType.Of<T2>(),
                    ComponentType.Of<T3>(),
                }
            );

            foreach (var archetype in matchingArchetypes)
            {
                var entities = archetype.Entities;
                for (int i = 0; i < archetype.Count; i++)
                {
                    int entityId = entities[i];
                    if (!IsMarkedForDestruction(entityId))
                    {
                        // Explicitly create and fill the array
                        Array[] componentArrays = new Array[3];
                        componentArrays[0] = archetype.GetComponentArray<T1>();
                        componentArrays[1] = archetype.GetComponentArray<T2>();
                        componentArrays[2] = archetype.GetComponentArray<T3>();

                        cache = new SingletonCache
                        {
                            ComponentArrays = componentArrays,
                            EntityIndex = i,
                            EntityId = entityId,
                            IsValid = true,
                        };

                        singletonCaches[flagType.Id] = cache;
                        return cache;
                    }
                }
            }

            throw new InvalidOperationException(
                $"No singleton found with flag {typeof(TFlag).Name} "
                    + $"and components {typeof(T1).Name}, {typeof(T2).Name}, {typeof(T3).Name}"
            );
        }

        #endregion

        #region Update System
        public void Update()
        {
            ProcessPendingCreations();
            ProcessPendingDestructions();
        }

        private void ProcessPendingCreations()
        {
            if (creationBatchSize == 0)
                return;

            var entitiesToUpdate = new List<int>();
            var processCount = Math.Min(OPERATIONS_PER_FRAME, creationBatchSize);

            for (int i = 0; i < processCount; i++)
            {
                if (pendingCreations.Count == 0)
                    break;

                var (template, modifier) = pendingCreations.Dequeue();
                int entityId = CreateEntityFromTemplate(template);

                modifier?.Invoke(entityId);
                entitiesToUpdate.Add(entityId);
            }

            if (entitiesToUpdate.Count > 0)
            {
                UpdateEntities(entitiesToUpdate);
                creationBatchSize -= entitiesToUpdate.Count;
            }
        }

        private void ProcessPendingDestructions()
        {
            int processCount = Math.Min(OPERATIONS_PER_FRAME, pendingDestructions.Count);

            for (int i = 0; i < processCount; i++)
            {
                if (pendingDestructions.Count == 0)
                    break;

                int entityId = pendingDestructions.Dequeue();
                markedForDestruction.Remove(entityId);

                if (entityArchetypes.TryGetValue(entityId, out var archetype))
                {
                    archetype.RemoveEntity(entityId);
                    entityArchetypes.Remove(entityId);
                    pendingOperationCount++;
                }
            }

            if (pendingOperationCount >= CLEANUP_THRESHOLD)
            {
                archetypeManager.CleanupEmptyArchetypes();
                pendingOperationCount = 0;
            }
        }

        public (int creations, int destructions) GetPendingOperationCounts() =>
            (creationBatchSize, pendingDestructions.Count);
        #endregion
    }

    public struct SingletonFlag : IComponent { }
}

================
File: ECS_Core/World.cs.meta
================
fileFormatVersion: 2
guid: 7af841868c71a4655bb50385d1c61ad1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles.meta
================
fileFormatVersion: 2
guid: c3e721e338fb4413aa0a1cfcd0e37811
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles/DataComponent.meta
================
fileFormatVersion: 2
guid: 401cb534838cf40049f69183b5206b9c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles/DataComponent/CornerComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_Core;
using UnityEngine;

public struct CornerComponent : IComponent
{
    public Vector2 TopLeft;
    public Vector2 TopRight;
    public Vector2 BottomLeft;
    public Vector2 BottomRight;
}

================
File: ECS_MagicTiles/DataComponent/CornerComponent.cs.meta
================
fileFormatVersion: 2
guid: b96e4a6c6cb604761b6ec117819be5b4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles/DataComponent/LongNoteTagComponent.cs
================
using ECS_Core;
using UnityEngine;

public struct LongNoteTagComponent : IComponent { }

================
File: ECS_MagicTiles/DataComponent/LongNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 58353002a3593244d8bf12e61f349c98

================
File: ECS_MagicTiles/DataComponent/MusicNoteComponent.cs
================
using ECS_Core;

public struct MusicNoteComponent : IComponent
{
    public int PostionId;
    public float TimeAppear;
    public float Duration;
}

================
File: ECS_MagicTiles/DataComponent/MusicNoteComponent.cs.meta
================
fileFormatVersion: 2
guid: e13eda0f52da940ceaec30f721998b78
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles/DataComponent/PerfectLineTagComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_Core;
using UnityEngine;

public struct PerfectLineTagComponent : IComponent { }

================
File: ECS_MagicTiles/DataComponent/PerfectLineTagComponent.cs.meta
================
fileFormatVersion: 2
guid: e18089c9ed33d49f8b76960358f6a4d2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles/DataComponent/ShortNoteTagComponent.cs
================
using ECS_Core;
using UnityEngine;

public struct ShortNoteTagComponent : IComponent { }

================
File: ECS_MagicTiles/DataComponent/ShortNoteTagComponent.cs.meta
================
fileFormatVersion: 2
guid: 83c9ef9fdf039c843b9556bfba72a05a

================
File: ECS_MagicTiles/DataComponent/TransformComponent.cs
================
using ECS_Core;
using UnityEngine;

public struct TransformComponent : IComponent
{
    public Vector2 Posision;
    public Vector2 Size;
}

================
File: ECS_MagicTiles/DataComponent/TransformComponent.cs.meta
================
fileFormatVersion: 2
guid: ff2e94255bc1f499a986a60df04d62ec
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles/DTO.meta
================
fileFormatVersion: 2
guid: c3e7f3ef03f524e6089d969eb175e299
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles/DTO/MusicNoteMidiData.cs
================
using UnityEngine;

public struct MusicNoteMidiData : IDataComponent
{
    // Core data arrays
    public int[] Ids;
    public int[] NoteNumbers;
    public int[] PositionIds;
    public float[] TimeAppears;
    public float[] Timespans;
    public float[] Durations;
    public float[] Velocities;

    // Metadata
    public int TotalNotes;
    public float MinDuration;

    public MusicNoteMidiData(int capacity)
    {
        // Preallocate arrays with specified capacity
        Ids = new int[capacity];
        NoteNumbers = new int[capacity];
        TimeAppears = new float[capacity];
        Timespans = new float[capacity];
        Durations = new float[capacity];
        Velocities = new float[capacity];
        PositionIds = new int[capacity];

        TotalNotes = 0;
        MinDuration = float.MaxValue;
    }
}

================
File: ECS_MagicTiles/DTO/MusicNoteMidiData.cs.meta
================
fileFormatVersion: 2
guid: 0772d691d2fae418b83ddb22ddc64cc6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles/GlobalPoint.cs
================
using System;
using System.Collections.Generic;
using ECS_Core;
using UnityEngine;

public class GlobalPoint : PersistentSingleton<GlobalPoint>
{
    public PrefabSourceSO prefabSourceSO;
    public PerfectLineSettingSO perfectLineSettingSO;
    public TextAsset midiContent;
    public float gameSpeed;
    private World world;

    protected override void OnAwake()
    {
        base.OnAwake();

        try
        {
            InitializeECS();
            CreateTemplates();
            CreateSingletons();
            CreateEntity();
            RegisterSystems();
            SystemManager.InitializeSystems(world);
        }
        catch (Exception e)
        {
            Debug.LogError($"Failed to initialize game: {e}");
            // Handle initialization failure
        }
    }

    private void Start()
    {
        SystemManager.SystemStart();
    }

    private void Update()
    {
        SystemManager.UpdateSystems();
    }

    private void InitializeECS()
    {
        world = new World();
        World.SetActiveWorld(world);
    }

    private void RegisterSystems()
    {
        SystemManager.RegisterSystem(new MusicNoteCreationSystem());
    }

    private void CreateTemplates()
    {
        world.CreateTemplate(
            "MusicNote",
            new Dictionary<ComponentType, object>
            {
                { ComponentType.Of<MusicNoteComponent>(), new MusicNoteComponent() },
                { ComponentType.Of<TransformComponent>(), new TransformComponent() },
            }
        );
    }

    private void CreateEntity() { }

    private void CreateSingletons()
    {
        int perfectLineEntity = world.CreateEntity();
        world.AddComponent(perfectLineEntity, new SingletonFlag());
        world.AddComponent(perfectLineEntity, new PerfectLineTagComponent());
        world.AddComponent(
            perfectLineEntity,
            new CornerComponent
            {
                TopLeft = perfectLineSettingSO.TopLeft,
                TopRight = perfectLineSettingSO.TopRight,
                BottomLeft = perfectLineSettingSO.BottomLeft,
                BottomRight = perfectLineSettingSO.BottomRight,
            }
        );
        world.UpdateEntity(perfectLineEntity);
    }

    protected void OnDestroy()
    {
        SystemManager.Clear();
    }
}

================
File: ECS_MagicTiles/GlobalPoint.cs.meta
================
fileFormatVersion: 2
guid: 0240696fe8e234e4d9147334f546a78e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles/MidiNoteParser.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

public static class MidiNoteParser
{
    public static MusicNoteMidiData ParseFromText(string content)
    {
        if (string.IsNullOrEmpty(content))
            throw new MidiParseException("MIDI content cannot be empty");

        var entries = content.Split(',', StringSplitOptions.RemoveEmptyEntries);
        if (entries.Length == 0)
            throw new MidiParseException("No valid MIDI entries found");

        // Split into note entries
        var data = new MusicNoteMidiData(entries.Length);

        for (int i = 0; i < entries.Length; i++)
        {
            try
            {
                ParseEntry(entries[i], i, ref data);
                data.TotalNotes++;
            }
            catch (Exception ex)
            {
                throw new MidiParseException($"Error parsing entry {i}: {ex.Message}");
            }
        }

        ValidateData(ref data);

        return data;
    }

    private static void ParseEntry(string entry, int index, ref MusicNoteMidiData data)
    {
        var properties = entry.Split('-');
        var requiredFields = new HashSet<string> { "id", "n", "ta", "ts", "d", "v", "pid" };
        var parsedFields = new HashSet<string>();

        foreach (var prop in properties)
        {
            var kv = prop.Split(':');
            if (kv.Length != 2)
                throw new MidiParseException($"Invalid property format: {prop}");

            if (!ParseProperty(kv[0], kv[1], index, ref data))
                throw new MidiParseException($"Failed to parse property: {kv[0]}");

            parsedFields.Add(kv[0]);
        }

        // Check for missing required fields
        requiredFields.ExceptWith(parsedFields);
        if (requiredFields.Count > 0)
            throw new MidiParseException(
                $"Missing required fields: {string.Join(", ", requiredFields)}"
            );
    }

    private static bool ParseProperty(
        string key,
        string value,
        int index,
        ref MusicNoteMidiData data
    )
    {
        try
        {
            switch (key)
            {
                case "id":
                    data.Ids[index] = int.Parse(value);
                    break;
                case "n":
                    data.NoteNumbers[index] = int.Parse(value);
                    break;
                case "ta":
                    data.TimeAppears[index] = float.Parse(value);
                    break;
                case "ts":
                    data.Timespans[index] = float.Parse(value);
                    break;
                case "d":
                    float duration = float.Parse(value);
                    data.Durations[index] = duration;
                    data.MinDuration = Mathf.Min(data.MinDuration, duration);
                    break;
                case "v":
                    data.Velocities[index] = float.Parse(value);
                    break;
                case "pid":
                    data.PositionIds[index] = int.Parse(value);
                    break;
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static void ValidateData(ref MusicNoteMidiData data)
    {
        if (data.MinDuration <= 0)
            throw new MidiParseException("Invalid minimum duration");

        if (data.TotalNotes <= 0)
            throw new MidiParseException("No valid notes parsed");
    }
}

public class MidiParseException : Exception
{
    public MidiParseException(string message)
        : base(message) { }
}

================
File: ECS_MagicTiles/MidiNoteParser.cs.meta
================
fileFormatVersion: 2
guid: ccd8b8d0c202c4c46a3c94a768d54c37
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles/PrefabSourceSO.cs
================
using UnityEngine;

[CreateAssetMenu(fileName = "Prefab Source", menuName = "Setting/PrefabSource")]
public class PrefabSourceSO : ScriptableObject
{
    public GameObject longTilePrefab;
    public GameObject shortTilePrefab;
}

================
File: ECS_MagicTiles/PrefabSourceSO.cs.meta
================
fileFormatVersion: 2
guid: 4af6165a650c8884eab1106c52392163

================
File: ECS_MagicTiles/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-27T09:50:16.946Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
DataComponent/
  MusicNoteComponent.cs
  MusicNoteComponent.cs.meta
  TransformComponent.cs
  TransformComponent.cs.meta
DTO/
  MusicNoteMidiData.cs
  MusicNoteMidiData.cs.meta
Systems/
  MusicNoteCreationSystem.cs
  MusicNoteCreationSystem.cs.meta
DataComponent.meta
DTO.meta
GlobalPoint.cs
GlobalPoint.cs.meta
MidiNoteParser.cs
MidiNoteParser.cs.meta
Systems.meta

================================================================
Repository Files
================================================================

================
File: DataComponent/MusicNoteComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_Core;
using UnityEngine;

public struct MusicNoteComponent : IComponent
{
    public int PostionId;
    public float TimeAppear;
    public float Duration;
}

================
File: DataComponent/MusicNoteComponent.cs.meta
================
fileFormatVersion: 2
guid: e13eda0f52da940ceaec30f721998b78
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent/TransformComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using ECS_Core;
using UnityEngine;

public struct TransformComponent : IComponent
{
    public Vector2 Posision;
    public Vector2 Scale;
}

================
File: DataComponent/TransformComponent.cs.meta
================
fileFormatVersion: 2
guid: ff2e94255bc1f499a986a60df04d62ec
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DTO/MusicNoteMidiData.cs
================
using UnityEngine;

public struct MusicNoteMidiData : IDataComponent
{
    // Core data arrays
    public int[] Ids;
    public int[] NoteNumbers;
    public int[] PositionIds;
    public float[] TimeAppears;
    public float[] Timespans;
    public float[] Durations;
    public float[] Velocities;

    // Metadata
    public int TotalNotes;
    public float MinDuration;

    public MusicNoteMidiData(int capacity)
    {
        // Preallocate arrays with specified capacity
        Ids = new int[capacity];
        NoteNumbers = new int[capacity];
        TimeAppears = new float[capacity];
        Timespans = new float[capacity];
        Durations = new float[capacity];
        Velocities = new float[capacity];
        PositionIds = new int[capacity];

        TotalNotes = 0;
        MinDuration = float.MaxValue;
    }
}

================
File: DTO/MusicNoteMidiData.cs.meta
================
fileFormatVersion: 2
guid: 0772d691d2fae418b83ddb22ddc64cc6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems/MusicNoteCreationSystem.cs
================
using System.Collections;
using System.Collections.Generic;
using System.Net;
using ECS_Core;
using UnityEngine;

public struct MusicNoteCreationSystem : ECS_Core.IGameSystem
{
    public bool AutoUpdate { get; set; }
    public ArchetypeManager ArchetypeManager { get; set; }

    public void Cleanup()
    {
        //
    }

    public void Initialize()
    {
        AutoUpdate = false;
    }

    public void Start()
    {
        //
        MusicNoteMidiData musicNoteMidiData = MidiNoteParser.ParseFromText(
            GlobalPoint.Instance.midiContent.text
        );

        Debug.Log($"Total Notes; {musicNoteMidiData.TotalNotes}");

        var entitiesToUpdate = new List<int>();

        for (int i = 0; i < musicNoteMidiData.TotalNotes; i++)
        {
            int noteEntity = World.Active.CreateEntityFromTemplate("MusicNote");
            World.Active.ModifyPendingComponent(
                noteEntity,
                (ref MusicNoteComponent component) =>
                {
                    component.Duration = musicNoteMidiData.Durations[i];
                    component.PostionId = musicNoteMidiData.PositionIds[i];
                    component.TimeAppear = musicNoteMidiData.TimeAppears[i];

                    Debug.Log($"PosId: {component.PostionId}");
                    Debug.Log($"Duration: {component.Duration}");
                    Debug.Log($"TimeAppear: {component.TimeAppear}");
                }
            );

            entitiesToUpdate.Add(noteEntity);
        }

        World.Active.UpdateEntities(entitiesToUpdate);
    }

    public void Update()
    {
        //
    }
}

================
File: Systems/MusicNoteCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: c6c60a0f2af5b40aa9ceefcab19fa1d3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DataComponent.meta
================
fileFormatVersion: 2
guid: 401cb534838cf40049f69183b5206b9c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: DTO.meta
================
fileFormatVersion: 2
guid: c3e7f3ef03f524e6089d969eb175e299
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: GlobalPoint.cs
================
using System;
using System.Collections.Generic;
using ECS_Core;
using UnityEngine;

public class GlobalPoint : PersistentSingleton<GlobalPoint>
{
    public TextAsset midiContent;
    private World world;

    protected override void OnAwake()
    {
        base.OnAwake();

        try
        {
            InitializeECS();
            CreateTemplates();
            CreateSingletons();
            CreateEntity();
            RegisterSystems();
            SystemManager.InitializeSystems(world);
        }
        catch (Exception e)
        {
            Debug.LogError($"Failed to initialize game: {e}");
            // Handle initialization failure
        }
    }

    private void Start()
    {
        SystemManager.SystemStart();
    }

    private void Update()
    {
        SystemManager.UpdateSystems();
    }

    private void InitializeECS()
    {
        world = new World();
        World.SetActiveWorld(world);
    }

    private void RegisterSystems()
    {
        // SystemManager.RegisterSystem(new MockDebugSystem());
        SystemManager.RegisterSystem(new MusicNoteCreationSystem());
    }

    private void CreateTemplates()
    {
        world.CreateTemplate(
            "MusicNote",
            new Dictionary<ComponentType, object>
            {
                { ComponentType.Of<MusicNoteComponent>(), new MusicNoteComponent() },
            }
        );
    }

    private void CreateEntity() { }

    private void CreateSingletons() { }

    protected void OnDestroy()
    {
        SystemManager.Clear();
    }
}

================
File: GlobalPoint.cs.meta
================
fileFormatVersion: 2
guid: 0240696fe8e234e4d9147334f546a78e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MidiNoteParser.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

public static class MidiNoteParser
{
    public static MusicNoteMidiData ParseFromText(string content)
    {
        if (string.IsNullOrEmpty(content))
            throw new MidiParseException("MIDI content cannot be empty");

        var entries = content.Split(',', StringSplitOptions.RemoveEmptyEntries);
        if (entries.Length == 0)
            throw new MidiParseException("No valid MIDI entries found");

        // Split into note entries
        var data = new MusicNoteMidiData(entries.Length);

        for (int i = 0; i < entries.Length; i++)
        {
            try
            {
                ParseEntry(entries[i], i, ref data);
                data.TotalNotes++;
            }
            catch (Exception ex)
            {
                throw new MidiParseException($"Error parsing entry {i}: {ex.Message}");
            }
        }

        ValidateData(ref data);

        return data;
    }

    private static void ParseEntry(string entry, int index, ref MusicNoteMidiData data)
    {
        var properties = entry.Split('-');
        var requiredFields = new HashSet<string> { "id", "n", "ta", "ts", "d", "v", "pid" };
        var parsedFields = new HashSet<string>();

        foreach (var prop in properties)
        {
            var kv = prop.Split(':');
            if (kv.Length != 2)
                throw new MidiParseException($"Invalid property format: {prop}");

            if (!ParseProperty(kv[0], kv[1], index, ref data))
                throw new MidiParseException($"Failed to parse property: {kv[0]}");

            parsedFields.Add(kv[0]);
        }

        // Check for missing required fields
        requiredFields.ExceptWith(parsedFields);
        if (requiredFields.Count > 0)
            throw new MidiParseException(
                $"Missing required fields: {string.Join(", ", requiredFields)}"
            );
    }

    private static bool ParseProperty(
        string key,
        string value,
        int index,
        ref MusicNoteMidiData data
    )
    {
        try
        {
            switch (key)
            {
                case "id":
                    data.Ids[index] = int.Parse(value);
                    break;
                case "n":
                    data.NoteNumbers[index] = int.Parse(value);
                    break;
                case "ta":
                    data.TimeAppears[index] = float.Parse(value);
                    break;
                case "ts":
                    data.Timespans[index] = float.Parse(value);
                    break;
                case "d":
                    float duration = float.Parse(value);
                    data.Durations[index] = duration;
                    data.MinDuration = Mathf.Min(data.MinDuration, duration);
                    break;
                case "v":
                    data.Velocities[index] = float.Parse(value);
                    break;
                case "pid":
                    data.PositionIds[index] = int.Parse(value);
                    break;
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static void ValidateData(ref MusicNoteMidiData data)
    {
        if (data.MinDuration <= 0)
            throw new MidiParseException("Invalid minimum duration");

        if (data.TotalNotes <= 0)
            throw new MidiParseException("No valid notes parsed");
    }
}

public class MidiParseException : Exception
{
    public MidiParseException(string message)
        : base(message) { }
}

================
File: MidiNoteParser.cs.meta
================
fileFormatVersion: 2
guid: ccd8b8d0c202c4c46a3c94a768d54c37
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Systems.meta
================
fileFormatVersion: 2
guid: 17861d9c20e3049fe97ef4d578457076
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles/repomix-output.txt.meta
================
fileFormatVersion: 2
guid: 14d12379fae474020aa008d7372d8ea9
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles/SceneObjectSpawner.cs
================
using UnityEngine;

public class SceneObjectSpawner { }

================
File: ECS_MagicTiles/SceneObjectSpawner.cs.meta
================
fileFormatVersion: 2
guid: fc9c6f76a2c5e3e429da077f4c6b84fb

================
File: ECS_MagicTiles/Systems.meta
================
fileFormatVersion: 2
guid: 17861d9c20e3049fe97ef4d578457076
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ECS_MagicTiles/Systems/MusicNoteCreationSystem.cs
================
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Net;
using ECS_Core;
using UnityEngine;

public struct MusicNoteCreationSystem : ECS_Core.IGameSystem
{
    public bool AutoUpdate { get; set; }
    public ArchetypeManager ArchetypeManager { get; set; }

    public void Initialize()
    {
        AutoUpdate = false;
    }

    public void Start()
    {
        //
        MusicNoteMidiData musicNoteMidiData = MidiNoteParser.ParseFromText(
            GlobalPoint.Instance.midiContent.text
        );

        Debug.Log($"Total Notes; {musicNoteMidiData.TotalNotes}");

        var entitiesToUpdate = new List<int>();

        World.Active.GetSingletonComponents<PerfectLineTagComponent, CornerComponent>(
            out CornerComponent perfectLine
        );

        Debug.Log("Perfect Line topleft: " + perfectLine.TopLeft);

        // Calculate lane width once
        float totalWidth = perfectLine.TopRight.x - perfectLine.TopLeft.x;
        float laneWidth = totalWidth / 4;
        float halfLaneWidth = laneWidth / 2f;

        for (int i = 0; i < musicNoteMidiData.TotalNotes; i++)
        {
            int noteEntity = World.Active.CreateEntityFromTemplate("MusicNote");
            World.Active.ModifyPendingComponent(
                noteEntity,
                (ref MusicNoteComponent component) =>
                {
                    component.Duration = musicNoteMidiData.Durations[i];
                    component.PostionId = musicNoteMidiData.PositionIds[i];
                    component.TimeAppear = musicNoteMidiData.TimeAppears[i];
                }
            );

            World.Active.ModifyPendingComponent(
                noteEntity,
                (ref TransformComponent component) =>
                {
                    float spawnX =
                        perfectLine.TopLeft.x
                        + (musicNoteMidiData.PositionIds[i] * laneWidth)
                        + halfLaneWidth;

                    float spawnY =
                        perfectLine.TopLeft.y
                        + (musicNoteMidiData.TimeAppears[i] * GlobalPoint.Instance.gameSpeed)
                        + component.Size.y / 2f;

                    component.Posision = new Vector2(spawnX, spawnY);
                }
            );

            if (
                musicNoteMidiData
                    .Durations[i]
                    .IsInRange(musicNoteMidiData.MinDuration, musicNoteMidiData.MinDuration + 0.01f)
            )
            {
                World.Active.AddComponent(noteEntity, new ShortNoteTagComponent());
            }
            else if (musicNoteMidiData.Durations[i] > musicNoteMidiData.MinDuration)
            {
                World.Active.AddComponent(noteEntity, new LongNoteTagComponent());
            }

            entitiesToUpdate.Add(noteEntity);
        }

        World.Active.UpdateEntities(entitiesToUpdate);
    }

    public void Update()
    {
        //
    }

    public void Cleanup()
    {
        //
    }
}

================
File: ECS_MagicTiles/Systems/MusicNoteCreationSystem.cs.meta
================
fileFormatVersion: 2
guid: c6c60a0f2af5b40aa9ceefcab19fa1d3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: ExampleMIddiNote.txt
================
id:0-n:96-ta:2.0978255625-ts:2.0978255625-d:0.5217390000000001-v:56-pid:0,id:1-n:97-ta:2.6195645625000004-ts:0.5217390000000002-d:0.5217390000000001-v:56-pid:1,id:2-n:99-ta:3.1413035625-ts:0.5217389999999997-d:0.13043475000000002-v:56-pid:3,id:3-n:96-ta:3.4021730625-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:0,id:4-n:97-ta:3.6630425625000003-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:1,id:5-n:99-ta:4.0543468125-ts:0.39130425000000013-d:0.13043475000000002-v:56-pid:3,id:6-n:98-ta:4.4456510625000005-ts:0.39130425000000013-d:0.13043475000000002-v:56-pid:2,id:7-n:96-ta:4.706520562500001-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:0,id:8-n:97-ta:4.967390062500001-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:1,id:9-n:99-ta:5.228259562500001-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:3,id:10-n:96-ta:5.4891290625-ts:0.2608694999999992-d:0.13043475000000002-v:56-pid:0,id:11-n:97-ta:5.7499985625-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:1,id:12-n:99-ta:6.1413028125-ts:0.39130425000000013-d:0.13043475000000002-v:56-pid:3,id:13-n:98-ta:6.5326070625-ts:0.39130425000000013-d:0.13043475000000002-v:56-pid:2,id:14-n:96-ta:6.7934765625-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:0,id:15-n:97-ta:7.0543460625000005-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:1,id:16-n:99-ta:7.315215562500001-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:3,id:17-n:96-ta:7.576085062500001-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:0,id:18-n:97-ta:7.836954562500001-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:1,id:19-n:99-ta:8.2282588125-ts:0.39130424999999924-d:0.13043475000000002-v:56-pid:3,id:20-n:98-ta:8.619563062500001-ts:0.391304250000001-d:0.13043475000000002-v:56-pid:2,id:21-n:96-ta:8.880432562500001-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:0,id:22-n:97-ta:9.141302062500001-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:1,id:23-n:98-ta:9.402171562500001-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:2,id:24-n:96-ta:10.4456495625-ts:1.0434779999999986-d:0.5217390000000001-v:56-pid:0,id:25-n:97-ta:10.9673885625-ts:0.5217390000000002-d:0.5217390000000001-v:56-pid:1,id:26-n:99-ta:11.4891275625-ts:0.5217390000000002-d:0.13043475000000002-v:56-pid:3,id:27-n:96-ta:11.7499970625-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:0,id:28-n:97-ta:12.0108665625-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:1,id:29-n:99-ta:12.402170812500001-ts:0.391304250000001-d:0.13043475000000002-v:56-pid:3,id:30-n:98-ta:12.7934750625-ts:0.39130424999999924-d:0.13043475000000002-v:56-pid:2,id:31-n:96-ta:13.0543445625-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:0,id:32-n:97-ta:13.3152140625-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:1,id:33-n:99-ta:13.576083562500001-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:3,id:34-n:96-ta:13.836953062500001-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:0,id:35-n:97-ta:14.097822562500001-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:1,id:36-n:99-ta:14.4891268125-ts:0.39130424999999924-d:0.13043475000000002-v:56-pid:3,id:37-n:98-ta:14.880431062500001-ts:0.391304250000001-d:0.13043475000000002-v:56-pid:2,id:38-n:96-ta:15.141300562500001-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:0,id:39-n:97-ta:15.402170062500002-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:1,id:40-n:99-ta:15.663039562500002-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:3,id:41-n:96-ta:15.923909062500002-ts:0.2608695000000001-d:0.13043475000000002-v:56-pid:0,id:42-n:97-ta:16.1847785625-ts:0.2608694999999983-d:0.13043475000000002-v:56-pid:1,id:43-n:99-ta:16.5760828125-ts:0.391304250000001-d:0.13043475000000002-v:56-pid:3,id:44-n:98-ta:16.967387062500002-ts:0.391304250000001-d:0.13043475000000002-v:56-pid:2,id:45-n:96-ta:17.2282565625-ts:0.2608694999999983-d:0.13043475000000002-v:56-pid:0,id:46-n:97-ta:17.489126062500002-ts:0.26086950000000186-d:0.13043475000000002-v:56-pid:1,id:47-n:98-ta:17.7499955625-ts:0.2608694999999983-d:0.13043475000000002-v:56-pid:2

================
File: ExampleMIddiNote.txt.meta
================
fileFormatVersion: 2
guid: 5651cca0434e843a4af2569038996f88
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles.meta
================
fileFormatVersion: 2
guid: b690df16c138a504ca8be92598f49859
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomEditor.meta
================
fileFormatVersion: 2
guid: c78b02fd4e8324da8af7636364c64841
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomEditor/GlobalGameSettingEditor.cs
================
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(GlobalGameSetting))]
public class GlobalGameSettingEditor : Editor
{
    public override void OnInspectorGUI()
    {
        // Draw the default inspector UI
        DrawDefaultInspector();

        // Add a button to display Game View dimensions
        if (GUILayout.Button("Show Simulator Screen Dimensions"))
        {
            // Get the Game View size
            Vector2 gameViewSize = GetMainGameViewSize();
            Debug.Log($"Game View Width: {gameViewSize.x}, Game View Height: {gameViewSize.y}");
        }
    }

    private Vector2 GetMainGameViewSize()
    {
        // Use UnityEditor.Handles to get the Game View size
        return UnityEditor.Handles.GetMainGameViewSize();
    }
}
#endif

================
File: MagicTiles/CustomEditor/GlobalGameSettingEditor.cs.meta
================
fileFormatVersion: 2
guid: 9f98f964be2154f68b612a170c6262e9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary.meta
================
fileFormatVersion: 2
guid: 3ceffd0e0680040d3a6294f82b4d1174
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/CameraViewUtils.cs
================
using UnityEngine;

public static class CameraViewUtils
{
    /// <summary>
    /// Gets the camera view boundaries in world units
    /// </summary>
    public static Rect GetCameraViewBounds(Camera camera)
    {
        if (!camera.orthographic)
        {
            Debug.LogWarning("GetCameraViewBounds is designed for orthographic cameras");
        }

        float height = camera.orthographicSize * 2f;
        float width = height * camera.aspect;

        // Calculate boundaries based on camera position
        float leftBound = camera.transform.position.x - width / 2f;
        float rightBound = camera.transform.position.x + width / 2f;
        float bottomBound = camera.transform.position.y - height / 2f;
        float topBound = camera.transform.position.y + height / 2f;

        return new Rect(leftBound, bottomBound, width, height);
    }

    /// <summary>
    /// Gets position within camera view based on normalized coordinates (0-1)
    /// </summary>
    public static Vector3 GetPositionInCameraView(
        Camera camera,
        float normalizedX,
        float normalizedY,
        float z = 0f
    )
    {
        Rect bounds = GetCameraViewBounds(camera);

        float x = Mathf.Lerp(bounds.xMin, bounds.xMax, normalizedX);
        float y = Mathf.Lerp(bounds.yMin, bounds.yMax, normalizedY);

        return new Vector3(x, y, z);
    }

    /// <summary>
    /// Calculates scale needed to make sprite fill specified portion of camera view
    /// </summary>
    public static Vector2 CalculateScaleInCameraView(
        Camera camera,
        Sprite sprite,
        float widthPercentage,
        float heightPercentage,
        bool maintainAspectRatio = true
    )
    {
        if (sprite == null)
            return Vector2.one;

        // Get sprite's original size in world units
        Vector2 spriteSize = sprite.bounds.size;

        // Calculate camera view size in world units
        float cameraHeight = camera.orthographicSize * 2f;
        float cameraWidth = cameraHeight * camera.aspect;

        // Calculate target size in world units
        float targetWidth = cameraWidth * widthPercentage;
        float targetHeight = cameraHeight * heightPercentage;

        // Calculate required scale
        Vector2 scale = new Vector2(targetWidth / spriteSize.x, targetHeight / spriteSize.y);

        if (maintainAspectRatio)
        {
            float minScale = Mathf.Min(scale.x, scale.y);
            scale.x = minScale;
            scale.y = minScale;
        }

        return scale;
    }

    public enum CameraBoundCheck
    {
        Top,
        Bottom,
        Right,
        Left,
        All,
    }

    /// <summary>
    /// Checks if a position is out of camera bounds for the specified check type
    /// </summary>
    /// <param name="camera">The camera to check bounds against</param>
    /// <param name="position">The world position to check</param>
    /// <param name="boundCheck">The type of bound check to perform</param>
    /// <param name="padding">Optional padding to add to the bounds (can be negative to shrink bounds)</param>
    /// <returns>True if the position is out of bounds for the specified check</returns>
    public static bool IsPositionOutOfBounds(
        Camera camera,
        Vector3 position,
        CameraBoundCheck boundCheck,
        float padding = 0f
    )
    {
        Rect bounds = GetCameraViewBounds(camera);

        // Apply padding
        bounds.xMin += padding;
        bounds.xMax -= padding;
        bounds.yMin += padding;
        bounds.yMax -= padding;

        return boundCheck switch
        {
            CameraBoundCheck.Top => position.y > bounds.yMax,
            CameraBoundCheck.Bottom => position.y < bounds.yMin,
            CameraBoundCheck.Left => position.x < bounds.xMin,
            CameraBoundCheck.Right => position.x > bounds.xMax,
            CameraBoundCheck.All => !bounds.Contains(new Vector2(position.x, position.y)),
            _ => false,
        };
    }
}

================
File: MagicTiles/CustomLibrary/CameraViewUtils.cs.meta
================
fileFormatVersion: 2
guid: e6d42bb3380cbfa4e9810dbe46523c02
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/ChunkArray.cs
================
using System;
using System.Collections.Generic;

public class ChunkArray<T>
{
    private readonly int chunkSize;
    private T[][] chunks;
    private int count;
    private int capacity;
    private readonly Stack<(int, int)> freeIndices;

    public int Count => count;
    public int Capacity => capacity;

    public ChunkArray(int initialCapacity, int chunkSize = 128)
    {
        if (initialCapacity < 0)
        {
            throw new ArgumentException(
                "Initial capacity must be non-negative",
                nameof(initialCapacity)
            );
        }
        if (chunkSize <= 0)
        {
            throw new ArgumentException("Chunk size must be positive", nameof(chunkSize));
        }

        this.chunkSize = chunkSize;
        int initialChunks = (initialCapacity + chunkSize - 1) / chunkSize;
        chunks = new T[initialChunks][];
        for (int i = 0; i < chunks.Length; i++)
        {
            chunks[i] = new T[chunkSize];
        }

        capacity = initialChunks * chunkSize;
        freeIndices = new Stack<(int, int)>();
    }

    public void Add(T item)
    {
        int chunkIndex,
            elementIndex;

        if (freeIndices.Count > 0)
        {
            (chunkIndex, elementIndex) = freeIndices.Pop();
        }
        else
        {
            if (count == capacity)
            {
                GrowChunks();
            }

            chunkIndex = count / chunkSize;
            elementIndex = count % chunkSize;
        }

        chunks[chunkIndex][elementIndex] = item;
        count++;
    }

    public void Remove(int index)
    {
        if (index < 0 || index >= count)
        {
            throw new IndexOutOfRangeException();
        }

        int chunkIndex = index / chunkSize;
        int elementIndex = index % chunkSize;

        chunks[chunkIndex][elementIndex] = default;
        freeIndices.Push((chunkIndex, elementIndex));
        count--;
    }

    public T Get(int index)
    {
        if (index < 0 || index >= count)
            throw new IndexOutOfRangeException();
        int chunkIndex = index / chunkSize;
        int elementIndex = index % chunkSize;
        return chunks[chunkIndex][elementIndex];
    }

    public void Set(int index, T value)
    {
        if (index < 0 || index >= count)
            throw new ArgumentOutOfRangeException(nameof(index));

        int chunkIndex = index / chunkSize;
        int elementIndex = index % chunkSize;
        chunks[chunkIndex][elementIndex] = value;
    }

    //Private Helper Methods
    private void GrowChunks()
    {
        int newChunkIndex = chunks.Length;
        Array.Resize(ref chunks, newChunkIndex + 1);
        chunks[newChunkIndex] = new T[chunkSize];
        capacity += chunkSize;
    }

    public void Clear()
    {
        count = 0;
        freeIndices.Clear();

        // Optional: Clear array contents
        for (int i = 0; i < chunks.Length; i++)
        {
            Array.Clear(chunks[i], 0, chunks[i].Length);
        }
    }
}

================
File: MagicTiles/CustomLibrary/ChunkArray.cs.meta
================
fileFormatVersion: 2
guid: e0db1794adab346a99885a51e1015527
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/EventChannel.meta
================
fileFormatVersion: 2
guid: 4ab889a21e9202f478374a9522356240
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/EventChannel/EventChannelSO.cs
================
using System;
using UnityEngine;

public class EventChannelSO<T> : ScriptableObject
    where T : IEventData
{
    [SerializeField]
    private int maxListeners = 8;
    private Action<T>[] listeners;
    private T lastEventData;
    private bool hasEventOccurred;
    private readonly object lockObject = new object();

    private void InitializeIfNeeded()
    {
        if (listeners == null)
        {
            listeners = new Action<T>[maxListeners];
        }
    }

    public void RaiseEvent(T eventData)
    {
        if (eventData == null)
        {
            Debug.LogError($"Attempted to raise null event data in {name}");
            return;
        }

        lock (lockObject)
        {
            lastEventData = eventData;
            hasEventOccurred = true;

            for (int i = 0; i < listeners.Length; i++)
            {
                if (listeners[i] != null)
                {
                    try
                    {
                        listeners[i].Invoke(eventData);
                    }
                    catch (Exception e)
                    {
                        Debug.LogError($"Error invoking event listener in {name}: {e}");
                    }
                }
            }
        }
    }

    public bool Subscribe(Action<T> listener, bool invokeLastEvent = false)
    {
        if (listener == null)
        {
            Debug.LogError($"Attempted to subscribe null listener to {name}");
            return false;
        }

        lock (lockObject)
        {
            InitializeIfNeeded();

            for (int i = 0; i < listeners.Length; i++)
            {
                if (listeners[i] == listener)
                {
                    Debug.LogWarning($"Attempted to subscribe duplicate listener to {name}");
                    return false;
                }
            }

            for (int i = 0; i < listeners.Length; i++)
            {
                if (listeners[i] == null)
                {
                    listeners[i] = listener;

                    if (invokeLastEvent && hasEventOccurred)
                    {
                        try
                        {
                            listener.Invoke(lastEventData);
                        }
                        catch (Exception e)
                        {
                            Debug.LogError($"Error invoking late subscriber in {name}: {e}");
                        }
                    }
                    return true;
                }
            }

            Debug.LogError(
                $"Failed to subscribe listener to {name}: Maximum listeners ({maxListeners}) reached"
            );
            return false;
        }
    }

    public void Unsubscribe(Action<T> listener)
    {
        if (listener == null || listeners == null)
            return;

        lock (lockObject)
        {
            for (int i = 0; i < listeners.Length; i++)
            {
                if (listeners[i] == listener)
                {
                    listeners[i] = null;
                    return;
                }
            }
        }
    }
}

================
File: MagicTiles/CustomLibrary/EventChannel/EventChannelSO.cs.meta
================
fileFormatVersion: 2
guid: c5aa02254343f1345b025a781a5f5af0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/EventChannel/IEventData.cs
================
public interface IEventData { }

================
File: MagicTiles/CustomLibrary/EventChannel/IEventData.cs.meta
================
fileFormatVersion: 2
guid: 5c076fb1bc1c2e64298ae293789fe45c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/EventChannel/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-27T04:41:44.504Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
BaseEventChannelSO.cs
BaseEventChannelSO.cs.meta
EventChannelSO.cs
EventChannelSO.cs.meta
IEventData.cs
IEventData.cs.meta

================================================================
Repository Files
================================================================

================
File: BaseEventChannelSO.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

public class BaseEventChannelSO : ScriptableObject
{
    protected readonly HashSet<WeakReference> listeners = new();

    protected void CleanupListeners()
    {
        listeners.RemoveWhere(weakRef => !weakRef.IsAlive);
    }
}

================
File: BaseEventChannelSO.cs.meta
================
fileFormatVersion: 2
guid: 03683e9b47d0bf74e8a2f453fa323329
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: EventChannelSO.cs
================
using System;
using System.Collections.Generic;
using UnityEngine;

public class EventChannelSO<T> : BaseEventChannelSO
    where T : IEventData
{
    private readonly List<Action<T>> onEventRaised = new();

    public void RaiseEvent(T eventData)
    {
        CleanupListeners();

        for (int i = onEventRaised.Count - 1; i >= 0; i--)
        {
            try
            {
                onEventRaised[i]?.Invoke(eventData);
            }
            catch (Exception e)
            {
                Debug.LogError($"Error invoking event listener: {e}");
            }
        }
    }

    public void Subscribe(Action<T> listener)
    {
        if (!onEventRaised.Contains(listener))
        {
            onEventRaised.Add(listener);
            listeners.Add(new WeakReference(listener.Target));
        }
    }

    public void Unsubscribe(Action<T> listener)
    {
        onEventRaised.Remove(listener);
        CleanupListeners();
    }
}

================
File: EventChannelSO.cs.meta
================
fileFormatVersion: 2
guid: c5aa02254343f1345b025a781a5f5af0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: IEventData.cs
================
public interface IEventData { }

================
File: IEventData.cs.meta
================
fileFormatVersion: 2
guid: 5c076fb1bc1c2e64298ae293789fe45c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/EventChannel/repomix-output.txt.meta
================
fileFormatVersion: 2
guid: 9489295e393fb483bbfb1f4f5100b4fe
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/HelperExtension.cs
================
using UnityEngine;

public static class HelperExtension
{
    public static bool IsInRange(this float value, float from, float to)
    {
        if (value >= from && value < to)
        {
            return true;
        }
        return false;
    }
}

================
File: MagicTiles/CustomLibrary/HelperExtension.cs.meta
================
fileFormatVersion: 2
guid: e7c93eb08d2e94246b3fffb6460d232d

================
File: MagicTiles/CustomLibrary/ManualDebug.meta
================
fileFormatVersion: 2
guid: 8f014a15625f2413ab47d1e0c57fce71
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/ManualDebug/DebugHandler.cs
================
using UnityEngine;

public abstract class BaseDebugHandler
{
    protected BaseDebugHandler _next;
    protected string _message;
    protected object[] _args;

    public void Initialize(string message, object[] args)
    {
        _message = message;
        _args = args;
    }

    public BaseDebugHandler SetNext(BaseDebugHandler handler)
    {
        _next = handler;
        return this;
    }

    public abstract void Execute();

    protected string FormatMessage()
    {
        return _args != null ? string.Format(_message, _args) : _message;
    }
}

public class NormalLog : BaseDebugHandler
{
    public override void Execute()
    {
        Debug.Log(FormatMessage());
        _next?.Execute();
    }
}

public class WarningLog : BaseDebugHandler
{
    public override void Execute()
    {
        Debug.LogWarning(FormatMessage());
        _next?.Execute();
    }
}

public class ErrorLog : BaseDebugHandler
{
    public override void Execute()
    {
        Debug.LogError(FormatMessage());
        _next?.Execute();
    }
}

public class LogBreak : BaseDebugHandler
{
    public override void Execute()
    {
        if (!string.IsNullOrEmpty(_message))
        {
            Debug.Log(FormatMessage());
        }
        Debug.Break();
        _next?.Execute();
    }
}

================
File: MagicTiles/CustomLibrary/ManualDebug/DebugHandler.cs.meta
================
fileFormatVersion: 2
guid: 430800b410a1e404abfa9a64e6d707ed
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/ManualDebug/ManualDebug.cs
================
using System;
using UnityEngine;

public class ManualDebug : MonoBehaviour
{
    private static ManualDebug _instance;
    private static bool _isTriggered;

    [SerializeField]
    private KeyCode triggerKey = KeyCode.F9;

    [SerializeField]
    private bool enableDebugging = true;

    private void Awake()
    {
        if (_instance != null && _instance != this)
        {
            Destroy(gameObject);
            return;
        }

        _instance = this;
        DontDestroyOnLoad(gameObject);
    }

    private void Update()
    {
        if (!enableDebugging)
            return;
        _isTriggered = Input.GetKeyDown(triggerKey);
    }

    // Simple factory method for creating debug handlers
    public static T CreateLog<T>(string message, params object[] args)
        where T : BaseDebugHandler, new()
    {
        if (_isTriggered)
        {
            var handler = new T();
            handler.Initialize(message, args);
            return handler;
        }

        return null;
    }
}

================
File: MagicTiles/CustomLibrary/ManualDebug/ManualDebug.cs.meta
================
fileFormatVersion: 2
guid: 27983b87a7f994308b3cff096e7df0b0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/NativeObjectPool.meta
================
fileFormatVersion: 2
guid: a64980356e88042879172f8a954be750
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/NativeObjectPool/INativePool.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface INativePool<T>
    where T : class
{
    T Get();
    void Return(T item);
    void Clear();
}

================
File: MagicTiles/CustomLibrary/NativeObjectPool/INativePool.cs.meta
================
fileFormatVersion: 2
guid: a9cb61feb98b84998a0d3da4635b1c56
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/NativeObjectPool/NativePool.cs
================
using System;
using UnityEngine;

public class NativePool<T> : INativePool<T>
    where T : class
{
    private readonly T[] items;
    private readonly bool[] activeFlags;
    private readonly int[] availableIndices;
    private readonly Func<T> createFunc;
    private readonly Action<T> resetFunc;

    private int availableCount;
    private readonly int maxSize;

    public NativePool(
        Func<T> createFunc,
        Action<T> resetFunc = null,
        int initialSize = 16,
        int maxSize = 64
    )
    {
        this.createFunc = createFunc ?? throw new ArgumentNullException(nameof(createFunc));
        this.resetFunc = resetFunc;
        this.maxSize = maxSize;

        items = new T[maxSize];
        activeFlags = new bool[maxSize];
        availableIndices = new int[maxSize];

        availableCount = 0;

        // Initialize pool
        Prewarm(initialSize);
    }

    public T Get()
    {
        if (availableCount > 0)
        {
            int index = availableIndices[availableCount - 1];
            availableCount--;

            activeFlags[index] = true;
            return items[index];
        }

        if (GetActiveCount() < maxSize)
        {
            int newIndex = GetActiveCount();
            var newItem = createFunc();

            items[newIndex] = newItem;
            activeFlags[newIndex] = true;

            return newItem;
        }

        Debug.LogWarning($"Native pool capacity reached for type {typeof(T).Name}, returning null");
        return null;
    }

    public void Return(T item)
    {
        for (int i = 0; i < maxSize; i++)
        {
            if (ReferenceEquals(items[i], item) && activeFlags[i])
            {
                activeFlags[i] = false;
                availableIndices[availableCount] = i;
                availableCount++;

                // Reset the item if a reset function was provided
                resetFunc?.Invoke(item);
                return;
            }
        }
    }

    private void Prewarm(int count)
    {
        int warmCount = Mathf.Min(count, maxSize);

        for (int i = 0; i < warmCount; i++)
        {
            var item = createFunc();

            items[i] = item;
            activeFlags[i] = false;

            availableIndices[availableCount] = i;
            availableCount++;
        }
    }

    public void Clear()
    {
        for (int i = 0; i < maxSize; i++)
        {
            if (items[i] != null)
            {
                // If item implements IDisposable, dispose it
                if (items[i] is IDisposable disposable)
                {
                    disposable.Dispose();
                }
                items[i] = null;
                activeFlags[i] = false;
            }
        }
        availableCount = 0;
    }

    private int GetActiveCount()
    {
        int count = 0;
        for (int i = 0; i < maxSize; i++)
        {
            if (items[i] != null && activeFlags[i])
                count++;
        }
        return count;
    }
}

================
File: MagicTiles/CustomLibrary/NativeObjectPool/NativePool.cs.meta
================
fileFormatVersion: 2
guid: 0a9e94969542545639f6a715cf8de818
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/ObjectPool.meta
================
fileFormatVersion: 2
guid: de10be2658f3f4f1e942956e6fe33d3c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/ObjectPool/IObjectPool.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ComponentObjectPool
{
    public interface IObjectPool<T>
        where T : Component
    {
        T Get();
        void Return(T item);
        void Prewarm(int count);
        void Clear();
    }
}

================
File: MagicTiles/CustomLibrary/ObjectPool/IObjectPool.cs.meta
================
fileFormatVersion: 2
guid: ab557896160d14f41ae51297b67af573
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/ObjectPool/ObjectPool.cs
================
using System.Collections.Generic;
using UnityEngine;
using Object = UnityEngine.Object;

namespace ComponentObjectPool
{
    public class ObjectPool<T> : IObjectPool<T>
        where T : Component
    {
        private readonly T[] items; // All pooled items
        private readonly bool[] activeFlags; // Active status for each item
        private readonly int[] poolIndices; // Pool indices for each item
        private readonly int[] availableIndices; // Indices of available items

        private int availableCount;
        private readonly Transform parent;
        private readonly T prefab;
        private readonly int maxSize;

        public ObjectPool(T prefab, int initialSize, Transform parent, int maxSize = 64)
        {
            this.prefab = prefab;
            this.parent = parent;
            this.maxSize = maxSize;

            items = new T[maxSize];
            activeFlags = new bool[maxSize]; // Defaults to false
            poolIndices = new int[maxSize]; // Defaults to 0
            availableIndices = new int[maxSize];

            availableCount = 0;

            // Initialize pool
            Prewarm(initialSize);
        }

        public T Get()
        {
            if (availableCount > 0)
            {
                int index = availableIndices[availableCount - 1];
                availableCount--;

                items[index].gameObject.SetActive(true);
                activeFlags[index] = true;

                return items[index];
            }

            if (availableCount + GetActiveCount() < maxSize)
            {
                int newIndex = GetActiveCount();
                var newItem = CreateNew();

                items[newIndex] = newItem;
                activeFlags[newIndex] = true;
                poolIndices[newIndex] = newIndex;

                return newItem;
            }

            Debug.LogWarning("Pool capacity reached, returning null");
            return null;
        }

        public void Return(T item)
        {
            // Find item index
            for (int i = 0; i < maxSize; i++)
            {
                if (items[i] == item && activeFlags[i])
                {
                    // Deactivate and add to available indices
                    item.gameObject.SetActive(false);
                    activeFlags[i] = false;
                    availableIndices[availableCount] = i;
                    availableCount++;

                    return;
                }
            }
        }

        public void Prewarm(int count)
        {
            int warmCount = Mathf.Min(count, maxSize);

            for (int i = 0; i < warmCount; i++)
            {
                var item = CreateNew();
                item.gameObject.SetActive(false);

                // Store in arrays
                items[i] = item;
                activeFlags[i] = false;
                poolIndices[i] = i;

                // Add to available indices
                availableIndices[availableCount] = i;
                availableCount++;
            }
        }

        public void Clear()
        {
            for (int i = 0; i < maxSize; i++)
            {
                if (items[i] != null)
                {
                    Object.Destroy(items[i].gameObject);
                    items[i] = null;
                    activeFlags[i] = false;
                }
            }

            availableCount = 0;
        }

        //Helper Methods
        private int GetActiveCount()
        {
            int count = 0;
            for (int i = 0; i < maxSize; i++)
            {
                if (items[i] != null && activeFlags[i])
                    count++;
            }
            return count;
        }

        private T CreateNew()
        {
            return Object.Instantiate(prefab, parent);
        }

        // Optional: Get active items without allocation
        public void GetActiveItems(List<T> result)
        {
            result.Clear();
            for (int i = 0; i < maxSize; i++)
            {
                if (items[i] != null && activeFlags[i])
                    result.Add(items[i]);
            }
        }
    }
}

================
File: MagicTiles/CustomLibrary/ObjectPool/ObjectPool.cs.meta
================
fileFormatVersion: 2
guid: 730c74f438e0be244b928603d2eeb831
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/PersistentSingleton.cs
================
using UnityEngine;

public abstract class PersistentSingleton<T> : MonoBehaviour
    where T : Component
{
    // Static instance reference - readonly for thread safety
    private static readonly object _lock = new object();
    private static T _instance;

    // Public getter with lazy initialization and thread safety
    public static T Instance
    {
        get
        {
            // For optimization - avoid lock if already initialized
            if (_instance != null)
                return _instance;

            lock (_lock)
            {
                // Find if there's an instance in the scene
                _instance = FindAnyObjectByType<T>();

                // Create new instance if none exists
                if (_instance == null)
                {
                    var go = new GameObject($"[{typeof(T).Name}]");
                    _instance = go.AddComponent<T>();
                }

                // Make persistent
                DontDestroyOnLoad(_instance.gameObject);

                return _instance;
            }
        }
    }

    protected virtual void Awake()
    {
        // If an instance already exists and it's not this one
        if (_instance != null && _instance != this)
        {
            // Destroy this duplicate
            Destroy(gameObject);
            return;
        }

        // Set up singleton instance
        _instance = this as T;
        DontDestroyOnLoad(gameObject);

        OnAwake();
    }

    // Optional override for child classes
    protected virtual void OnAwake() { }
}

================
File: MagicTiles/CustomLibrary/PersistentSingleton.cs.meta
================
fileFormatVersion: 2
guid: 914e6b0bb36ee944dbfe4c8eb4d121bd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/CustomLibrary/SpriteExtension.cs
================
using System;
using UnityEngine;

public static class SpriteExtension
{
    /// <summary>
    /// Resize sprite to fill percentage of camera view
    /// </summary>
    public static void ResizeInCameraView(
        this SpriteRenderer spriteRenderer,
        Camera camera,
        float widthPercentage,
        float heightPercentage,
        bool maintainAspectRatio = true
    )
    {
        if (spriteRenderer == null || spriteRenderer.sprite == null)
            return;

        Vector2 scale = CameraViewUtils.CalculateScaleInCameraView(
            camera,
            spriteRenderer.sprite,
            widthPercentage,
            heightPercentage,
            maintainAspectRatio
        );

        spriteRenderer.transform.localScale = new Vector3(scale.x, scale.y, 1f);
    }
}

public static class SpriteUtility
{
    public struct SpriteCorners
    {
        public Vector2 TopLeft;
        public Vector2 TopRight;
        public Vector2 BottomLeft;
        public Vector2 BottomRight;
        public Vector2 Center;
        public Vector2 Size;
    }

    public static SpriteCorners GetSpriteCorners(SpriteRenderer spriteRenderer)
    {
        Vector2 position = spriteRenderer.transform.position;
        Vector2 spriteSize = Vector2.Scale(
            spriteRenderer.sprite.bounds.size,
            spriteRenderer.transform.localScale
        );

        float halfWidth = spriteSize.x / 2f;
        float halfHeight = spriteSize.y / 2f;

        return new SpriteCorners
        {
            TopLeft = position + new Vector2(-halfWidth, halfHeight),
            TopRight = position + new Vector2(halfWidth, halfHeight),
            BottomLeft = position + new Vector2(-halfWidth, -halfHeight),
            BottomRight = position + new Vector2(halfWidth, -halfHeight),
            Center = position,
            Size = spriteSize,
        };
    }

    public enum PivotPointXY
    {
        Top,
        Bottom,
        Left,
        Right,
    }

    /// <summary>
    /// Scales a sprite from a specified pivot point while maintaining the pivot position.
    /// </summary>
    /// <param name="spriteRenderer">The sprite renderer to scale</param>
    /// <param name="newScale">The target scale (x,y)</param>
    /// <param name="pivot">The pivot point to scale from</param>
    /// <returns>True if scaling succeeded, false otherwise</returns>
    public static bool ScaleFromPivot(
        SpriteRenderer spriteRenderer,
        Vector2 newScale,
        PivotPointXY pivot
    )
    {
        if (spriteRenderer == null || spriteRenderer.sprite == null)
            return false;

        var transform = spriteRenderer.transform;
        Vector3 originalPosition = transform.position;

        // Get current pivot point position in world space
        Vector3 pivotWorldPosition = GetPivotWorldPosition(spriteRenderer, pivot);

        // Apply new scale
        transform.localScale = new Vector3(newScale.x, newScale.y, transform.localScale.z);

        // Get new pivot point position after scaling
        Vector3 newPivotWorldPosition = GetPivotWorldPosition(spriteRenderer, pivot);

        // Calculate and apply position correction
        Vector3 correction = pivotWorldPosition - newPivotWorldPosition;
        transform.position = originalPosition + correction;

        return true;
    }

    private static Vector3 GetPivotWorldPosition(SpriteRenderer spriteRenderer, PivotPointXY pivot)
    {
        Bounds bounds = spriteRenderer.bounds;
        Vector3 center = bounds.center;
        Vector3 extents = bounds.extents;

        return pivot switch
        {
            PivotPointXY.Top => center + new Vector3(0, extents.y, 0),
            PivotPointXY.Bottom => center - new Vector3(0, extents.y, 0),
            PivotPointXY.Left => center - new Vector3(extents.x, 0, 0),
            PivotPointXY.Right => center + new Vector3(extents.x, 0, 0),
            _ => center,
        };
    }
}

================
File: MagicTiles/CustomLibrary/SpriteExtension.cs.meta
================
fileFormatVersion: 2
guid: 221588c9dfbbacb47b03d52a5b58ffef
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/DataComponent.meta
================
fileFormatVersion: 2
guid: 47d5a4a405d3b4ac6a1f8e459e7bdce7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/DataComponent/InputDataComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public struct InputStateData
{
    public Vector2 Position;
    public Vector2 PreviousPosition;
    public InputState State;
    public int FrameCount;
}

public enum InputState
{
    None,
    JustPressed,
    Held,
    JustReleased,
}

public struct InputDataComponent : IDataComponent
{
    public const int MAX_INPUTS = 2;

    public ChunkArray<InputStateData> inputStates;
    public ChunkArray<bool> isActives;
    public int activeInputCount;

    public InputDataComponent(int capacity)
    {
        inputStates = new ChunkArray<InputStateData>(capacity);
        isActives = new ChunkArray<bool>(capacity);
        activeInputCount = 0;

        for (int i = 0; i < MAX_INPUTS; i++)
        {
            inputStates.Add(
                new InputStateData
                {
                    Position = Vector2.zero,
                    PreviousPosition = Vector2.zero,
                    State = InputState.None,
                    FrameCount = 0,
                }
            );
            isActives.Add(false);
        }
    }
}

================
File: MagicTiles/DataComponent/InputDataComponent.cs.meta
================
fileFormatVersion: 2
guid: 32179416774b543de96f5b78c7770d11
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/DataComponent/IntroNoteData.cs
================
using UnityEngine;

public struct IntroNoteData : IDataComponent
{
    public Vector2 Position;
    public bool isActive;

    public IntroNoteData(bool isActive)
    {
        Position = Vector2.zero;
        this.isActive = isActive;
    }
}

================
File: MagicTiles/DataComponent/IntroNoteData.cs.meta
================
fileFormatVersion: 2
guid: 24d4a4fe9d0f720489369d852d02342a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/DataComponent/LaneLineData.cs
================
using UnityEngine;

public struct LaneLineData : IDataComponent
{
    public ChunkArray<Vector2> Positions;
    public ChunkArray<Vector2> Sizes;

    public LaneLineData(int capacity)
    {
        Positions = new ChunkArray<Vector2>(capacity);
        Sizes = new ChunkArray<Vector2>(capacity);

        for (int i = 0; i < capacity; i++)
        {
            Positions.Add(Vector2.zero);
            Sizes.Add(Vector2.zero);
        }
    }
}

================
File: MagicTiles/DataComponent/LaneLineData.cs.meta
================
fileFormatVersion: 2
guid: 5b648117f3553724994f311d2184285d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/DataComponent/MusicNoteFillerData.cs
================
using UnityEngine;

public struct MusicNoteFillerData : IDataComponent
{
    public ChunkArray<float> FillPercent;
    public ChunkArray<bool> IsVisibles;

    public MusicNoteFillerData(int capacity)
    {
        FillPercent = new ChunkArray<float>(capacity);
        IsVisibles = new ChunkArray<bool>(capacity);

        for (int i = 0; i < capacity; i++)
        {
            FillPercent.Add(0f);
            IsVisibles.Add(false);
        }
    }
}

================
File: MagicTiles/DataComponent/MusicNoteFillerData.cs.meta
================
fileFormatVersion: 2
guid: 6aba06b332bc74f42bef4d3dd45da17a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/DataComponent/MusicNoteStateData.cs
================
using UnityEngine;

public struct MusicNoteStateData : IDataComponent
{
    public ChunkArray<MusicNoteType> noteTypes;
    public ChunkArray<MusicNotePositionState> positionStates;
    public ChunkArray<MusicNoteInteractiveState> interactiveStates;
    public ChunkArray<float> filler;

    public MusicNoteStateData(int capacity)
    {
        noteTypes = new ChunkArray<MusicNoteType>(capacity);
        positionStates = new ChunkArray<MusicNotePositionState>(capacity);
        interactiveStates = new ChunkArray<MusicNoteInteractiveState>(capacity);
        filler = new ChunkArray<float>(capacity);

        for (int i = 0; i < capacity; i++)
        {
            noteTypes.Add(MusicNoteType.ShortNote);
            positionStates.Add(MusicNotePositionState.AbovePerfectLine);
            interactiveStates.Add(MusicNoteInteractiveState.Normal);
            filler.Add(0f);
        }
    }
}

public enum MusicNoteType
{
    ShortNote,
    LongNote,
}

public enum MusicNotePositionState
{
    AbovePerfectLine,
    InlineWithPerfectLine,
    PassedPerfectLine,
    OutOfScreen,
}

public enum MusicNoteInteractiveState
{
    Normal,
    Pressed,
    Hold,
    Completed,
}

================
File: MagicTiles/DataComponent/MusicNoteStateData.cs.meta
================
fileFormatVersion: 2
guid: a17129c8d7c2343478f256bcbdbbcbac
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/DataComponent/MusicNoteTransformData.cs
================
using UnityEngine;

public struct MusicNoteTransformData : IDataComponent
{
    public ChunkArray<Vector3> positions;
    public ChunkArray<Vector2> sizes;
    public ChunkArray<Vector2> TopLeft;
    public ChunkArray<Vector2> TopRight;
    public ChunkArray<Vector2> BottomLeft;
    public ChunkArray<Vector2> BottomRight;

    public MusicNoteTransformData(int capacity)
    {
        positions = new ChunkArray<Vector3>(capacity);
        sizes = new ChunkArray<Vector2>(capacity);
        TopLeft = new ChunkArray<Vector2>(capacity);
        TopRight = new ChunkArray<Vector2>(capacity);
        BottomLeft = new ChunkArray<Vector2>(capacity);
        BottomRight = new ChunkArray<Vector2>(capacity);

        for (int entityId = 0; entityId < capacity; entityId++)
        {
            positions.Add(Vector2.zero);
            sizes.Add(Vector2.zero);
            TopLeft.Add(Vector2.zero);
            TopRight.Add(Vector2.zero);
            BottomLeft.Add(Vector2.zero);
            BottomRight.Add(Vector2.zero);
        }
    }
}

================
File: MagicTiles/DataComponent/MusicNoteTransformData.cs.meta
================
fileFormatVersion: 2
guid: 47e29690f2ac54fd39e4fd284cb2d994
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/DataComponent/PerfectLineData.cs
================
using UnityEngine;

public struct PerfectLineData : IDataComponent
{
    public Vector2 TopLeft;
    public Vector2 TopRight;
    public Vector2 BottomLeft;
    public Vector2 BottomRight;
    public Vector2 Position;

    public PerfectLineData(
        Vector2 topLeft,
        Vector2 topRight,
        Vector2 bottomLeft,
        Vector2 bottomRight,
        Vector2 position
    )
    {
        TopLeft = topLeft;
        TopRight = topRight;
        BottomLeft = bottomLeft;
        BottomRight = bottomRight;
        Position = position;
    }
}

================
File: MagicTiles/DataComponent/PerfectLineData.cs.meta
================
fileFormatVersion: 2
guid: f2bdd665ecfccbb42a1439c9303dd84c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Enum.meta
================
fileFormatVersion: 2
guid: 4ddfe3a407477fe4da36b3366f94020d
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Enum/BridgeType.cs
================
using UnityEngine;

public enum BridgeType
{
    NoteTransform,
    InputDebugger,
    LaneLineBridge,
    IntroNote,
    Count,
}

================
File: MagicTiles/Enum/BridgeType.cs.meta
================
fileFormatVersion: 2
guid: 051ed9d86d4c61943b893f7af17d2a1c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Enum/DataComponentEnum.meta
================
fileFormatVersion: 2
guid: 0d8f297bc1266884090e7c1f99bce7a7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Enum/DataComponentEnum/LaneLineComponentType.cs
================
using UnityEngine;

public enum LaneLineComponentType
{
    LaneLineData,
}

================
File: MagicTiles/Enum/DataComponentEnum/LaneLineComponentType.cs.meta
================
fileFormatVersion: 2
guid: da624a81088514c4899c76efc8840fb7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Enum/DataComponentEnum/MusicNoteComponentType.cs
================
using UnityEngine;

public enum MusicNoteComponentType
{
    MusicNoteMidiData,
    MusicNoteTransformData,
    MusicNoteStateData,
    MusicNoteFiller,
}

================
File: MagicTiles/Enum/DataComponentEnum/MusicNoteComponentType.cs.meta
================
fileFormatVersion: 2
guid: 6761d442d7d19c14399241e912a16052
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Enum/EntityType.cs
================
using UnityEngine;

public enum EntityType
{
    NoteEntityGroup,
    NoteFillerEnttyGroup,
    LaneLineEntityGroup,
    Count,
}

================
File: MagicTiles/Enum/EntityType.cs.meta
================
fileFormatVersion: 2
guid: afea15442e7e36344bea4520ea468145
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Enum/PresenterManagerType.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public enum PresenterManagerType
{
    MusicNotePresenterManager,
    LongNotePresenterManager,
    InputDebuggerPresenterManager,
    LaneLinePresenterManager,
    IntroNotePresenterManager,
    Count,
}

================
File: MagicTiles/Enum/PresenterManagerType.cs.meta
================
fileFormatVersion: 2
guid: 8640e8f2be2a542e994ae97ba0d6b3e2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Enum/SingletonComponentType.cs
================
public enum SingletonComponentType
{
    PerfectLine,
    MusicNotePresenterManager,
    Input,
    IntroNote,
    Count,
}

================
File: MagicTiles/Enum/SingletonComponentType.cs.meta
================
fileFormatVersion: 2
guid: 84676ce79d1374a79a99b7c320e2ef81
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Global.meta
================
fileFormatVersion: 2
guid: 0ef1a4ea60a8db74d8cdb95ce324d5e9
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Global/EntityGroup.cs
================
using System;
using UnityEngine;

public struct EntityGroup<TDataComponentType> : IEntityGroup
    where TDataComponentType : Enum
{
    private readonly ChunkArray<bool> entityStates;
    private readonly IDataComponent[] dataComponents;

    public int EntityCount { get; private set; }

    public EntityGroup(int capacity)
    {
        entityStates = new ChunkArray<bool>(capacity);
        dataComponents = new IDataComponent[Enum.GetValues(typeof(TDataComponentType)).Length];

        EntityCount = 0;
        for (int entityId = 0; entityId < capacity; entityId++)
        {
            entityStates.Add(true);
            EntityCount++;
        }
    }

    public void RegisterComponent<T>(TDataComponentType type, T dataComponent)
        where T : struct, IDataComponent
    {
        dataComponents[Convert.ToInt32(type)] = new DataComponentWrapper<T>(dataComponent);
    }

    public ref T GetComponent<T>(TDataComponentType type)
        where T : struct, IDataComponent
    {
        var index = Convert.ToInt32(type);
        if (index >= dataComponents.Length || dataComponents[index] == null)
        {
            throw new InvalidOperationException($"Component of type {type} is not registered");
        }
        return ref ((DataComponentWrapper<T>)dataComponents[index]).Data;
    }

    public bool IsEntityActive(int entityId)
    {
        return entityId < EntityCount && entityStates.Get(entityId);
    }

    public void SetEntityCount(int count)
    {
        if (count > entityStates.Capacity)
            throw new ArgumentException("Count exceeds capacity");

        EntityCount = count;
        for (int i = 0; i < count; i++)
        {
            entityStates.Set(i, true);
        }
    }

    private class DataComponentWrapper<T> : IDataComponent
        where T : struct
    {
        public T Data;

        public DataComponentWrapper(T data)
        {
            Data = data;
        }
    }
}

================
File: MagicTiles/Global/EntityGroup.cs.meta
================
fileFormatVersion: 2
guid: ca25acad315127b449a8ffa609594246
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Global/GlobalGameSetting.cs
================
using System;
using UnityEngine;

public class GlobalGameSetting : PersistentSingleton<GlobalGameSetting>
{
    [Header("Global Game Settings")]
    public GeneralGameSettingSO generalSetting;
    public DataSystemSettingSO dataSystemSetting;

    [Header("Presenter Setting")]
    public PresenterSettingSO presenterSetting;

    [Header("Perfect Line Setting")]
    public PerfectLineSettingSO perfectLineSettingSO;

    [Header("Music Note")]
    public MusicNoteSettingSO musicNoteSettingSO;
    public Transform notePresenterParent;

    [Header("Input Debugger")]
    public Transform inputPresenterParent;

    [Header("Lane Line Settings")]
    public LaneLineSettingSO laneLineSettings;

    [Header("Intro Note Setting")]
    public IntroNoteSettingSO introNoteSetting;

    protected override void OnAwake()
    {
        // #region Systems registration
        // SystemRepository.RegisterSystem(new TileSpawnSystem());
        // SystemRepository.RegisterSystem(new TransformUpdateSystem());
        // SystemRepository.RegisterSystem(new MovingTileSystem());
        // SystemRepository.RegisterSystem(new NoteCornerUpdateSystem());
        // SystemRepository.RegisterSystem(new NoteStateSystem());
        // SystemRepository.RegisterSystem(new InputSystem());
        // SystemRepository.RegisterSystem(new InputCollisionSystem());
        // SystemRepository.RegisterSystem(new LaneLineSortingSystem());
        // SystemRepository.RegisterSystem(new IntroNoteInitSystem());
        // #endregion

        // #region Entities and data components registration

        // MusicNoteMidiData musicNoteMidiData = MidiNoteParser.ParseFromText(
        //     generalSetting.midiContent.text
        // );

        // var musicNoteEntityGroup = new EntityGroup<MusicNoteComponentType>(
        //     musicNoteMidiData.TotalNotes
        // );

        // musicNoteEntityGroup.RegisterComponent(
        //     MusicNoteComponentType.MusicNoteMidiData,
        //     musicNoteMidiData
        // );
        // musicNoteEntityGroup.RegisterComponent(
        //     MusicNoteComponentType.MusicNoteTransformData,
        //     new MusicNoteTransformData(musicNoteEntityGroup.EntityCount)
        // );
        // musicNoteEntityGroup.RegisterComponent(
        //     MusicNoteComponentType.MusicNoteStateData,
        //     new MusicNoteStateData(musicNoteEntityGroup.EntityCount)
        // );
        // musicNoteEntityGroup.RegisterComponent(
        //     MusicNoteComponentType.MusicNoteFiller,
        //     new MusicNoteFillerData(musicNoteEntityGroup.EntityCount)
        // );

        // EntityRepository.RegisterEGroup(EntityType.NoteEntityGroup, ref musicNoteEntityGroup);

        // var landLineEntityGroup = new EntityGroup<LaneLineComponentType>(5);
        // landLineEntityGroup.RegisterComponent(
        //     LaneLineComponentType.LaneLineData,
        //     new LaneLineData(landLineEntityGroup.EntityCount)
        // );

        // EntityRepository.RegisterEGroup(EntityType.LaneLineEntityGroup, ref landLineEntityGroup);

        // #endregion

        // #region Singleton data registration
        // SingletonComponentRepository.RegisterComponent(
        //     SingletonComponentType.PerfectLine,
        //     new PerfectLineData(
        //         perfectLineSettingSO.TopLeft,
        //         perfectLineSettingSO.TopRight,
        //         perfectLineSettingSO.BottomLeft,
        //         perfectLineSettingSO.BottomRight,
        //         perfectLineSettingSO.Position
        //     )
        // );

        // SingletonComponentRepository.RegisterComponent(
        //     SingletonComponentType.Input,
        //     new InputDataComponent(2)
        // );

        // SingletonComponentRepository.RegisterComponent(
        //     SingletonComponentType.IntroNote,
        //     new IntroNoteData(true)
        // );
        // #endregion

        // #region Presenters registration

        // PresenterManagerRepository.RegisterManager(
        //     PresenterManagerType.MusicNotePresenterManager,
        //     new PresenterManager(
        //         musicNoteEntityGroup.EntityCount,
        //         presenterSetting.shortMusicNotePresenterPrefab,
        //         notePresenterParent
        //     )
        // );

        // PresenterManagerRepository.RegisterManager(
        //     PresenterManagerType.LongNotePresenterManager,
        //     new PresenterManager(
        //         musicNoteEntityGroup.EntityCount,
        //         presenterSetting.longMusicNotePresenterPrefab,
        //         notePresenterParent
        //     )
        // );

        // PresenterManagerRepository.RegisterManager(
        //     PresenterManagerType.InputDebuggerPresenterManager,
        //     new PresenterManager(
        //         dataSystemSetting.defaultCapacity,
        //         presenterSetting.inputDebuggerPresenterPrefab,
        //         inputPresenterParent
        //     )
        // );

        // PresenterManagerRepository.RegisterManager(
        //     PresenterManagerType.LaneLinePresenterManager,
        //     new PresenterManager(
        //         landLineEntityGroup.EntityCount,
        //         presenterSetting.laneLinePresenter,
        //         inputPresenterParent
        //     )
        // );

        // PresenterManagerRepository.RegisterManager(
        //     PresenterManagerType.IntroNotePresenterManager,
        //     new PresenterManager(1, presenterSetting.introNotePressenyer)
        // );

        // #endregion

        // #region Initialize Data
        // MusicNoteInitializer.Initialize();
        // LaneLineInitializer.Initialize();
        // #endregion

        // #region bridges registration
        // BridgeRepository.RegisterBridge(
        //     BridgeType.NoteTransform,
        //     MusicNoteTransformBridge.Create()
        // );
        // BridgeRepository.RegisterBridge(BridgeType.LaneLineBridge, LaneLineBridge.Create());
        // BridgeRepository.RegisterBridge(BridgeType.IntroNote, IntroNoteTransformBridge.Create());
        // #endregion

        // GizmoDebugger.Instance.InitData(musicNoteEntityGroup.EntityCount);
    }

    private void OnDestroy()
    {
        SystemRepository.Clear();
        EntityRepository.Clear();
    }
}

================
File: MagicTiles/Global/GlobalGameSetting.cs.meta
================
fileFormatVersion: 2
guid: 1d6c4d845e5858a4d8049e50e480a4aa
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Global/MagicTileHelper.cs
================
using System;
using UnityEngine;

public static class MagicTileHelper
{
    public static float GetXPositionBasedOnPosID(int posId)
    {
        return posId * 10f;
    }

    public static float GetYPositionBasedOnTimeAppear(float timeAppear)
    {
        return timeAppear * GlobalGameSetting.Instance.generalSetting.gameSpeed;
    }

    public static float CalculateScaleY(
        MusicNoteType noteType,
        float scaleX,
        float longNoteDuration = 1f
    )
    {
        float scaleY;
        if (noteType == MusicNoteType.ShortNote)
        {
            scaleY =
                scaleX
                + GlobalGameSetting.Instance.musicNoteSettingSO.shortNoteScaleYFactor * scaleX;
        }
        else
        {
            scaleY =
                (scaleX + longNoteDuration)
                * GlobalGameSetting.Instance.musicNoteSettingSO.longNoteScaleYFactor;
        }
        return scaleY;
    }
}

================
File: MagicTiles/Global/MagicTileHelper.cs.meta
================
fileFormatVersion: 2
guid: c455467deb40dd748b5433e648326477
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Global/MusicTileManager.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MusicTileManager : MonoBehaviour
{
    private MusicTileWorld musicTileWorld;
    private LaneLineWorld laneLineWorld;

    // Start is called before the first frame update
    void Start()
    {
        musicTileWorld = new MusicTileWorld();
        laneLineWorld = new LaneLineWorld();
    }

    // Update is called once per frame
    void Update()
    {
        musicTileWorld.Update();
        laneLineWorld.Update();
    }
}

================
File: MagicTiles/Global/MusicTileManager.cs.meta
================
fileFormatVersion: 2
guid: 1149b9f93f2bd4dbca8c561e0d13e0cf
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Global/PresenterManager.cs
================
using UnityEngine;

public struct PresenterManager : IPresenterManager
{
    private readonly GameObject[] presenters;
    private readonly Transform parent;
    private readonly GameObject @base;

    public PresenterManager(int capacity, GameObject @base, Transform parent = null)
    {
        this.presenters = new GameObject[capacity];
        this.parent = parent;
        this.@base = @base;
    }

    public GameObject GetOrCreatePresenter(int entityId)
    {
        if (presenters[entityId] == null)
        {
            if (parent == null)
            {
                presenters[entityId] = GameObject.Instantiate(@base);
            }
            else
            {
                presenters[entityId] = GameObject.Instantiate(@base, parent);
            }
        }
        return presenters[entityId];
    }

    public void Cleanup()
    {
        for (int i = 0; i < presenters.Length; i++)
        {
            if (presenters[i] != null)
            {
                GameObject.Destroy(presenters[i]);
            }
        }
    }
}

================
File: MagicTiles/Global/PresenterManager.cs.meta
================
fileFormatVersion: 2
guid: b1837fa5a4c75464eb08e7a6e92baf98
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Initializer.meta
================
fileFormatVersion: 2
guid: e13ff9836de87b046b10991a7bb713cf
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Initializer/LaneLineInitializer.cs
================
public struct LaneLineInitializer
{
    public static void Initialize()
    {
        ref var laneLineSortingSystem = ref SystemRepository.GetSystem<LaneLineSortingSystem>();

        ref var laneLineEntityGroup = ref EntityRepository.GetEGroup<
            EntityGroup<LaneLineComponentType>
        >(EntityType.LaneLineEntityGroup);

        ref var landLineData = ref laneLineEntityGroup.GetComponent<LaneLineData>(
            LaneLineComponentType.LaneLineData
        );
        ref var perfectLineData = ref SingletonComponentRepository.GetComponent<PerfectLineData>(
            SingletonComponentType.PerfectLine
        );

        for (int entityId = 0; entityId < laneLineEntityGroup.EntityCount; entityId++)
        {
            laneLineSortingSystem.PositionLandLine(entityId, ref landLineData, ref perfectLineData);
        }
    }
}

================
File: MagicTiles/Initializer/LaneLineInitializer.cs.meta
================
fileFormatVersion: 2
guid: 1f487ad22838b014fa1a5efc51089175
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Initializer/MusicNoteInitializer.cs
================
using Mono.Cecil.Cil;
using UnityEngine;

public struct MusicNoteInitializer
{
    public static void Initialize()
    {
        ref var transfromUpdateSystem = ref SystemRepository.GetSystem<TransformUpdateSystem>();
        ref var tileSpawnSystem = ref SystemRepository.GetSystem<TileSpawnSystem>();

        ref var noteEntityGroup = ref EntityRepository.GetEGroup<
            EntityGroup<MusicNoteComponentType>
        >(EntityType.NoteEntityGroup);

        ref var musicNoteTransformData = ref noteEntityGroup.GetComponent<MusicNoteTransformData>(
            MusicNoteComponentType.MusicNoteTransformData
        );

        ref var musicNoteMidiData = ref noteEntityGroup.GetComponent<MusicNoteMidiData>(
            MusicNoteComponentType.MusicNoteMidiData
        );

        ref var musicNoteStateData = ref noteEntityGroup.GetComponent<MusicNoteStateData>(
            MusicNoteComponentType.MusicNoteStateData
        );

        ref var noteStateSystem = ref SystemRepository.GetSystem<NoteStateSystem>();

        ref var perfectLineData = ref SingletonComponentRepository.GetComponent<PerfectLineData>(
            SingletonComponentType.PerfectLine
        );

        for (int entityId = 0; entityId < noteEntityGroup.EntityCount; entityId++)
        {
            if (!noteEntityGroup.IsEntityActive(entityId))
            {
                continue;
            }
            noteStateSystem.NoteStateDeterminer(
                entityId,
                ref musicNoteMidiData,
                ref musicNoteStateData
            );
            transfromUpdateSystem.SyncTransformScale(
                entityId,
                ref musicNoteMidiData,
                ref musicNoteTransformData,
                ref musicNoteStateData
            );
            tileSpawnSystem.SpawnTileNote(
                entityId,
                ref perfectLineData,
                ref musicNoteMidiData,
                ref musicNoteTransformData
            );
        }

        ref var introNoteData = ref SingletonComponentRepository.GetComponent<IntroNoteData>(
            SingletonComponentType.IntroNote
        );
        ref var introNoteInitSystem = ref SystemRepository.GetSystem<IntroNoteInitSystem>();

        introNoteInitSystem.PrepareIntroNote(ref introNoteData, ref perfectLineData);
    }
}

================
File: MagicTiles/Initializer/MusicNoteInitializer.cs.meta
================
fileFormatVersion: 2
guid: 1f217910c9cf7004b8dc7566ab970332
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Interfaces.meta
================
fileFormatVersion: 2
guid: d219485a24ea3416ebefbcdcd4b8b482
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Interfaces/IBridge.cs
================
using UnityEngine;

public interface IBridge { }

================
File: MagicTiles/Interfaces/IBridge.cs.meta
================
fileFormatVersion: 2
guid: baa93b7e87438004380ae7b106cb91c6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Interfaces/IDataComponent.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface IDataComponent { }

================
File: MagicTiles/Interfaces/IDataComponent.cs.meta
================
fileFormatVersion: 2
guid: a4ece394aa7a34d3ca12be9a37c6eecf
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Interfaces/IEntityGroup.cs
================
using UnityEngine;

public interface IEntityGroup { }

================
File: MagicTiles/Interfaces/IEntityGroup.cs.meta
================
fileFormatVersion: 2
guid: 35da50d8a7751d34d8a3ff8aee805b2e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Interfaces/IGameSystem.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface IGameSystem { }

================
File: MagicTiles/Interfaces/IGameSystem.cs.meta
================
fileFormatVersion: 2
guid: d1d18ccf3c3af4219b2149883be06b9e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Interfaces/IPresenterManager.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface IPresenterManager { }

================
File: MagicTiles/Interfaces/IPresenterManager.cs.meta
================
fileFormatVersion: 2
guid: 776c9a1885c6742f9a50d3a122399fc4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Repositories.meta
================
fileFormatVersion: 2
guid: 08421506aee4f934da92384cf1b7959a
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Repositories/BridgeRepository.cs
================
using UnityEngine;

// Bridge repository to manage presenter systems
public static class BridgeRepository
{
    private static IBridge[] _bridges;

    static BridgeRepository()
    {
        _bridges = new IBridge[(int)BridgeType.Count];
    }

    public static void RegisterBridge<T>(BridgeType type, T bridge)
        where T : struct, IBridge
    {
        _bridges[(int)type] = new BridgeWrapper<T>(bridge);
    }

    public static ref T GetBridge<T>(BridgeType type)
        where T : struct, IBridge
    {
        return ref ((BridgeWrapper<T>)_bridges[(int)type]).Data;
    }

    private class BridgeWrapper<T> : IBridge
        where T : struct
    {
        public T Data;

        public BridgeWrapper(T data) => Data = data;

        public void InitializeBridge() { }
    }
}

================
File: MagicTiles/Repositories/BridgeRepository.cs.meta
================
fileFormatVersion: 2
guid: 1ffdef668bbc2e5428591b8922c1bd0b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Repositories/EntityRepository.cs
================
using UnityEngine;

public static class EntityRepository
{
    private static IEntityGroup[] entityGroups;

    static EntityRepository()
    {
        entityGroups = new IEntityGroup[(int)EntityType.Count];
    }

    public static void RegisterEGroup<T>(EntityType type, ref T entityGroup)
        where T : struct, IEntityGroup
    {
        entityGroups[(int)type] = new EntityGroupWrapper<T>(entityGroup);
    }

    public static ref T GetEGroup<T>(EntityType type)
        where T : struct, IEntityGroup
    {
        return ref ((EntityGroupWrapper<T>)entityGroups[(int)type]).Entity;
    }

    public static void Clear()
    {
        entityGroups = new IEntityGroup[(int)EntityType.Count];
    }

    private class EntityGroupWrapper<T> : IEntityGroup
        where T : struct
    {
        public T Entity;

        public EntityGroupWrapper(T entity)
        {
            Entity = entity;
        }
    }
}

================
File: MagicTiles/Repositories/EntityRepository.cs.meta
================
fileFormatVersion: 2
guid: cffe01ee9b0817a47810a56286e096b0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Repositories/PresenterManagerRepository.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public static class PresenterManagerRepository
{
    private static IPresenterManager[] _managers;

    static PresenterManagerRepository()
    {
        _managers = new IPresenterManager[(int)PresenterManagerType.Count];
    }

    public static void RegisterManager<T>(PresenterManagerType type, T manager)
        where T : struct, IPresenterManager
    {
        _managers[(int)type] = new ManagerWrapper<T>(manager);
    }

    public static ref T GetManager<T>(PresenterManagerType type)
        where T : struct, IPresenterManager
    {
        return ref ((ManagerWrapper<T>)_managers[(int)type]).Data;
    }

    private class ManagerWrapper<T> : IPresenterManager
        where T : struct
    {
        public T Data;

        public ManagerWrapper(T data) => Data = data;
    }
}

================
File: MagicTiles/Repositories/PresenterManagerRepository.cs.meta
================
fileFormatVersion: 2
guid: a4131bf9d92d94c24a0f3689ef984a35
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Repositories/SingletonComponentRepository.cs
================
public static class SingletonComponentRepository
{
    private static IDataComponent[] _singletonComponents;

    static SingletonComponentRepository()
    {
        _singletonComponents = new IDataComponent[(int)SingletonComponentType.Count];
    }

    public static void RegisterComponent<T>(SingletonComponentType type, T component)
        where T : struct, IDataComponent
    {
        _singletonComponents[(int)type] = new SingletonComponentWrapper<T>(component);
    }

    public static ref T GetComponent<T>(SingletonComponentType type)
        where T : struct, IDataComponent
    {
        return ref ((SingletonComponentWrapper<T>)_singletonComponents[(int)type]).Data;
    }

    private class SingletonComponentWrapper<T> : IDataComponent
        where T : struct
    {
        public T Data;

        public SingletonComponentWrapper(T data) => Data = data;
    }
}

================
File: MagicTiles/Repositories/SingletonComponentRepository.cs.meta
================
fileFormatVersion: 2
guid: c15db2d493fec0644a62d039504a234a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Repositories/SystemRepository.cs
================
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public static class SystemRepository
{
    private static Dictionary<Type, IGameSystem> systems = new();

    public static void RegisterSystem<T>(T system)
        where T : struct, IGameSystem
    {
        systems[typeof(T)] = new GameSystemWrapper<T>(system);
    }

    public static ref T GetSystem<T>()
        where T : struct, IGameSystem
    {
        if (systems.TryGetValue(typeof(T), out var wrapper))
        {
            return ref ((GameSystemWrapper<T>)wrapper).System;
        }
        throw new KeyNotFoundException($"System {typeof(T)} not registered");
    }

    public static void Clear()
    {
        systems.Clear();
    }

    private class GameSystemWrapper<T> : IGameSystem
        where T : IGameSystem
    {
        public T System;

        public GameSystemWrapper(T system)
        {
            System = system;
        }
    }
}

================
File: MagicTiles/Repositories/SystemRepository.cs.meta
================
fileFormatVersion: 2
guid: 811c9bdafd1bb4c1c9c0d2af63095cc5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Systems.meta
================
fileFormatVersion: 2
guid: c4d8f06821e684dccb70c722a74e6ef7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Systems/InputCollisionSystem.cs
================
using UnityEngine;

public struct InputCollisionSystem : IGameSystem
{
    private const string LOG_PREFIX = "[Input Collision] ";

    public void ProcessCollisions(
        int entityId,
        ref MusicNoteTransformData musicNoteTransformData,
        ref MusicNoteStateData musicNoteStateData,
        ref MusicNoteFillerData musicNoteFillerData
    )
    {
        ref var inputData = ref SingletonComponentRepository.GetComponent<InputDataComponent>(
            SingletonComponentType.Input
        );

        // Process each active input
        for (int inputIdx = 0; inputIdx < InputDataComponent.MAX_INPUTS; inputIdx++)
        {
            if (!inputData.isActives.Get(inputIdx))
                continue;

            var inputState = inputData.inputStates.Get(inputIdx);
            Vector2 inputPosition = inputState.Position;

            // // Skip notes not in playable zone
            // if (
            //     musicNoteStateData.positionStates.Get(entityId)
            //     != MusicNotePositionState.InlineWithPerfectLine
            // )
            //     continue;

            // Skip completed notes
            if (
                musicNoteStateData.interactiveStates.Get(entityId)
                == MusicNoteInteractiveState.Completed
            )
                continue;

            bool isInsideNote = IsPointInNote(
                inputPosition,
                musicNoteTransformData.TopLeft.Get(entityId),
                musicNoteTransformData.TopRight.Get(entityId),
                musicNoteTransformData.BottomLeft.Get(entityId),
                musicNoteTransformData.BottomRight.Get(entityId)
            );

            if (!isInsideNote)
            {
                continue;
            }

            ProcessNoteInteraction(
                entityId,
                inputState,
                ref musicNoteStateData,
                ref musicNoteTransformData,
                ref musicNoteFillerData
            );
        }
    }

    private static void ProcessNoteInteraction(
        int entityId,
        InputStateData inputState,
        ref MusicNoteStateData stateData,
        ref MusicNoteTransformData transformData,
        ref MusicNoteFillerData musicNoteFillerData
    )
    {
        var currentInteractiveState = stateData.interactiveStates.Get(entityId);
        var noteType = stateData.noteTypes.Get(entityId);

        switch (inputState.State)
        {
            case InputState.JustPressed:
                if (currentInteractiveState == MusicNoteInteractiveState.Normal)
                {
                    if (noteType == MusicNoteType.ShortNote)
                    {
                        CompleteNote(entityId, ref stateData);
                    }
                    else
                    {
                        StartLongNote(
                            entityId,
                            inputState,
                            ref stateData,
                            ref transformData,
                            ref musicNoteFillerData
                        );
                    }
                }
                break;

            case InputState.Held:
                if (noteType == MusicNoteType.LongNote)
                {
                    if (currentInteractiveState == MusicNoteInteractiveState.Pressed)
                    {
                        EnterHoldState(entityId, ref stateData);
                    }
                    else if (currentInteractiveState == MusicNoteInteractiveState.Hold)
                    {
                        UpdateLongNoteFill(
                            entityId,
                            ref stateData,
                            ref transformData,
                            ref musicNoteFillerData
                        );
                    }
                }
                break;

            case InputState.JustReleased:
                if (
                    noteType == MusicNoteType.LongNote
                    && (
                        currentInteractiveState == MusicNoteInteractiveState.Pressed
                        || currentInteractiveState == MusicNoteInteractiveState.Hold
                    )
                )
                {
                    CompleteNote(entityId, ref stateData);
                }
                break;
        }
    }

    private static void CompleteNote(int entityId, ref MusicNoteStateData stateData)
    {
        stateData.interactiveStates.Set(entityId, MusicNoteInteractiveState.Completed);
        Debug.Log($"{LOG_PREFIX} Note {entityId} completed");
    }

    private static void StartLongNote(
        int entityId,
        InputStateData inputState,
        ref MusicNoteStateData stateData,
        ref MusicNoteTransformData transformData,
        ref MusicNoteFillerData musicNoteFillerData
    )
    {
        stateData.interactiveStates.Set(entityId, MusicNoteInteractiveState.Pressed);
        musicNoteFillerData.IsVisibles.Set(entityId, true);

        float sizeOfNote =
            transformData.TopLeft.Get(entityId).y - transformData.BottomLeft.Get(entityId).y;
        float fromTouchPositionToLowerOfNote =
            inputState.Position.y - transformData.BottomLeft.Get(entityId).y;
        float touchPercent = fromTouchPositionToLowerOfNote / sizeOfNote;
        musicNoteFillerData.FillPercent.Set(entityId, touchPercent + 0.1f);

        Debug.Log($"{LOG_PREFIX} Note {entityId} pressed");
    }

    private static void EnterHoldState(int entityId, ref MusicNoteStateData stateData)
    {
        stateData.interactiveStates.Set(entityId, MusicNoteInteractiveState.Hold);
        Debug.Log($"{LOG_PREFIX} Long note {entityId} entering hold state");
    }

    private static void UpdateLongNoteFill(
        int entityId,
        ref MusicNoteStateData stateData,
        ref MusicNoteTransformData transformData,
        ref MusicNoteFillerData musicNoteFillerData
    )
    {
        float noteLength =
            transformData.TopLeft.Get(entityId).y - transformData.BottomLeft.Get(entityId).y;
        float gameSpeed = GlobalGameSetting.Instance.generalSetting.gameSpeed;
        float fillSpeed = gameSpeed / noteLength;

        float currentFillPercent = musicNoteFillerData.FillPercent.Get(entityId);
        float fillAmount = fillSpeed * Time.deltaTime;
        float nextFillPercent = currentFillPercent + fillAmount;
        nextFillPercent = Mathf.Min(nextFillPercent, 1f);

        musicNoteFillerData.FillPercent.Set(entityId, nextFillPercent);

        if (nextFillPercent >= 1f)
        {
            CompleteNote(entityId, ref stateData);
        }
    }

    private static bool IsPointInNote(
        Vector2 point,
        Vector2 topLeft,
        Vector2 topRight,
        Vector2 bottomLeft,
        Vector2 bottomRight
    )
    {
        int wn = 0; // Winding number

        // Using winding number algorithm for accurate polygon containment
        Vector2[] vertices = { topLeft, topRight, bottomRight, bottomLeft };

        for (int i = 0; i < vertices.Length; i++)
        {
            Vector2 current = vertices[i];
            Vector2 next = vertices[(i + 1) % vertices.Length];

            if (current.y <= point.y)
            {
                if (next.y > point.y && IsLeftOf(current, next, point) > 0)
                    wn++;
            }
            else
            {
                if (next.y <= point.y && IsLeftOf(current, next, point) < 0)
                    wn--;
            }
        }

        return wn != 0;
    }

    private static float IsLeftOf(Vector2 a, Vector2 b, Vector2 point)
    {
        return (b.x - a.x) * (point.y - a.y) - (point.x - a.x) * (b.y - a.y);
    }
}

================
File: MagicTiles/Systems/InputCollisionSystem.cs.meta
================
fileFormatVersion: 2
guid: e29f95c494be44f14910ae4f14e49879
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Systems/InputSystem.cs
================
using UnityEngine;

public struct InputSystem : IGameSystem
{
    private bool wasMousePressed;

    public InputSystem(bool fake = true)
    {
        wasMousePressed = false;
    }

    public void ProcessInput()
    {
        ref var inputData = ref SingletonComponentRepository.GetComponent<InputDataComponent>(
            SingletonComponentType.Input
        );

        UpdateInputStates(ref inputData);

        inputData.activeInputCount = 0;
        if (Input.touchCount > 0)
        {
            ProcessTouchInput(ref inputData);
        }
        else
        {
            ProcessMouseInput(ref inputData);
        }

        //LogInputDebugInfo(ref inputData);
    }

    private void ProcessMouseInput(ref InputDataComponent inputData)
    {
        // Always process mouse input every frame
        bool isCurrentlyPressed = Input.GetMouseButton(0);
        Vector2 worldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);

        var currentState = inputData.inputStates.Get(0);
        var newState = DetermineNewInputState(isCurrentlyPressed, wasMousePressed);

        // Only update if state changed or position changed
        if (newState != currentState.State || worldPos != currentState.Position)
        {
            UpdateInputSlot(ref inputData, 0, worldPos, newState);
            if (newState != InputState.None)
            {
                inputData.activeInputCount = 1;
            }
        }

        wasMousePressed = isCurrentlyPressed;
    }

    private InputState DetermineNewInputState(bool isPressed, bool wasPressed)
    {
        if (isPressed && !wasPressed)
            return InputState.JustPressed;
        if (!isPressed && wasPressed)
            return InputState.JustReleased;
        if (isPressed)
            return InputState.Held;
        return InputState.None;
    }

    private void ProcessTouchInput(ref InputDataComponent inputData)
    {
        int touchCount = Mathf.Min(Input.touchCount, InputDataComponent.MAX_INPUTS);

        for (int i = 0; i < touchCount; i++)
        {
            Touch touch = Input.GetTouch(i);
            Vector2 worldPos = Camera.main.ScreenToWorldPoint(touch.position);

            InputState newState = touch.phase switch
            {
                TouchPhase.Began => InputState.JustPressed,
                TouchPhase.Moved => InputState.Held,
                TouchPhase.Stationary => InputState.Held,
                TouchPhase.Ended => InputState.JustReleased,
                TouchPhase.Canceled => InputState.JustReleased,
                _ => InputState.None,
            };

            UpdateInputSlot(ref inputData, i, worldPos, newState);
            inputData.activeInputCount++;
        }
    }

    private void UpdateInputSlot(
        ref InputDataComponent inputData,
        int slot,
        Vector2 position,
        InputState newState
    )
    {
        var currentState = inputData.inputStates.Get(slot);

        currentState.PreviousPosition = currentState.Position;
        currentState.Position = position;
        currentState.State = newState;

        if (newState != currentState.State)
        {
            currentState.FrameCount = 0;
        }
        currentState.FrameCount++;

        inputData.inputStates.Set(slot, currentState);
        inputData.isActives.Set(slot, newState != InputState.None);
    }

    private void UpdateInputStates(ref InputDataComponent inputData)
    {
        for (int i = 0; i < InputDataComponent.MAX_INPUTS; i++)
        {
            var state = inputData.inputStates.Get(i);

            if (state.State == InputState.JustReleased)
            {
                state.State = InputState.None;
                state.FrameCount = 0;
                inputData.inputStates.Set(i, state);
                inputData.isActives.Set(i, false);
            }
        }
    }

    private void LogInputDebugInfo(ref InputDataComponent inputData)
    {
        for (int i = 0; i < InputDataComponent.MAX_INPUTS; i++)
        {
            if (inputData.isActives.Get(i))
            {
                var state = inputData.inputStates.Get(i);
                Debug.Log(
                    $"Input {i} - State: {state.State}, Position: {state.Position}, Frame Count: {state.FrameCount}"
                );
            }
        }
    }
}

================
File: MagicTiles/Systems/InputSystem.cs.meta
================
fileFormatVersion: 2
guid: b00456b7beee34fc197ff77a49db5847
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Systems/IntroNoteInitSystem.cs
================
using UnityEngine;

public struct IntroNoteInitSystem : IGameSystem
{
    public void PrepareIntroNote(
        ref IntroNoteData introNoteData,
        ref PerfectLineData perfectLineData
    )
    {
        // Calculate lane width
        float totalWidth = perfectLineData.TopRight.x - perfectLineData.TopLeft.x;
        float laneWidth = totalWidth / 4;
        float halfLaneWidth = laneWidth / 2f;

        int laneToSpawn = GlobalGameSetting.Instance.introNoteSetting.initLane;

        // Calculate X position (centered in lane)
        float spawnX = perfectLineData.TopLeft.x + (laneToSpawn * laneWidth) + halfLaneWidth;

        // Calculate Y position (centered on perfect line)
        float spawnY = (perfectLineData.TopLeft.y + perfectLineData.BottomLeft.y) / 2f;

        // Set position
        introNoteData.Position = new Vector2(spawnX, spawnY);

        Debug.Log($"Intro Note Position - X: {spawnX}, Y: {spawnY}");
        Debug.Log(
            $"Perfect Line - Top: {perfectLineData.TopLeft.y}, Bottom: {perfectLineData.BottomLeft.y}"
        );
    }
}

================
File: MagicTiles/Systems/IntroNoteInitSystem.cs.meta
================
fileFormatVersion: 2
guid: 68c779fd8db1c1b4da12dc617cea1797
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Systems/LaneLineSortingSystem.cs
================
using UnityEngine;

public struct LaneLineSortingSystem : IGameSystem
{
    // Pseudo setting - replace with actual ScriptableObject reference later

    public void PositionLandLine(
        int entityId,
        ref LaneLineData landLineData,
        ref PerfectLineData perfectLineData
    )
    {
        // Calculate total width from perfect line bounds
        float totalWidth = perfectLineData.TopRight.x - perfectLineData.TopLeft.x;

        // Calculate lane width (total width / 4 for 4 lanes)
        float laneWidth = totalWidth / 4f;

        // Calculate x position based on entity ID
        float lineX;
        if (entityId == 0)
        {
            // First line - left edge
            lineX = perfectLineData.TopLeft.x;
        }
        else if (entityId == 4)
        {
            // Last line - right edge
            lineX = perfectLineData.TopRight.x;
        }
        else
        {
            // Internal dividing lines (entityId 1,2,3)
            // Position after each lane (1/4, 2/4, 3/4 of total width)
            lineX = perfectLineData.TopLeft.x + (laneWidth * (entityId));
        }

        // Calculate normalized x position (0-1 range)
        float normalizedX = (lineX - perfectLineData.TopLeft.x) / totalWidth;

        // Position the line
        Vector2 worldPosition = CameraViewUtils.GetPositionInCameraView(
            Camera.main,
            normalizedX,
            0.5f,
            0f
        );

        // Set position
        landLineData.Positions.Set(entityId, worldPosition);

        // Calculate and set size
        float lineWidthPercentage = GlobalGameSetting.Instance.laneLineSettings.lineWidthPercentage;
        Vector2 size = CalculateLineSize(Camera.main, lineWidthPercentage);
        landLineData.Sizes.Set(entityId, size);

#if UNITY_EDITOR
        Debug.Log(
            $"Lane line {entityId} positioned at x: {worldPosition.x}, normalized: {normalizedX}, isEdge: {entityId == 0 || entityId == 4}"
        );
#endif
    }

    private Vector2 CalculateLineSize(Camera camera, float widthPercentage)
    {
        // Magic number 3 to ensure that the line always fill entire screen,
        // as camera view does not cover entire screen height on some devices
        float cameraHeight = camera.orthographicSize * 2f + 3;
        float cameraWidth = cameraHeight * camera.aspect;

        return new Vector2(cameraWidth * widthPercentage, cameraHeight);
    }
}

================
File: MagicTiles/Systems/LaneLineSortingSystem.cs.meta
================
fileFormatVersion: 2
guid: 7e067d8963e277a4cac990c1b18efef1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Systems/MovingTileSystem.cs
================
using UnityEngine;

public struct MovingTileSystem : IGameSystem
{
    public void MovingTile(
        int entityId,
        ref MusicNoteTransformData musicNoteTransformData,
        ref MusicNoteStateData musicNoteStateData
    )
    {
        if (musicNoteStateData.positionStates.Get(entityId) == MusicNotePositionState.OutOfScreen)
        {
            Debug.Log($"Entity {entityId} is out of bounds");
            return;
        }

        Vector2 newPos = Vector2.zero;

        float gameSpeed = GlobalGameSetting.Instance.generalSetting.gameSpeed;

        newPos.x = musicNoteTransformData.positions.Get(entityId).x;
        newPos.y = musicNoteTransformData.positions.Get(entityId).y - gameSpeed * Time.deltaTime;

        musicNoteTransformData.positions.Set(entityId, newPos);
    }
}

================
File: MagicTiles/Systems/MovingTileSystem.cs.meta
================
fileFormatVersion: 2
guid: d33d078bb1476f847b64793d2a5e86ed
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Systems/NoteCornerUpdateSystem.cs
================
using UnityEngine;

public struct NoteCornerUpdateSystem : IGameSystem
{
    public void UpdateCorners(int entityId, ref MusicNoteTransformData musicNoteTransformData)
    {
        Vector3 position = musicNoteTransformData.positions.Get(entityId);
        Vector2 size = musicNoteTransformData.sizes.Get(entityId);

        float halfWidth = size.x / 2f;
        float halfHeight = size.y / 2f;

        // Update all corners based on current position
        musicNoteTransformData.TopLeft.Set(
            entityId,
            new Vector2(position.x - halfWidth, position.y + halfHeight)
        );
        musicNoteTransformData.TopRight.Set(
            entityId,
            new Vector2(position.x + halfWidth, position.y + halfHeight)
        );
        musicNoteTransformData.BottomLeft.Set(
            entityId,
            new Vector2(position.x - halfWidth, position.y - halfHeight)
        );
        musicNoteTransformData.BottomRight.Set(
            entityId,
            new Vector2(position.x + halfWidth, position.y - halfHeight)
        );
        GizmoDebugger.Instance.UpdateData(
            entityId,
            0,
            musicNoteTransformData.TopLeft.Get(entityId)
        );
        GizmoDebugger.Instance.UpdateData(
            entityId,
            1,
            musicNoteTransformData.TopRight.Get(entityId)
        );
        GizmoDebugger.Instance.UpdateData(
            entityId,
            2,
            musicNoteTransformData.BottomLeft.Get(entityId)
        );
        GizmoDebugger.Instance.UpdateData(
            entityId,
            3,
            musicNoteTransformData.BottomRight.Get(entityId)
        );
    }
}

================
File: MagicTiles/Systems/NoteCornerUpdateSystem.cs.meta
================
fileFormatVersion: 2
guid: 720c0a27802a23343a235b47c246d9c5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Systems/NoteStateSystem.cs
================
using UnityEngine;

public struct NoteStateSystem : IGameSystem
{
    public void NoteStateUpdate(
        int entityId,
        ref MusicNoteTransformData musicNoteTransformData,
        ref MusicNoteStateData musicNoteStateData,
        ref PerfectLineData perfectLineData
    )
    {
        float noteUpperY = musicNoteTransformData.TopLeft.Get(entityId).y;
        float noteLowerY = musicNoteTransformData.BottomLeft.Get(entityId).y;
        float perfectLineUpperY = perfectLineData.TopLeft.y;
        float perfectLineLowerY = perfectLineData.BottomLeft.y;

        if (musicNoteStateData.positionStates.Get(entityId) == MusicNotePositionState.OutOfScreen)
        {
            return;
        }

        if (noteLowerY < perfectLineUpperY && noteUpperY > perfectLineLowerY)
        {
            musicNoteStateData.positionStates.Set(
                entityId,
                MusicNotePositionState.InlineWithPerfectLine
            );
        }
        else if (noteUpperY < perfectLineLowerY)
        {
            musicNoteStateData.positionStates.Set(
                entityId,
                MusicNotePositionState.PassedPerfectLine
            );
        }
        else if (noteUpperY > perfectLineUpperY)
        {
            musicNoteStateData.positionStates.Set(
                entityId,
                MusicNotePositionState.AbovePerfectLine
            );
        }

        Vector2 noteTop = musicNoteTransformData.TopLeft.Get(entityId);
        if (
            CameraViewUtils.IsPositionOutOfBounds(
                Camera.main,
                noteTop,
                CameraViewUtils.CameraBoundCheck.Bottom
            )
        )
        {
            musicNoteStateData.positionStates.Set(entityId, MusicNotePositionState.OutOfScreen);
        }
    }

    public void NoteStateDeterminer(
        int entityId,
        ref MusicNoteMidiData musicNoteMidiData,
        ref MusicNoteStateData musicNoteStateData
    )
    {
        if (
            musicNoteMidiData
                .Durations[entityId]
                .IsInRange(musicNoteMidiData.MinDuration, musicNoteMidiData.MinDuration + 0.01f)
        )
        {
            musicNoteStateData.noteTypes.Set(entityId, MusicNoteType.ShortNote);
        }
        else if (musicNoteMidiData.Durations[entityId] > musicNoteMidiData.MinDuration)
        {
            musicNoteStateData.noteTypes.Set(entityId, MusicNoteType.LongNote);
        }
    }
}

================
File: MagicTiles/Systems/NoteStateSystem.cs.meta
================
fileFormatVersion: 2
guid: 35083ba37d009314e89fb8bdb5d2c948
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Systems/TileSpawnSystem.cs
================
using UnityEngine;

public struct TileSpawnSystem : IGameSystem
{
    public void SpawnTileNote(
        int entityId,
        ref PerfectLineData perfectLine,
        ref MusicNoteMidiData musicNoteMidiData,
        ref MusicNoteTransformData musicNoteTransformData
    )
    {
        // Calculate lane width once
        float totalWidth = perfectLine.TopRight.x - perfectLine.TopLeft.x;
        float laneWidth = totalWidth / 4;
        float halfLaneWidth = laneWidth / 2f;

        // Calculate final position
        float spawnX =
            perfectLine.TopLeft.x
            + (musicNoteMidiData.PositionIds[entityId] * laneWidth)
            + halfLaneWidth;

        float spawnY =
            perfectLine.TopLeft.y
            + (
                musicNoteMidiData.TimeAppears[entityId]
                * GlobalGameSetting.Instance.generalSetting.gameSpeed
            )
            + musicNoteTransformData.sizes.Get(entityId).y / 2f;

        // Set both MIDI data and transform position in one go
        musicNoteTransformData.positions.Set(entityId, new Vector3(spawnX, spawnY, 0));

        // Calculate and set corners if needed
        Vector2 currentSize = musicNoteTransformData.sizes.Get(entityId);
        float halfWidth = currentSize.x / 2f;
        float halfHeight = currentSize.y / 2f;

        musicNoteTransformData.TopLeft.Set(
            entityId,
            new Vector2(spawnX - halfWidth, spawnY + halfHeight)
        );
        musicNoteTransformData.TopRight.Set(
            entityId,
            new Vector2(spawnX + halfWidth, spawnY + halfHeight)
        );
        musicNoteTransformData.BottomLeft.Set(
            entityId,
            new Vector2(spawnX - halfWidth, spawnY - halfHeight)
        );
        musicNoteTransformData.BottomRight.Set(
            entityId,
            new Vector2(spawnX + halfWidth, spawnY - halfHeight)
        );

        Debug.Log($"Top Left [{entityId}]: {musicNoteTransformData.TopLeft.Get(entityId)}");
        Debug.Log($"Top Right [{entityId}]: {musicNoteTransformData.TopRight.Get(entityId)}");
        Debug.Log($"Bottom Left [{entityId}]: {musicNoteTransformData.BottomLeft.Get(entityId)}");
        Debug.Log($"Bottom Right [{entityId}]: {musicNoteTransformData.BottomRight.Get(entityId)}");
    }
}

================
File: MagicTiles/Systems/TileSpawnSystem.cs.meta
================
fileFormatVersion: 2
guid: 743e510e1cb83e84598108e6bedcce90
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/Systems/TransformUpdateSystem.cs
================
using System.Linq;
using UnityEngine;

public struct TransformUpdateSystem : IGameSystem
{
    public void SyncTransformScale(
        int entityId,
        ref MusicNoteMidiData musicNoteMidiData,
        ref MusicNoteTransformData musicNoteTransformData,
        ref MusicNoteStateData musicNoteStateData
    )
    {
        ref var noteEntityManager = ref EntityRepository.GetEGroup<
            EntityGroup<MusicNoteComponentType>
        >(EntityType.NoteEntityGroup);

        //

        Vector3 transformScale = Vector3.zero;

        float scaleX = GlobalGameSetting.Instance.perfectLineSettingSO.PerfectLineWidth() / 4;

        float scaleY = MagicTileHelper.CalculateScaleY(
            musicNoteStateData.noteTypes.Get(entityId),
            scaleX,
            musicNoteMidiData.Durations[entityId]
        );

        transformScale.x = scaleX;
        transformScale.y = scaleY;

        musicNoteTransformData.sizes.Set(entityId, transformScale);
    }
}

================
File: MagicTiles/Systems/TransformUpdateSystem.cs.meta
================
fileFormatVersion: 2
guid: 7a27b9d4b25b244c793755a7ce5a4af4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/UnityBridge.meta
================
fileFormatVersion: 2
guid: c06d26500dd1a458cb44c3405c290e0d
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/UnityBridge/InputDebuggerBridge.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public struct InputDebuggerBridge : IBridge
{
    private readonly int spawnCount;

    public InputDebuggerBridge(bool fake)
    {
        this.spawnCount = 0;
    }

    public void SpawnDebuggerAtInputPressed()
    {
        ref var presenterManager = ref PresenterManagerRepository.GetManager<PresenterManager>(
            PresenterManagerType.InputDebuggerPresenterManager
        );

        ref var inputData = ref SingletonComponentRepository.GetComponent<InputDataComponent>(
            SingletonComponentType.Input
        );

        GameObject presenter;

        for (int inputIdx = 0; inputIdx < InputDataComponent.MAX_INPUTS; inputIdx++)
        {
            if (!inputData.isActives.Get(inputIdx))
                continue;

            var inputState = inputData.inputStates.Get(inputIdx);

            // Only check collisions on JustPressed state
            if (inputState.State != InputState.JustPressed)
            {
                continue;
            }

            presenter = presenterManager.GetOrCreatePresenter(spawnCount);

            presenter.transform.position = inputData.inputStates.Get(inputIdx).Position;
            Debug.Break();
        }
    }
}

================
File: MagicTiles/UnityBridge/InputDebuggerBridge.cs.meta
================
fileFormatVersion: 2
guid: e66a9da85ccde4bf1ad6302a048f2f68
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/UnityBridge/IntroNoteTransformBridge.cs
================
using UnityEngine;

public struct IntroNoteTransformBridge : IBridge
{
    private GameObject cachedIntroNotePresenter;

    private IntroNoteTransformBridge(bool fake)
    {
        ref var introNotePresenter = ref PresenterManagerRepository.GetManager<PresenterManager>(
            PresenterManagerType.IntroNotePresenterManager
        );
        GameObject go = introNotePresenter.GetOrCreatePresenter(0);
        cachedIntroNotePresenter = go;
    }

    public void SyncIntroNoteTransform(ref IntroNoteData introNoteData)
    {
        cachedIntroNotePresenter.transform.position = introNoteData.Position;
        cachedIntroNotePresenter.SetActive(introNoteData.isActive);
    }

    public static IntroNoteTransformBridge Create()
    {
        return new IntroNoteTransformBridge(true);
    }
}

================
File: MagicTiles/UnityBridge/IntroNoteTransformBridge.cs.meta
================
fileFormatVersion: 2
guid: 264d7eeef6444a047b142bd06972ae70
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/UnityBridge/LaneLineBridge.cs
================
using UnityEngine;

public struct LaneLineBridge : IBridge
{
    private ChunkArray<GameObject> cachedLaneLinePresenter;
    private ChunkArray<SpriteRenderer> cachedSpriteRenderers;

    private LaneLineBridge(bool fake)
    {
        ref var laneLinePresenter = ref PresenterManagerRepository.GetManager<PresenterManager>(
            PresenterManagerType.LaneLinePresenterManager
        );

        ref var laneLineEntityGroup = ref EntityRepository.GetEGroup<
            EntityGroup<LaneLineComponentType>
        >(EntityType.LaneLineEntityGroup);

        ref var lanelineData = ref laneLineEntityGroup.GetComponent<LaneLineData>(
            LaneLineComponentType.LaneLineData
        );

        cachedLaneLinePresenter = new ChunkArray<GameObject>(laneLineEntityGroup.EntityCount);
        cachedSpriteRenderers = new ChunkArray<SpriteRenderer>(laneLineEntityGroup.EntityCount);

        GameObject presenterGO;
        for (int entityId = 0; entityId < laneLineEntityGroup.EntityCount; entityId++)
        {
            presenterGO = laneLinePresenter.GetOrCreatePresenter(entityId);
            cachedLaneLinePresenter.Add(presenterGO);
            cachedSpriteRenderers.Add(presenterGO.GetComponent<SpriteRenderer>());
            SyncTransform(entityId, ref lanelineData);
        }
    }

    public static LaneLineBridge Create()
    {
        return new LaneLineBridge(true);
    }

    public void SyncTransform(int entityId, ref LaneLineData landLineData)
    {
        // Update position
        cachedLaneLinePresenter.Get(entityId).transform.position = landLineData.Positions.Get(
            entityId
        );

        // Update scale based on size
        Vector2 size = landLineData.Sizes.Get(entityId);
        Vector2 scale = Vector2.one;

        // Get the sprite size in world units
        var sprite = cachedSpriteRenderers.Get(entityId).sprite;
        if (sprite != null)
        {
            Vector2 spriteSize = sprite.bounds.size;
            scale.x = size.x / spriteSize.x;
            scale.y = size.y / spriteSize.y;
        }

        cachedLaneLinePresenter.Get(entityId).transform.localScale = new Vector3(
            scale.x,
            scale.y,
            1f
        );
    }
}

================
File: MagicTiles/UnityBridge/LaneLineBridge.cs.meta
================
fileFormatVersion: 2
guid: d57debea564f3e54f8afd152a189927b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/UnityBridge/MusicNoteTransformBridge.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public struct MusicNoteTransformBridge : IBridge
{
    private readonly ChunkArray<GameObject> cachedNotePresenters;
    private readonly ChunkArray<SpriteRenderer> cachedNotePresenterSprites;

    private readonly Dictionary<int, SpriteRenderer> cachedLongNoteFiller;

    private MusicNoteTransformBridge(bool fake)
    {
        ref var noteEntityGroup = ref EntityRepository.GetEGroup<
            EntityGroup<MusicNoteComponentType>
        >(EntityType.NoteEntityGroup);

        ref var musicNoteStatedata = ref noteEntityGroup.GetComponent<MusicNoteStateData>(
            MusicNoteComponentType.MusicNoteStateData
        );

        ref var shortNotePresenterManager =
            ref PresenterManagerRepository.GetManager<PresenterManager>(
                PresenterManagerType.MusicNotePresenterManager
            );

        ref var longNotePresenterManager =
            ref PresenterManagerRepository.GetManager<PresenterManager>(
                PresenterManagerType.LongNotePresenterManager
            );

        cachedNotePresenters = new ChunkArray<GameObject>(noteEntityGroup.EntityCount);
        cachedNotePresenterSprites = new ChunkArray<SpriteRenderer>(noteEntityGroup.EntityCount);
        cachedLongNoteFiller = new Dictionary<int, SpriteRenderer>();

        GameObject presenterGO;

        for (int entityId = 0; entityId < noteEntityGroup.EntityCount; entityId++)
        {
            if (!noteEntityGroup.IsEntityActive(entityId))
            {
                continue;
            }

            if (musicNoteStatedata.noteTypes.Get(entityId) == MusicNoteType.ShortNote)
            {
                presenterGO = shortNotePresenterManager.GetOrCreatePresenter(entityId);

                cachedNotePresenters.Add(presenterGO);
                cachedNotePresenterSprites.Add(presenterGO.GetComponent<SpriteRenderer>());
            }
            else if (musicNoteStatedata.noteTypes.Get(entityId) == MusicNoteType.LongNote)
            {
                presenterGO = longNotePresenterManager.GetOrCreatePresenter(entityId);

                cachedNotePresenters.Add(presenterGO);
                cachedNotePresenterSprites.Add(presenterGO.GetComponent<SpriteRenderer>());
                cachedLongNoteFiller.Add(
                    entityId,
                    presenterGO.transform.GetChild(0).GetComponent<SpriteRenderer>()
                );
            }
        }
    }

    public static MusicNoteTransformBridge Create()
    {
        return new MusicNoteTransformBridge(true);
    }

    public void SyncNoteTransformToUnity(
        int entityId,
        ref MusicNoteTransformData musicNoteTransformData,
        ref MusicNoteStateData musicNoteStateData,
        ref MusicNoteFillerData musicNoteFillerData
    )
    {
        cachedNotePresenters.Get(entityId).transform.position =
            musicNoteTransformData.positions.Get(entityId);
        cachedNotePresenters.Get(entityId).transform.localScale = musicNoteTransformData.sizes.Get(
            entityId
        );

        if (
            musicNoteStateData.noteTypes.Get(entityId) == MusicNoteType.ShortNote
            && musicNoteStateData.interactiveStates.Get(entityId)
                == MusicNoteInteractiveState.Completed
        )
        {
            cachedNotePresenterSprites.Get(entityId).color = Color.black;
        }
        if (
            musicNoteStateData.noteTypes.Get(entityId) == MusicNoteType.LongNote
            && cachedLongNoteFiller.ContainsKey(entityId)
        )
        {
            cachedLongNoteFiller[entityId]
                .gameObject.SetActive(musicNoteFillerData.IsVisibles.Get(entityId));
            float fillerPercentage = musicNoteFillerData.FillPercent.Get(entityId);

            SpriteUtility.ScaleFromPivot(
                cachedLongNoteFiller[entityId],
                new Vector2(1, fillerPercentage),
                SpriteUtility.PivotPointXY.Bottom
            );
        }
    }
}

================
File: MagicTiles/UnityBridge/MusicNoteTransformBridge.cs.meta
================
fileFormatVersion: 2
guid: ce77ab49b19d14160b0e2d8568174a50
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/World.meta
================
fileFormatVersion: 2
guid: b968799c8edd741c6a56296b03865558
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/World/LaneLineWorld.cs
================
public struct LaneLineWorld
{
    public void Update()
    {
        // ref var laneLineEntityGroup = ref EntityRepository.GetEGroup<
        //     EntityGroup<LaneLineComponentType>
        // >(EntityType.LaneLineEntityGroup);

        // ref var landLineData = ref laneLineEntityGroup.GetComponent<LaneLineData>(
        //     LaneLineComponentType.LaneLineData
        // );

        // ref var laneLineBridge = ref BridgeRepository.GetBridge<LaneLineBridge>(
        //     BridgeType.LaneLineBridge
        // );

        // for (int entityId = 0; entityId < laneLineEntityGroup.EntityCount; entityId++)
        // {
        //     laneLineBridge.SyncTransform(entityId, ref landLineData);
        // }
    }
}

================
File: MagicTiles/World/LaneLineWorld.cs.meta
================
fileFormatVersion: 2
guid: 8aad0043fdb38b04a856d114299d9b96
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MagicTiles/World/MusicTileWorld.cs
================
public struct MusicTileWorld
{
    public void Update()
    {
        ref var bridge = ref BridgeRepository.GetBridge<MusicNoteTransformBridge>(
            BridgeType.NoteTransform
        );

        ref var introNoteTransformBridge = ref BridgeRepository.GetBridge<IntroNoteTransformBridge>(
            BridgeType.IntroNote
        );

        SystemRepository.GetSystem<InputSystem>().ProcessInput();

        ref var movingTileSystem = ref SystemRepository.GetSystem<MovingTileSystem>();
        ref var noteCornerUpdateSystem = ref SystemRepository.GetSystem<NoteCornerUpdateSystem>();
        ref var noteStateSystem = ref SystemRepository.GetSystem<NoteStateSystem>();
        ref var inputCollisionSystem = ref SystemRepository.GetSystem<InputCollisionSystem>();

        ref var noteEntityGroup = ref EntityRepository.GetEGroup<
            EntityGroup<MusicNoteComponentType>
        >(EntityType.NoteEntityGroup);

        ref var musicNoteTransformData = ref noteEntityGroup.GetComponent<MusicNoteTransformData>(
            MusicNoteComponentType.MusicNoteTransformData
        );

        ref var musicNoteStateData = ref noteEntityGroup.GetComponent<MusicNoteStateData>(
            MusicNoteComponentType.MusicNoteStateData
        );

        ref var musicNoteFillerData = ref noteEntityGroup.GetComponent<MusicNoteFillerData>(
            MusicNoteComponentType.MusicNoteFiller
        );

        ref var perfectLineData = ref SingletonComponentRepository.GetComponent<PerfectLineData>(
            SingletonComponentType.PerfectLine
        );

        for (int entityId = 0; entityId < noteEntityGroup.EntityCount; entityId++)
        {
            if (!noteEntityGroup.IsEntityActive(entityId))
            {
                continue;
            }

            movingTileSystem.MovingTile(
                entityId,
                ref musicNoteTransformData,
                ref musicNoteStateData
            );

            noteCornerUpdateSystem.UpdateCorners(entityId, ref musicNoteTransformData);

            noteStateSystem.NoteStateUpdate(
                entityId,
                ref musicNoteTransformData,
                ref musicNoteStateData,
                ref perfectLineData
            );

            inputCollisionSystem.ProcessCollisions(
                entityId,
                ref musicNoteTransformData,
                ref musicNoteStateData,
                ref musicNoteFillerData
            );

            bridge.SyncNoteTransformToUnity(
                entityId,
                ref musicNoteTransformData,
                ref musicNoteStateData,
                ref musicNoteFillerData
            );
        }
    }
}

================
File: MagicTiles/World/MusicTileWorld.cs.meta
================
fileFormatVersion: 2
guid: 1d699017f87e042038ca7a6ff4f7102a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoDebug.meta
================
fileFormatVersion: 2
guid: 5de9732655733194d934d453adc63bdf
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoDebug/CameraSpacePositionAdjuster.cs
================
using UnityEngine;

public class CameraSpacePositionAdjuster : MonoBehaviour
{
    [SerializeField]
    private Camera targetCamera;

    [Range(0, 1)]
    public float normalizedX = 0.5f;

    [Range(0, 1)]
    public float normalizedY = 0.5f;

    public void OnValidate()
    {
        if (targetCamera == null)
            targetCamera = Camera.main;
        if (targetCamera != null)
        {
            // Position object within camera view
            transform.position = CameraViewUtils.GetPositionInCameraView(
                targetCamera,
                normalizedX,
                normalizedY
            );
        }
    }
}

================
File: MonoDebug/CameraSpacePositionAdjuster.cs.meta
================
fileFormatVersion: 2
guid: 58867b88740e4d247b80eb0a9d77da2e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoDebug/GizmoDebugger.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GizmoDebugger : PersistentSingleton<GizmoDebugger>
{
    [SerializeField]
    private float gizmosSize;
    private Vector2[,] cornersToDraw;
    private int count;

    public void InitData(int capacity)
    {
        cornersToDraw = new Vector2[capacity, 4];
        count = capacity;
    }

    public void UpdateData(int index, int cornerIndex, Vector2 corner)
    {
        cornersToDraw[index, cornerIndex] = corner;
    }

    void OnDrawGizmos()
    {
        if (cornersToDraw == null || cornersToDraw.Length == 0)
        {
            return;
        }

        for (int i = 0; i < count; i++)
        {
            Gizmos.DrawWireSphere(cornersToDraw[i, 0], gizmosSize);
            Gizmos.DrawWireSphere(cornersToDraw[i, 1], gizmosSize);
            Gizmos.DrawWireSphere(cornersToDraw[i, 2], gizmosSize);
            Gizmos.DrawWireSphere(cornersToDraw[i, 3], gizmosSize);
        }
    }
}

================
File: MonoDebug/GizmoDebugger.cs.meta
================
fileFormatVersion: 2
guid: c545a8b295f314a098f701047c23b4cb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoDebug/SpriteCornerDebugger.cs
================
#if UNITY_EDITOR
using UnityEngine;

[RequireComponent(typeof(SpriteRenderer))]
public class SpriteCornerDebugger : MonoBehaviour
{
    private SpriteRenderer spriteRenderer;

    [SerializeField]
    private Color gizmoColor = Color.yellow;

    [SerializeField]
    private float gizmoSize = 0.2f;

    [SerializeField]
    PerfectLineSettingSO generalGameSettingSO;

    private void OnDrawGizmos()
    {
        if (spriteRenderer == null)
            spriteRenderer = GetComponent<SpriteRenderer>();

        if (spriteRenderer == null || spriteRenderer.sprite == null)
            return;

        // Cache sprite properties
        Vector2 position = transform.position;
        Vector2 spriteSize = Vector2.Scale(spriteRenderer.sprite.bounds.size, transform.localScale);

        // Calculate half sizes
        float halfWidth = spriteSize.x / 2f;
        float halfHeight = spriteSize.y / 2f;

        // Calculate corners
        Vector2 topLeft = position + new Vector2(-halfWidth, halfHeight);
        Vector2 topRight = position + new Vector2(halfWidth, halfHeight);
        Vector2 bottomLeft = position + new Vector2(-halfWidth, -halfHeight);
        Vector2 bottomRight = position + new Vector2(halfWidth, -halfHeight);

        // Draw corners
        Gizmos.color = gizmoColor;
        DrawCorner(topLeft);
        DrawCorner(topRight);
        DrawCorner(bottomLeft);
        DrawCorner(bottomRight);

        generalGameSettingSO.TopLeft = topLeft;
        generalGameSettingSO.TopRight = topRight;
        generalGameSettingSO.BottomLeft = bottomLeft;
        generalGameSettingSO.BottomRight = bottomRight;
        generalGameSettingSO.Position = transform.position;
    }

    private void DrawCorner(Vector2 position)
    {
        Gizmos.DrawWireSphere(position, gizmoSize);
    }

    // Optional: Add this if you want to see the full bounds
    private void OnDrawGizmosSelected()
    {
        if (spriteRenderer == null || spriteRenderer.sprite == null)
            return;

        // Draw sprite bounds
        Gizmos.color = new Color(gizmoColor.r, gizmoColor.g, gizmoColor.b, 0.3f);
        Vector2 spriteSize = Vector2.Scale(spriteRenderer.sprite.bounds.size, transform.localScale);
        Gizmos.DrawWireCube(transform.position, spriteSize);
    }
}
#endif

================
File: MonoDebug/SpriteCornerDebugger.cs.meta
================
fileFormatVersion: 2
guid: 8fdea83a777f7104e8ce4b38a4e25e04
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: MonoDebug/SpriteResizer.cs
================
using UnityEngine;

[RequireComponent(typeof(SpriteRenderer))]
public class SpriteResizer : MonoBehaviour
{
    private SpriteRenderer spriteRenderer;
    private Camera targetCamera;

    [Range(0, 1)]
    [SerializeField]
    private float widthPercentage = 0.5f;

    [Range(0, 1)]
    [SerializeField]
    private float heightPercentage = 0.5f;

    [SerializeField]
    private bool maintainAspectRatio = true;

    public void OnValidate()
    {
        if (!Application.isPlaying)
        {
            Initialize();
            UpdateSize();
        }
    }

    private void Initialize()
    {
        spriteRenderer = GetComponent<SpriteRenderer>();
        targetCamera = Camera.main;
    }

    private void UpdateSize()
    {
        if (spriteRenderer == null || targetCamera == null)
            return;

        spriteRenderer.ResizeInCameraView(
            targetCamera,
            widthPercentage,
            heightPercentage,
            maintainAspectRatio
        );
    }
}

================
File: MonoDebug/SpriteResizer.cs.meta
================
fileFormatVersion: 2
guid: 3a53ba282e624be4ba23bdf1ac6887e0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Prefabs.meta
================
fileFormatVersion: 2
guid: 530960f1fceb34b6fbac957a9b2fc1f1
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Prefabs/IntroNotePrefab.prefab
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &8137537297466452066
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 6830457600340365524}
  - component: {fileID: 825267904523317309}
  m_Layer: 0
  m_Name: IntroNotePrefab
  m_TagString: Player
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &6830457600340365524
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 8137537297466452066}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: -0.37592387, y: 2.5320113, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!212 &825267904523317309
SpriteRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 8137537297466452066}
  m_Enabled: 1
  m_CastShadows: 0
  m_ReceiveShadows: 0
  m_DynamicOccludee: 1
  m_StaticShadowCaster: 0
  m_MotionVectors: 1
  m_LightProbeUsage: 1
  m_ReflectionProbeUsage: 1
  m_RayTracingMode: 0
  m_RayTraceProcedural: 0
  m_RenderingLayerMask: 1
  m_RendererPriority: 0
  m_Materials:
  - {fileID: 10754, guid: 0000000000000000f000000000000000, type: 0}
  m_StaticBatchInfo:
    firstSubMesh: 0
    subMeshCount: 0
  m_StaticBatchRoot: {fileID: 0}
  m_ProbeAnchor: {fileID: 0}
  m_LightProbeVolumeOverride: {fileID: 0}
  m_ScaleInLightmap: 1
  m_ReceiveGI: 1
  m_PreserveUVs: 0
  m_IgnoreNormalsForChartDetection: 0
  m_ImportantGI: 0
  m_StitchLightmapSeams: 1
  m_SelectedEditorRenderState: 0
  m_MinimumChartSize: 4
  m_AutoUVMaxDistance: 0.5
  m_AutoUVMaxAngle: 89
  m_LightmapParameters: {fileID: 0}
  m_SortingLayerID: 0
  m_SortingLayer: 0
  m_SortingOrder: 0
  m_Sprite: {fileID: 7482667652216324306, guid: 311925a002f4447b3a28927169b83ea6, type: 3}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_FlipX: 0
  m_FlipY: 0
  m_DrawMode: 0
  m_Size: {x: 1, y: 1}
  m_AdaptiveModeThreshold: 0.5
  m_SpriteTileMode: 0
  m_WasSpriteAssigned: 1
  m_MaskInteraction: 0
  m_SpriteSortPoint: 0

================
File: Prefabs/IntroNotePrefab.prefab.meta
================
fileFormatVersion: 2
guid: 3ab92a42b30f7d440901bcd50afe0d58
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Prefabs/LaneLinePrefab.prefab
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &856688113385644598
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 7428668525235586251}
  - component: {fileID: 3437472951177313213}
  m_Layer: 0
  m_Name: LaneLinePrefab
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &7428668525235586251
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 856688113385644598}
  serializedVersion: 2
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: -1.5051621, y: -0.030207556, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 0}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!212 &3437472951177313213
SpriteRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 856688113385644598}
  m_Enabled: 1
  m_CastShadows: 0
  m_ReceiveShadows: 0
  m_DynamicOccludee: 1
  m_StaticShadowCaster: 0
  m_MotionVectors: 1
  m_LightProbeUsage: 1
  m_ReflectionProbeUsage: 1
  m_RayTracingMode: 0
  m_RayTraceProcedural: 0
  m_RayTracingAccelStructBuildFlagsOverride: 0
  m_RayTracingAccelStructBuildFlags: 1
  m_SmallMeshCulling: 1
  m_RenderingLayerMask: 1
  m_RendererPriority: 0
  m_Materials:
  - {fileID: 10754, guid: 0000000000000000f000000000000000, type: 0}
  m_StaticBatchInfo:
    firstSubMesh: 0
    subMeshCount: 0
  m_StaticBatchRoot: {fileID: 0}
  m_ProbeAnchor: {fileID: 0}
  m_LightProbeVolumeOverride: {fileID: 0}
  m_ScaleInLightmap: 1
  m_ReceiveGI: 1
  m_PreserveUVs: 0
  m_IgnoreNormalsForChartDetection: 0
  m_ImportantGI: 0
  m_StitchLightmapSeams: 1
  m_SelectedEditorRenderState: 0
  m_MinimumChartSize: 4
  m_AutoUVMaxDistance: 0.5
  m_AutoUVMaxAngle: 89
  m_LightmapParameters: {fileID: 0}
  m_SortingLayerID: 0
  m_SortingLayer: 0
  m_SortingOrder: 0
  m_Sprite: {fileID: 7482667652216324306, guid: 311925a002f4447b3a28927169b83ea6, type: 3}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_FlipX: 0
  m_FlipY: 0
  m_DrawMode: 0
  m_Size: {x: 1, y: 1}
  m_AdaptiveModeThreshold: 0.5
  m_SpriteTileMode: 0
  m_WasSpriteAssigned: 1
  m_MaskInteraction: 0
  m_SpriteSortPoint: 0

================
File: Prefabs/LaneLinePrefab.prefab.meta
================
fileFormatVersion: 2
guid: af74a368381e1114095acf0acae2ec78
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Prefabs/LongTilePrefab.prefab
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &1080894500243719342
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1768529617924660700}
  - component: {fileID: 5546535750671264741}
  m_Layer: 0
  m_Name: Square
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &1768529617924660700
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1080894500243719342}
  serializedVersion: 2
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: -0.3876, z: 0}
  m_LocalScale: {x: 1, y: 0.22475855, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 6830457600340365524}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!212 &5546535750671264741
SpriteRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1080894500243719342}
  m_Enabled: 1
  m_CastShadows: 0
  m_ReceiveShadows: 0
  m_DynamicOccludee: 1
  m_StaticShadowCaster: 0
  m_MotionVectors: 1
  m_LightProbeUsage: 1
  m_ReflectionProbeUsage: 1
  m_RayTracingMode: 0
  m_RayTraceProcedural: 0
  m_RayTracingAccelStructBuildFlagsOverride: 0
  m_RayTracingAccelStructBuildFlags: 1
  m_SmallMeshCulling: 1
  m_RenderingLayerMask: 1
  m_RendererPriority: 0
  m_Materials:
  - {fileID: 10754, guid: 0000000000000000f000000000000000, type: 0}
  m_StaticBatchInfo:
    firstSubMesh: 0
    subMeshCount: 0
  m_StaticBatchRoot: {fileID: 0}
  m_ProbeAnchor: {fileID: 0}
  m_LightProbeVolumeOverride: {fileID: 0}
  m_ScaleInLightmap: 1
  m_ReceiveGI: 1
  m_PreserveUVs: 0
  m_IgnoreNormalsForChartDetection: 0
  m_ImportantGI: 0
  m_StitchLightmapSeams: 1
  m_SelectedEditorRenderState: 0
  m_MinimumChartSize: 4
  m_AutoUVMaxDistance: 0.5
  m_AutoUVMaxAngle: 89
  m_LightmapParameters: {fileID: 0}
  m_SortingLayerID: 0
  m_SortingLayer: 0
  m_SortingOrder: 1
  m_Sprite: {fileID: 7482667652216324306, guid: 311925a002f4447b3a28927169b83ea6, type: 3}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_FlipX: 0
  m_FlipY: 0
  m_DrawMode: 0
  m_Size: {x: 1, y: 1}
  m_AdaptiveModeThreshold: 0.5
  m_SpriteTileMode: 0
  m_WasSpriteAssigned: 1
  m_MaskInteraction: 0
  m_SpriteSortPoint: 0
--- !u!1 &8137537297466452066
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 6830457600340365524}
  - component: {fileID: 825267904523317309}
  m_Layer: 0
  m_Name: LongTilePrefab
  m_TagString: Player
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &6830457600340365524
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 8137537297466452066}
  serializedVersion: 2
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: -0.37592387, y: 2.5320113, z: 0}
  m_LocalScale: {x: 1, y: 3, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 1768529617924660700}
  m_Father: {fileID: 0}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!212 &825267904523317309
SpriteRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 8137537297466452066}
  m_Enabled: 1
  m_CastShadows: 0
  m_ReceiveShadows: 0
  m_DynamicOccludee: 1
  m_StaticShadowCaster: 0
  m_MotionVectors: 1
  m_LightProbeUsage: 1
  m_ReflectionProbeUsage: 1
  m_RayTracingMode: 0
  m_RayTraceProcedural: 0
  m_RayTracingAccelStructBuildFlagsOverride: 0
  m_RayTracingAccelStructBuildFlags: 1
  m_SmallMeshCulling: 1
  m_RenderingLayerMask: 1
  m_RendererPriority: 0
  m_Materials:
  - {fileID: 10754, guid: 0000000000000000f000000000000000, type: 0}
  m_StaticBatchInfo:
    firstSubMesh: 0
    subMeshCount: 0
  m_StaticBatchRoot: {fileID: 0}
  m_ProbeAnchor: {fileID: 0}
  m_LightProbeVolumeOverride: {fileID: 0}
  m_ScaleInLightmap: 1
  m_ReceiveGI: 1
  m_PreserveUVs: 0
  m_IgnoreNormalsForChartDetection: 0
  m_ImportantGI: 0
  m_StitchLightmapSeams: 1
  m_SelectedEditorRenderState: 0
  m_MinimumChartSize: 4
  m_AutoUVMaxDistance: 0.5
  m_AutoUVMaxAngle: 89
  m_LightmapParameters: {fileID: 0}
  m_SortingLayerID: 0
  m_SortingLayer: 0
  m_SortingOrder: 0
  m_Sprite: {fileID: 7482667652216324306, guid: 311925a002f4447b3a28927169b83ea6, type: 3}
  m_Color: {r: 0.9245283, g: 0.34451762, b: 0.34451762, a: 1}
  m_FlipX: 0
  m_FlipY: 0
  m_DrawMode: 0
  m_Size: {x: 1, y: 1}
  m_AdaptiveModeThreshold: 0.5
  m_SpriteTileMode: 0
  m_WasSpriteAssigned: 1
  m_MaskInteraction: 0
  m_SpriteSortPoint: 0

================
File: Prefabs/LongTilePrefab.prefab.meta
================
fileFormatVersion: 2
guid: 12f1ab7db8533406285c2148378e45d8
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Prefabs/musicNoteDebugger.prefab
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &6666608278722455570
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 3671549102477011096}
  - component: {fileID: 4940677685883620885}
  m_Layer: 0
  m_Name: musicNoteDebugger
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &3671549102477011096
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 6666608278722455570}
  m_LocalRotation: {x: 0, y: 0, z: -1, w: 0}
  m_LocalPosition: {x: 1.583494, y: 5.924902, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: -180}
--- !u!212 &4940677685883620885
SpriteRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 6666608278722455570}
  m_Enabled: 1
  m_CastShadows: 0
  m_ReceiveShadows: 0
  m_DynamicOccludee: 1
  m_StaticShadowCaster: 0
  m_MotionVectors: 1
  m_LightProbeUsage: 1
  m_ReflectionProbeUsage: 1
  m_RayTracingMode: 0
  m_RayTraceProcedural: 0
  m_RenderingLayerMask: 1
  m_RendererPriority: 0
  m_Materials:
  - {fileID: 10754, guid: 0000000000000000f000000000000000, type: 0}
  m_StaticBatchInfo:
    firstSubMesh: 0
    subMeshCount: 0
  m_StaticBatchRoot: {fileID: 0}
  m_ProbeAnchor: {fileID: 0}
  m_LightProbeVolumeOverride: {fileID: 0}
  m_ScaleInLightmap: 1
  m_ReceiveGI: 1
  m_PreserveUVs: 0
  m_IgnoreNormalsForChartDetection: 0
  m_ImportantGI: 0
  m_StitchLightmapSeams: 1
  m_SelectedEditorRenderState: 0
  m_MinimumChartSize: 4
  m_AutoUVMaxDistance: 0.5
  m_AutoUVMaxAngle: 89
  m_LightmapParameters: {fileID: 0}
  m_SortingLayerID: 0
  m_SortingLayer: 0
  m_SortingOrder: 2
  m_Sprite: {fileID: 7482667652216324306, guid: 75f5f34dc1b5347e0b8351032682f224, type: 3}
  m_Color: {r: 0, g: 1, b: 0.1808362, a: 1}
  m_FlipX: 0
  m_FlipY: 0
  m_DrawMode: 0
  m_Size: {x: 1, y: 1}
  m_AdaptiveModeThreshold: 0.5
  m_SpriteTileMode: 0
  m_WasSpriteAssigned: 1
  m_MaskInteraction: 0
  m_SpriteSortPoint: 0

================
File: Prefabs/musicNoteDebugger.prefab.meta
================
fileFormatVersion: 2
guid: c6b4f0197f87e492d97214d8db929d87
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Prefabs/ShortTilePrefab.prefab
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &8137537297466452066
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 6830457600340365524}
  - component: {fileID: 825267904523317309}
  m_Layer: 0
  m_Name: ShortTilePrefab
  m_TagString: Player
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &6830457600340365524
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 8137537297466452066}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: -0.37592387, y: 2.5320113, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!212 &825267904523317309
SpriteRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 8137537297466452066}
  m_Enabled: 1
  m_CastShadows: 0
  m_ReceiveShadows: 0
  m_DynamicOccludee: 1
  m_StaticShadowCaster: 0
  m_MotionVectors: 1
  m_LightProbeUsage: 1
  m_ReflectionProbeUsage: 1
  m_RayTracingMode: 0
  m_RayTraceProcedural: 0
  m_RenderingLayerMask: 1
  m_RendererPriority: 0
  m_Materials:
  - {fileID: 10754, guid: 0000000000000000f000000000000000, type: 0}
  m_StaticBatchInfo:
    firstSubMesh: 0
    subMeshCount: 0
  m_StaticBatchRoot: {fileID: 0}
  m_ProbeAnchor: {fileID: 0}
  m_LightProbeVolumeOverride: {fileID: 0}
  m_ScaleInLightmap: 1
  m_ReceiveGI: 1
  m_PreserveUVs: 0
  m_IgnoreNormalsForChartDetection: 0
  m_ImportantGI: 0
  m_StitchLightmapSeams: 1
  m_SelectedEditorRenderState: 0
  m_MinimumChartSize: 4
  m_AutoUVMaxDistance: 0.5
  m_AutoUVMaxAngle: 89
  m_LightmapParameters: {fileID: 0}
  m_SortingLayerID: 0
  m_SortingLayer: 0
  m_SortingOrder: 0
  m_Sprite: {fileID: 7482667652216324306, guid: 311925a002f4447b3a28927169b83ea6, type: 3}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_FlipX: 0
  m_FlipY: 0
  m_DrawMode: 0
  m_Size: {x: 1, y: 1}
  m_AdaptiveModeThreshold: 0.5
  m_SpriteTileMode: 0
  m_WasSpriteAssigned: 1
  m_MaskInteraction: 0
  m_SpriteSortPoint: 0

================
File: Prefabs/ShortTilePrefab.prefab.meta
================
fileFormatVersion: 2
guid: 8c1c272d019a341fa8cc13b90b199606
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings.meta
================
fileFormatVersion: 2
guid: 1a464d2bb41a7e64a9168ddd0613109c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/DataSystemSetting.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5de072596167efc49bf36d492bcabf3c, type: 3}
  m_Name: DataSystemSetting
  m_EditorClassIdentifier: 
  defaultCapacity: 64

================
File: Settings/DataSystemSetting.asset.meta
================
fileFormatVersion: 2
guid: 8dd20fefdf2161f45b1585cd5229c40d
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/GeneralGameSettings.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: b73eeb48ce0974348a172363518df0c1, type: 3}
  m_Name: GeneralGameSettings
  m_EditorClassIdentifier: 
  gameSpeed: 10
  baseScaleYForNote: 1
  midiContent: {fileID: 4900000, guid: 5651cca0434e843a4af2569038996f88, type: 3}
  shortNoteScaleYFactor: 0.7
  longNoteScaleYFactor: 3

================
File: Settings/GeneralGameSettings.asset.meta
================
fileFormatVersion: 2
guid: ed6ccf6072fffca40b837c5b9c6cf9d3
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/IntroNoteSettingSO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 185a4860fbc38974f824e4cc723a7019, type: 3}
  m_Name: IntroNoteSettingSO
  m_EditorClassIdentifier: 
  introNoteScaleYFactor: 1.1
  initLane: 2

================
File: Settings/IntroNoteSettingSO.asset.meta
================
fileFormatVersion: 2
guid: cd0407af573214940befb5cee631cb2b
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/LaneLineSettingSO.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 0622aa9a1ce990b4c97c15279952a78b, type: 3}
  m_Name: LaneLineSettingSO
  m_EditorClassIdentifier: 
  lineWidthPercentage: 0.005
  lineColor: {r: 1, g: 1, b: 1, a: 1}

================
File: Settings/LaneLineSettingSO.asset.meta
================
fileFormatVersion: 2
guid: 330727d9e2a2dd343986587e74077906
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/MusicNoteSetting.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 1dbbc6a1909167b47bf3680a5acee7e6, type: 3}
  m_Name: MusicNoteSetting
  m_EditorClassIdentifier: 
  shortNoteScaleYFactor: 1.1
  longNoteScaleYFactor: 3

================
File: Settings/MusicNoteSetting.asset.meta
================
fileFormatVersion: 2
guid: 72bffdb76f5bbab49851ad87eb3e0382
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/PerfectLineSetting.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 8b50bdfa3d8fba34a8dc54f9a818bfee, type: 3}
  m_Name: PerfectLineSetting
  m_EditorClassIdentifier: 
  TopLeft: {x: 0, y: 0}
  TopRight: {x: 0, y: 0}
  BottomLeft: {x: 0, y: 0}
  BottomRight: {x: 0, y: 0}

================
File: Settings/PerfectLineSetting.asset.meta
================
fileFormatVersion: 2
guid: a12736c430f23984f8317f2aefad4b55
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/PresenterSetting.asset
================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 663cc3f67ea124898a340a01949707e7, type: 3}
  m_Name: PresenterSetting
  m_EditorClassIdentifier: 
  shortMusicNotePresenterPrefab: {fileID: 8137537297466452066, guid: 8c1c272d019a341fa8cc13b90b199606, type: 3}
  longMusicNotePresenterPrefab: {fileID: 8137537297466452066, guid: 12f1ab7db8533406285c2148378e45d8, type: 3}
  inputDebuggerPresenterPrefab: {fileID: 6666608278722455570, guid: c6b4f0197f87e492d97214d8db929d87, type: 3}
  laneLinePresenter: {fileID: 856688113385644598, guid: af74a368381e1114095acf0acae2ec78, type: 3}
  introNotePressenyer: {fileID: 8137537297466452066, guid: 3ab92a42b30f7d440901bcd50afe0d58, type: 3}

================
File: Settings/PresenterSetting.asset.meta
================
fileFormatVersion: 2
guid: cef7bacd0c6f14627bc71745f55622fb
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO Scripts.meta
================
fileFormatVersion: 2
guid: 6d2370453581e814ebdb6add26e1b0af
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO Scripts/DataSystemSettingSO.cs
================
using UnityEngine;

[CreateAssetMenu(fileName = "DataSystemSetting", menuName = "Setting/Data System Settings")]
public class DataSystemSettingSO : ScriptableObject
{
    public int defaultCapacity = 64;
}

================
File: Settings/SO Scripts/DataSystemSettingSO.cs.meta
================
fileFormatVersion: 2
guid: 5de072596167efc49bf36d492bcabf3c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO Scripts/GeneralGameSettingSO.cs
================
using UnityEngine;

[CreateAssetMenu(fileName = "GeneralGameSettings", menuName = "Setting/General Game Settings")]
public class GeneralGameSettingSO : ScriptableObject
{
    [Header("General")]
    public int gameSpeed;
    public float baseScaleYForNote = 1;
    public TextAsset midiContent;
}

================
File: Settings/SO Scripts/GeneralGameSettingSO.cs.meta
================
fileFormatVersion: 2
guid: b73eeb48ce0974348a172363518df0c1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO Scripts/IntroNoteSettingSO.cs
================
using UnityEngine;

[CreateAssetMenu(fileName = "IntroNoteSettingSO", menuName = "Setting/IntroNoteSetting")]
public class IntroNoteSettingSO : ScriptableObject
{
    [Header("Note Configuration")]
    public float introNoteScaleYFactor = 1.1f;
    public int initLane = 2;
}

================
File: Settings/SO Scripts/IntroNoteSettingSO.cs.meta
================
fileFormatVersion: 2
guid: 185a4860fbc38974f824e4cc723a7019
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO Scripts/LaneLineSettingSO.cs
================
using UnityEngine;

[CreateAssetMenu(fileName = "LaneLineSettingSO", menuName = "Setting/LaneLineSetting")]
public class LaneLineSettingSO : ScriptableObject
{
    [Header("Visual Settings")]
    [Range(0.001f, 0.1f)]
    [Tooltip("Width of lane lines as percentage of screen width")]
    public float lineWidthPercentage = 0.01f;

    [Header("Color Settings")]
    public Color lineColor = Color.white;
}

================
File: Settings/SO Scripts/LaneLineSettingSO.cs.meta
================
fileFormatVersion: 2
guid: 0622aa9a1ce990b4c97c15279952a78b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO Scripts/MusicNoteSettingSO.cs
================
using UnityEngine;

[CreateAssetMenu(fileName = "MusicNoteSetting", menuName = "Setting/MusicNoteSetting")]
public class MusicNoteSettingSO : ScriptableObject
{
    [Header("Note Configuration")]
    public float shortNoteScaleYFactor = 1.1f;
    public float longNoteScaleYFactor = 1.5f;
}

================
File: Settings/SO Scripts/MusicNoteSettingSO.cs.meta
================
fileFormatVersion: 2
guid: 1dbbc6a1909167b47bf3680a5acee7e6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO Scripts/PerfectLineSettingSO.cs
================
using UnityEngine;

[CreateAssetMenu(fileName = "PerfectLineSetting", menuName = "Setting/Perfect Line Settings")]
public class PerfectLineSettingSO : ScriptableObject
{
    [Header("Perfect Line")]
    public Vector2 TopLeft;
    public Vector2 TopRight;
    public Vector2 BottomLeft;
    public Vector2 BottomRight;
    public Vector2 Position;

    public float PerfectLineWidth()
    {
        return TopRight.x - TopLeft.x;
    }
}

================
File: Settings/SO Scripts/PerfectLineSettingSO.cs.meta
================
fileFormatVersion: 2
guid: 8b50bdfa3d8fba34a8dc54f9a818bfee
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Settings/SO Scripts/PresenterSettingSO.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "PresenterSetting", menuName = "Setting/Presenter Settings")]
public class PresenterSettingSO : ScriptableObject
{
    [Header("Music Note Presenter")]
    public GameObject shortMusicNotePresenterPrefab;
    public GameObject longMusicNotePresenterPrefab;

    [Header("Input Deugger Presenter")]
    public GameObject inputDebuggerPresenterPrefab;

    [Header("Lane Line presenter")]
    public GameObject laneLinePresenter;

    [Header("Intro Note Presenter")]
    public GameObject introNotePressenyer;
}

================
File: Settings/SO Scripts/PresenterSettingSO.cs.meta
================
fileFormatVersion: 2
guid: 663cc3f67ea124898a340a01949707e7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
